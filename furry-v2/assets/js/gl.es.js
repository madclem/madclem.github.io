function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      return constructor.resolve(callback()).then(function() {
        return constructor.reject(reason);
      });
    }
  );
}
function allSettled(arr) {
  var P = this;
  return new P(function(resolve2, reject2) {
    if (!(arr && typeof arr.length !== "undefined")) {
      return reject2(
        new TypeError(
          typeof arr + " " + arr + " is not iterable(cannot read property Symbol(Symbol.iterator))"
        )
      );
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return resolve2([]);
    var remaining = args.length;
    function res(i2, val) {
      if (val && (typeof val === "object" || typeof val === "function")) {
        var then = val.then;
        if (typeof then === "function") {
          then.call(
            val,
            function(val2) {
              res(i2, val2);
            },
            function(e2) {
              args[i2] = { status: "rejected", reason: e2 };
              if (--remaining === 0) {
                resolve2(args);
              }
            }
          );
          return;
        }
      }
      args[i2] = { status: "fulfilled", value: val };
      if (--remaining === 0) {
        resolve2(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
}
function AggregateError$1(errors, message) {
  this.name = "AggregateError", this.errors = errors;
  this.message = message || "";
}
AggregateError$1.prototype = Error.prototype;
function any(arr) {
  var P = this;
  return new P(function(resolve2, reject2) {
    if (!(arr && typeof arr.length !== "undefined")) {
      return reject2(new TypeError("Promise.any accepts an array"));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return reject2();
    var rejectionReasons = [];
    for (var i = 0; i < args.length; i++) {
      try {
        P.resolve(args[i]).then(resolve2).catch(function(error) {
          rejectionReasons.push(error);
          if (rejectionReasons.length === args.length) {
            reject2(
              new AggregateError$1(
                rejectionReasons,
                "All promises were rejected"
              )
            );
          }
        });
      } catch (ex) {
        reject2(ex);
      }
    }
  });
}
var setTimeoutFunc = setTimeout;
function isArray$a(x2) {
  return Boolean(x2 && typeof x2.length !== "undefined");
}
function noop() {
}
function bind$2(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}
function Promise$1(fn) {
  if (!(this instanceof Promise$1))
    throw new TypeError("Promises must be constructed via new");
  if (typeof fn !== "function")
    throw new TypeError("not a function");
  this._state = 0;
  this._handled = false;
  this._value = void 0;
  this._deferreds = [];
  doResolve(fn, this);
}
function handle(self2, deferred) {
  while (self2._state === 3) {
    self2 = self2._value;
  }
  if (self2._state === 0) {
    self2._deferreds.push(deferred);
    return;
  }
  self2._handled = true;
  Promise$1._immediateFn(function() {
    var cb = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self2._state === 1 ? resolve$1 : reject$1)(deferred.promise, self2._value);
      return;
    }
    var ret;
    try {
      ret = cb(self2._value);
    } catch (e2) {
      reject$1(deferred.promise, e2);
      return;
    }
    resolve$1(deferred.promise, ret);
  });
}
function resolve$1(self2, newValue) {
  try {
    if (newValue === self2)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
      var then = newValue.then;
      if (newValue instanceof Promise$1) {
        self2._state = 3;
        self2._value = newValue;
        finale(self2);
        return;
      } else if (typeof then === "function") {
        doResolve(bind$2(then, newValue), self2);
        return;
      }
    }
    self2._state = 1;
    self2._value = newValue;
    finale(self2);
  } catch (e2) {
    reject$1(self2, e2);
  }
}
function reject$1(self2, newValue) {
  self2._state = 2;
  self2._value = newValue;
  finale(self2);
}
function finale(self2) {
  if (self2._state === 2 && self2._deferreds.length === 0) {
    Promise$1._immediateFn(function() {
      if (!self2._handled) {
        Promise$1._unhandledRejectionFn(self2._value);
      }
    });
  }
  for (var i = 0, len = self2._deferreds.length; i < len; i++) {
    handle(self2, self2._deferreds[i]);
  }
  self2._deferreds = null;
}
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
  this.onRejected = typeof onRejected === "function" ? onRejected : null;
  this.promise = promise;
}
function doResolve(fn, self2) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done)
          return;
        done = true;
        resolve$1(self2, value);
      },
      function(reason) {
        if (done)
          return;
        done = true;
        reject$1(self2, reason);
      }
    );
  } catch (ex) {
    if (done)
      return;
    done = true;
    reject$1(self2, ex);
  }
}
Promise$1.prototype["catch"] = function(onRejected) {
  return this.then(null, onRejected);
};
Promise$1.prototype.then = function(onFulfilled, onRejected) {
  var prom = new this.constructor(noop);
  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};
Promise$1.prototype["finally"] = finallyConstructor;
Promise$1.all = function(arr) {
  return new Promise$1(function(resolve2, reject2) {
    if (!isArray$a(arr)) {
      return reject2(new TypeError("Promise.all accepts an array"));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return resolve2([]);
    var remaining = args.length;
    function res(i2, val) {
      try {
        if (val && (typeof val === "object" || typeof val === "function")) {
          var then = val.then;
          if (typeof then === "function") {
            then.call(
              val,
              function(val2) {
                res(i2, val2);
              },
              reject2
            );
            return;
          }
        }
        args[i2] = val;
        if (--remaining === 0) {
          resolve2(args);
        }
      } catch (ex) {
        reject2(ex);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};
Promise$1.any = any;
Promise$1.allSettled = allSettled;
Promise$1.resolve = function(value) {
  if (value && typeof value === "object" && value.constructor === Promise$1) {
    return value;
  }
  return new Promise$1(function(resolve2) {
    resolve2(value);
  });
};
Promise$1.reject = function(value) {
  return new Promise$1(function(resolve2, reject2) {
    reject2(value);
  });
};
Promise$1.race = function(arr) {
  return new Promise$1(function(resolve2, reject2) {
    if (!isArray$a(arr)) {
      return reject2(new TypeError("Promise.race accepts an array"));
    }
    for (var i = 0, len = arr.length; i < len; i++) {
      Promise$1.resolve(arr[i]).then(resolve2, reject2);
    }
  });
};
Promise$1._immediateFn = typeof setImmediate === "function" && function(fn) {
  setImmediate(fn);
} || function(fn) {
  setTimeoutFunc(fn, 0);
};
Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== "undefined" && console) {
    console.warn("Possible Unhandled Promise Rejection:", err);
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s2 = 1; s2 < arguments.length; s2++) {
    from = Object(arguments[s2]);
    for (var key in from) {
      if (hasOwnProperty$1.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
/*!
 * @pixi/polyfill - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
if (typeof globalThis === "undefined") {
  if (typeof self !== "undefined") {
    self.globalThis = self;
  } else if (typeof global !== "undefined") {
    global.globalThis = global;
  }
}
if (!globalThis.Promise) {
  globalThis.Promise = Promise$1;
}
if (!Object.assign) {
  Object.assign = objectAssign;
}
var ONE_FRAME_TIME = 16;
if (!(Date.now && Date.prototype.getTime)) {
  Date.now = function now() {
    return new Date().getTime();
  };
}
if (!(globalThis.performance && globalThis.performance.now)) {
  var startTime_1 = Date.now();
  if (!globalThis.performance) {
    globalThis.performance = {};
  }
  globalThis.performance.now = function() {
    return Date.now() - startTime_1;
  };
}
var lastTime = Date.now();
var vendors = ["ms", "moz", "webkit", "o"];
for (var x$1 = 0; x$1 < vendors.length && !globalThis.requestAnimationFrame; ++x$1) {
  var p$1 = vendors[x$1];
  globalThis.requestAnimationFrame = globalThis[p$1 + "RequestAnimationFrame"];
  globalThis.cancelAnimationFrame = globalThis[p$1 + "CancelAnimationFrame"] || globalThis[p$1 + "CancelRequestAnimationFrame"];
}
if (!globalThis.requestAnimationFrame) {
  globalThis.requestAnimationFrame = function(callback) {
    if (typeof callback !== "function") {
      throw new TypeError(callback + "is not a function");
    }
    var currentTime = Date.now();
    var delay = ONE_FRAME_TIME + lastTime - currentTime;
    if (delay < 0) {
      delay = 0;
    }
    lastTime = currentTime;
    return globalThis.self.setTimeout(function() {
      lastTime = Date.now();
      callback(performance.now());
    }, delay);
  };
}
if (!globalThis.cancelAnimationFrame) {
  globalThis.cancelAnimationFrame = function(id) {
    return clearTimeout(id);
  };
}
if (!Math.sign) {
  Math.sign = function mathSign(x2) {
    x2 = Number(x2);
    if (x2 === 0 || isNaN(x2)) {
      return x2;
    }
    return x2 > 0 ? 1 : -1;
  };
}
if (!Number.isInteger) {
  Number.isInteger = function numberIsInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
}
if (!globalThis.ArrayBuffer) {
  globalThis.ArrayBuffer = Array;
}
if (!globalThis.Float32Array) {
  globalThis.Float32Array = Array;
}
if (!globalThis.Uint32Array) {
  globalThis.Uint32Array = Array;
}
if (!globalThis.Uint16Array) {
  globalThis.Uint16Array = Array;
}
if (!globalThis.Uint8Array) {
  globalThis.Uint8Array = Array;
}
if (!globalThis.Int32Array) {
  globalThis.Int32Array = Array;
}
/*!
 * @pixi/constants - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV || (ENV = {}));
var RENDERER_TYPE;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE || (RENDERER_TYPE = {}));
var BUFFER_BITS;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS || (BUFFER_BITS = {}));
var BLEND_MODES;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES || (BLEND_MODES = {}));
var DRAW_MODES;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES || (DRAW_MODES = {}));
var FORMATS;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS || (FORMATS = {}));
var TARGETS;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS || (TARGETS = {}));
var TYPES;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES || (TYPES = {}));
var SAMPLER_TYPES;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));
var SCALE_MODES;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES || (SCALE_MODES = {}));
var WRAP_MODES;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES || (WRAP_MODES = {}));
var MIPMAP_MODES;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES || (MIPMAP_MODES = {}));
var ALPHA_MODES;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES || (ALPHA_MODES = {}));
var CLEAR_MODES;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES || (CLEAR_MODES = {}));
var GC_MODES;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES || (GC_MODES = {}));
var PRECISION;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION || (PRECISION = {}));
var MASK_TYPES;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
  MASK_TYPES2[MASK_TYPES2["COLOR"] = 4] = "COLOR";
})(MASK_TYPES || (MASK_TYPES = {}));
var COLOR_MASK_BITS;
(function(COLOR_MASK_BITS2) {
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["RED"] = 1] = "RED";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["GREEN"] = 2] = "GREEN";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["BLUE"] = 4] = "BLUE";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["ALPHA"] = 8] = "ALPHA";
})(COLOR_MASK_BITS || (COLOR_MASK_BITS = {}));
var MSAA_QUALITY;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY || (MSAA_QUALITY = {}));
var BUFFER_TYPE;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE || (BUFFER_TYPE = {}));
/*!
 * @pixi/settings - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var BrowserAdapter = {
  createCanvas: function(width, height) {
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  },
  getWebGLRenderingContext: function() {
    return WebGLRenderingContext;
  },
  getNavigator: function() {
    return navigator;
  },
  getBaseUrl: function() {
    var _a2;
    return (_a2 = document.baseURI) !== null && _a2 !== void 0 ? _a2 : window.location.href;
  },
  fetch: function(url2, options) {
    return fetch(url2, options);
  }
};
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function(navigator2) {
  return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
};
function createMatch(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
}
function isMobile$1(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
var isMobile = isMobile$1(globalThis.navigator);
function canUploadSameBuffer() {
  return !isMobile.apple.device;
}
function maxRecommendedTextures(max2) {
  var allowMax = true;
  if (isMobile.tablet || isMobile.phone) {
    if (isMobile.apple.device) {
      var match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match) {
        var majorVersion = parseInt(match[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (isMobile.android.device) {
      var match = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (match) {
        var majorVersion = parseInt(match[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max2 : 4;
}
var settings = {
  ADAPTER: BrowserAdapter,
  MIPMAP_TEXTURES: MIPMAP_MODES.POW2,
  ANISOTROPIC_LEVEL: 0,
  RESOLUTION: 1,
  FILTER_RESOLUTION: 1,
  FILTER_MULTISAMPLE: MSAA_QUALITY.NONE,
  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
  SPRITE_BATCH_SIZE: 4096,
  RENDER_OPTIONS: {
    view: null,
    width: 800,
    height: 600,
    autoDensity: false,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: true,
    clearBeforeRender: true,
    antialias: false,
    preserveDrawingBuffer: false
  },
  GC_MODE: GC_MODES.AUTO,
  GC_MAX_IDLE: 60 * 60,
  GC_MAX_CHECK_COUNT: 60 * 10,
  WRAP_MODE: WRAP_MODES.CLAMP,
  SCALE_MODE: SCALE_MODES.LINEAR,
  PRECISION_VERTEX: PRECISION.HIGH,
  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM,
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
  CREATE_IMAGE_BITMAP: false,
  ROUND_PIXELS: false
};
var eventemitter3 = { exports: {} };
(function(module) {
  var has2 = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context2, once3) {
    this.fn = fn;
    this.context = context2;
    this.once = once3 || false;
  }
  function addListener2(emitter, event, fn, context2, once3) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context2 || emitter, once3), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames2() {
    var names = [], events2, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events2 = this._events) {
      if (has2.call(events2, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events2));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l2 = handlers.length, ee = new Array(l2); i < l2; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount2(event) {
    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len = arguments.length, args, i;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length = listeners2.length, j2;
      for (i = 0; i < length; i++) {
        if (listeners2[i].once)
          this.removeListener(event, listeners2[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners2[i].fn.call(listeners2[i].context);
            break;
          case 2:
            listeners2[i].fn.call(listeners2[i].context, a1);
            break;
          case 3:
            listeners2[i].fn.call(listeners2[i].context, a1, a2);
            break;
          case 4:
            listeners2[i].fn.call(listeners2[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
            listeners2[i].fn.apply(listeners2[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context2) {
    return addListener2(this, event, fn, context2, false);
  };
  EventEmitter2.prototype.once = function once3(event, fn, context2) {
    return addListener2(this, event, fn, context2, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener2(event, fn, context2, once3) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn && (!once3 || listeners2.once) && (!context2 || listeners2.context === context2)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events2 = [], length = listeners2.length; i < length; i++) {
        if (listeners2[i].fn !== fn || once3 && !listeners2[i].once || context2 && listeners2[i].context !== context2) {
          events2.push(listeners2[i]);
        }
      }
      if (events2.length)
        this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
var EventEmitter$1 = eventemitter3.exports;
var earcut$2 = { exports: {} };
earcut$2.exports = earcut;
earcut$2.exports.default = earcut;
function earcut(data, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  var minX, minY, maxX, maxY, x2, y2, invSize;
  if (hasHoles)
    outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];
    for (var i = dim; i < outerLen; i += dim) {
      x2 = data[i];
      y2 = data[i + 1];
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise) {
  var i, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim)
      last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim)
      last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  var p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next)
        break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  var stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a2 = ear.prev, b2 = ear, c = ear.next;
  if (area(a2, b2, c) >= 0)
    return false;
  var ax = a2.x, bx = b2.x, cx = c.x, ay = a2.y, by = b2.y, cy = c.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var p2 = c.next;
  while (p2 !== a2) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a2 = ear.prev, b2 = ear, c = ear.next;
  if (area(a2, b2, c) >= 0)
    return false;
  var ax = a2.x, bx = b2.x, cx = c.x, ay = a2.y, by = b2.y, cy = c.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  var p2 = ear.prevZ, n2 = ear.nextZ;
  while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  var p2 = start;
  do {
    var a2 = p2.prev, b2 = p2.next.next;
    if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i / dim | 0);
      triangles.push(p2.i / dim | 0);
      triangles.push(b2.i / dim | 0);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b2;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  var a2 = start;
  do {
    var b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        var c = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c = filterPoints(c, c.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [], i, len, start, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareX(a2, b2) {
  return a2.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
  do {
    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        m2 = p2.x < p2.next.x ? p2 : p2.next;
        if (x2 === hx)
          return m2;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2)
    return null;
  var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan2;
  p2 = m2;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      tan2 = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan2 < tanMin || tan2 === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
        m2 = p2;
        tanMin = tan2;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m2;
}
function sectorContainsSector(m2, p2) {
  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  var p2 = start;
  do {
    if (p2.z === 0)
      p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  var i, p2, q2, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p2 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      q2 = p2;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q2 = q2.nextZ;
        if (!q2)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q2) {
        if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
          e2 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e2 = q2;
          q2 = q2.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p2 = q2;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = (x2 - minX) * invSize | 0;
  y2 = (y2 - minY) * invSize | 0;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  var p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
      leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p2, q2, r2) {
  return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  var o1 = sign$1(area(p1, q1, p2));
  var o2 = sign$1(area(p1, q1, q2));
  var o3 = sign$1(area(p2, q2, p1));
  var o4 = sign$1(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p2, q2, r2) {
  return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
}
function sign$1(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
  var p2 = a2;
  do {
    if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
      return true;
    p2 = p2.next;
  } while (p2 !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  var p2 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
  do {
    if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  var a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i, x2, y2, last) {
  var p2 = new Node(i, x2, y2);
  if (!last) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last.next;
    p2.prev = last;
    last.next.prev = p2;
    last.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ)
    p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ)
    p2.nextZ.prevZ = p2.prevZ;
}
function Node(i, x2, y2) {
  this.i = i;
  this.x = x2;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
earcut.deviation = function(data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
  if (hasHoles) {
    for (var i = 0, len = holeIndices.length; i < len; i++) {
      var start = holeIndices[i] * dim;
      var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      polygonArea -= Math.abs(signedArea(data, start, end, dim));
    }
  }
  var trianglesArea = 0;
  for (i = 0; i < triangles.length; i += 3) {
    var a2 = triangles[i] * dim;
    var b2 = triangles[i + 1] * dim;
    var c = triangles[i + 2] * dim;
    trianglesArea += Math.abs(
      (data[a2] - data[c]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c + 1] - data[a2 + 1])
    );
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
  var sum = 0;
  for (var i = start, j2 = end - dim; i < end; i += dim) {
    sum += (data[j2] - data[i]) * (data[i + 1] + data[j2 + 1]);
    j2 = i;
  }
  return sum;
}
earcut.flatten = function(data) {
  var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i = 0; i < data.length; i++) {
    for (var j2 = 0; j2 < data[i].length; j2++) {
      for (var d2 = 0; d2 < dim; d2++)
        result.vertices.push(data[i][j2][d2]);
    }
    if (i > 0) {
      holeIndex += data[i - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};
var earcut$1 = earcut$2.exports;
var punycode$2 = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
(function(module, exports) {
  (function(root2) {
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = module && !module.nodeType && module;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal;
    if (freeGlobal2.global === freeGlobal2 || freeGlobal2.window === freeGlobal2 || freeGlobal2.self === freeGlobal2) {
      root2 = freeGlobal2;
    }
    var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, baseMinusTMin = base - tMin, floor3 = Math.floor, stringFromCharCode = String.fromCharCode, key;
    function error(type2) {
      throw new RangeError(errors[type2]);
    }
    function map4(array, fn) {
      var length = array.length;
      var result = [];
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map4(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [], counter = 0, length = string.length, value, extra;
      while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    function ucs2encode(array) {
      return map4(array, function(value) {
        var output = "";
        if (value > 65535) {
          value -= 65536;
          output += stringFromCharCode(value >>> 10 & 1023 | 55296);
          value = 56320 | value & 1023;
        }
        output += stringFromCharCode(value);
        return output;
      }).join("");
    }
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    }
    function digitToBasic(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    function adapt(delta, numPoints, firstTime) {
      var k2 = 0;
      delta = firstTime ? floor3(delta / damp) : delta >> 1;
      delta += floor3(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
        delta = floor3(delta / baseMinusTMin);
      }
      return floor3(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    function decode2(input) {
      var output = [], inputLength = input.length, out, i = 0, n2 = initialN, bias = initialBias, basic, j2, index, oldi, w2, k2, digit, t2, baseMinusT;
      basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (j2 = 0; j2 < basic; ++j2) {
        if (input.charCodeAt(j2) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j2));
      }
      for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        for (oldi = i, w2 = 1, k2 = base; ; k2 += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor3((maxInt - i) / w2)) {
            error("overflow");
          }
          i += digit * w2;
          t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (digit < t2) {
            break;
          }
          baseMinusT = base - t2;
          if (w2 > floor3(maxInt / baseMinusT)) {
            error("overflow");
          }
          w2 *= baseMinusT;
        }
        out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor3(i / out) > maxInt - n2) {
          error("overflow");
        }
        n2 += floor3(i / out);
        i %= out;
        output.splice(i++, 0, n2);
      }
      return ucs2encode(output);
    }
    function encode3(input) {
      var n2, delta, handledCPCount, basicLength, bias, j2, m2, q2, k2, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
      input = ucs2decode(input);
      inputLength = input.length;
      n2 = initialN;
      delta = 0;
      bias = initialBias;
      for (j2 = 0; j2 < inputLength; ++j2) {
        currentValue = input[j2];
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      handledCPCount = basicLength = output.length;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue >= n2 && currentValue < m2) {
            m2 = currentValue;
          }
        }
        handledCPCountPlusOne = handledCPCount + 1;
        if (m2 - n2 > floor3((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m2 - n2) * handledCPCountPlusOne;
        n2 = m2;
        for (j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue < n2 && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue == n2) {
            for (q2 = delta, k2 = base; ; k2 += base) {
              t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
              if (q2 < t2) {
                break;
              }
              qMinusT = q2 - t2;
              baseMinusT = base - t2;
              output.push(
                stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
              );
              q2 = floor3(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q2, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n2;
      }
      return output.join("");
    }
    function toUnicode(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
      });
    }
    function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode3(string) : string;
      });
    }
    punycode2 = {
      "version": "1.4.1",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode2,
      "encode": encode3,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    if (freeExports && freeModule) {
      if (module.exports == freeExports) {
        freeModule.exports = punycode2;
      } else {
        for (key in punycode2) {
          punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
        }
      }
    } else {
      root2.punycode = punycode2;
    }
  })(commonjsGlobal);
})(punycode$2, punycode$2.exports);
var esErrors = Error;
var _eval = EvalError;
var range = RangeError;
var ref = ReferenceError;
var syntax = SyntaxError;
var type = TypeError;
var uri = URIError;
var shams$1 = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams$1;
var hasSymbols$5 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var test = {
  foo: {}
};
var $Object$1 = Object;
var hasProto$2 = function hasProto() {
  return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object$1);
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var toStr$9 = Object.prototype.toString;
var max = Math.max;
var funcType = "[object Function]";
var concatty = function concatty2(a2, b2) {
  var arr = [];
  for (var i = 0; i < a2.length; i += 1) {
    arr[i] = a2[i];
  }
  for (var j2 = 0; j2 < b2.length; j2 += 1) {
    arr[j2 + a2.length] = b2[j2];
  }
  return arr;
};
var slicy = function slicy2(arrLike, offset) {
  var arr = [];
  for (var i = offset || 0, j2 = 0; i < arrLike.length; i += 1, j2 += 1) {
    arr[j2] = arrLike[i];
  }
  return arr;
};
var joiny = function(arr, joiner) {
  var str = "";
  for (var i = 0; i < arr.length; i += 1) {
    str += arr[i];
    if (i + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
var implementation$b = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$9.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slicy(arguments, 1);
  var bound2;
  var binder = function() {
    if (this instanceof bound2) {
      var result = target.apply(
        this,
        concatty(args, arguments)
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
    return target.apply(
      that,
      concatty(args, arguments)
    );
  };
  var boundLength = max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs[i] = "$" + i;
  }
  bound2 = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound2.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound2;
};
var implementation$a = implementation$b;
var functionBind = Function.prototype.bind || implementation$a;
var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind$1 = functionBind;
var hasown = bind$1.call(call, $hasOwn);
var undefined$1;
var $Error = esErrors;
var $EvalError = _eval;
var $RangeError$1 = range;
var $ReferenceError = ref;
var $SyntaxError$5 = syntax;
var $TypeError$p = type;
var $URIError = uri;
var $Function = Function;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e2) {
  }
};
var $gOPD$2 = Object.getOwnPropertyDescriptor;
if ($gOPD$2) {
  try {
    $gOPD$2({}, "");
  } catch (e2) {
    $gOPD$2 = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$p();
};
var ThrowTypeError = $gOPD$2 ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD$2(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$4 = hasSymbols$5();
var hasProto$1 = hasProto$2();
var getProto$1 = Object.getPrototypeOf || (hasProto$1 ? function(x2) {
  return x2.__proto__;
} : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$4 && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$4 && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$4 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError$1,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$4 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$4 && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$4 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$5,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$p,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
if (getProto$1) {
  try {
    null.error;
  } catch (e2) {
    var errorProto = getProto$1(getProto$1(e2));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto$1) {
      value = getProto$1(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind2 = functionBind;
var hasOwn$8 = hasown;
var $concat$1 = bind2.call(Function.call, Array.prototype.concat);
var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
var $replace$2 = bind2.call(Function.call, String.prototype.replace);
var $strSlice$1 = bind2.call(Function.call, String.prototype.slice);
var $exec$2 = bind2.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice$1(string, 0, 1);
  var last = $strSlice$1(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError$5("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError$5("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace$2(string, rePropName, function(match, number, quote2, subString) {
    result[result.length] = quote2 ? $replace$2(subString, reEscapeChar, "$1") : number || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$8(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$8(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$p("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError$5("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$p("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$p('"allowMissing" argument must be a boolean');
  }
  if ($exec$2(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError$5("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat$1([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice$1(part, 0, 1);
    var last = $strSlice$1(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError$5("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$8(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$p("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$2 && i + 1 >= parts.length) {
        var desc = $gOPD$2(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$8(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$5 = { exports: {} };
var GetIntrinsic$x = getIntrinsic;
var $defineProperty$2 = GetIntrinsic$x("%Object.defineProperty%", true);
var hasPropertyDescriptors$2 = function hasPropertyDescriptors() {
  if ($defineProperty$2) {
    try {
      $defineProperty$2({}, "a", { value: 1 });
      return true;
    } catch (e2) {
      return false;
    }
  }
  return false;
};
hasPropertyDescriptors$2.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!hasPropertyDescriptors$2()) {
    return null;
  }
  try {
    return $defineProperty$2([], "length", { value: 1 }).length !== 1;
  } catch (e2) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors$2;
var GetIntrinsic$w = getIntrinsic;
var $gOPD$1 = GetIntrinsic$w("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD$1) {
  try {
    $gOPD$1([], "length");
  } catch (e2) {
    $gOPD$1 = null;
  }
}
var gopd$1 = $gOPD$1;
var hasPropertyDescriptors$1 = hasPropertyDescriptors_1();
var GetIntrinsic$v = getIntrinsic;
var $defineProperty$1 = hasPropertyDescriptors$1 && GetIntrinsic$v("%Object.defineProperty%", true);
if ($defineProperty$1) {
  try {
    $defineProperty$1({}, "a", { value: 1 });
  } catch (e2) {
    $defineProperty$1 = false;
  }
}
var $SyntaxError$4 = syntax;
var $TypeError$o = type;
var gopd = gopd$1;
var defineDataProperty$1 = function defineDataProperty(obj, property, value) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new $TypeError$o("`obj` must be an object or a function`");
  }
  if (typeof property !== "string" && typeof property !== "symbol") {
    throw new $TypeError$o("`property` must be a string or a symbol`");
  }
  if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
    throw new $TypeError$o("`nonEnumerable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
    throw new $TypeError$o("`nonWritable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
    throw new $TypeError$o("`nonConfigurable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
    throw new $TypeError$o("`loose`, if provided, must be a boolean");
  }
  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;
  var desc = !!gopd && gopd(obj, property);
  if ($defineProperty$1) {
    $defineProperty$1(obj, property, {
      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
      value,
      writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    obj[property] = value;
  } else {
    throw new $SyntaxError$4("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }
};
var GetIntrinsic$u = getIntrinsic;
var define$6 = defineDataProperty$1;
var hasDescriptors = hasPropertyDescriptors_1();
var gOPD$1 = gopd$1;
var $TypeError$n = type;
var $floor$4 = GetIntrinsic$u("%Math.floor%");
var setFunctionLength = function setFunctionLength2(fn, length) {
  if (typeof fn !== "function") {
    throw new $TypeError$n("`fn` is not a function");
  }
  if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor$4(length) !== length) {
    throw new $TypeError$n("`length` must be a positive 32-bit integer");
  }
  var loose = arguments.length > 2 && !!arguments[2];
  var functionLengthIsConfigurable = true;
  var functionLengthIsWritable = true;
  if ("length" in fn && gOPD$1) {
    var desc = gOPD$1(fn, "length");
    if (desc && !desc.configurable) {
      functionLengthIsConfigurable = false;
    }
    if (desc && !desc.writable) {
      functionLengthIsWritable = false;
    }
  }
  if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
    if (hasDescriptors) {
      define$6(fn, "length", length, true, true);
    } else {
      define$6(fn, "length", length);
    }
  }
  return fn;
};
(function(module) {
  var bind3 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var setFunctionLength$1 = setFunctionLength;
  var $TypeError2 = type;
  var $apply2 = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply2);
  var $defineProperty2 = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty2) {
    try {
      $defineProperty2({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty2 = null;
    }
  }
  module.exports = function callBind2(originalFunction) {
    if (typeof originalFunction !== "function") {
      throw new $TypeError2("a function is required");
    }
    var func = $reflectApply(bind3, $call, arguments);
    return setFunctionLength$1(
      func,
      1 + $max(0, originalFunction.length - (arguments.length - 1)),
      true
    );
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply2, arguments);
  };
  if ($defineProperty2) {
    $defineProperty2(module.exports, "apply", { value: applyBind });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$5);
var GetIntrinsic$t = getIntrinsic;
var callBind$4 = callBind$5.exports;
var $indexOf = callBind$4(GetIntrinsic$t("String.prototype.indexOf"));
var callBound$b = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic$t(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
    return callBind$4(intrinsic);
  }
  return intrinsic;
};
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize$1 = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString$2 = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice$1 = String.prototype.slice;
var $replace$1 = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor$3 = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable$1 = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
  return O.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor$3(-num) : $floor$3(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice$1.call(str, intStr.length + 1);
      return $replace$1.call(intStr, sepRegex, "$&_") + "." + $replace$1.call($replace$1.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace$1.call(str, sepRegex, "$&_");
}
var utilInspect = require$$0;
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol$4(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options, depth, seen) {
  var opts = options || {};
  if (has$5(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$5(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$5(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$5(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$5(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$9(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$5(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === "function" && !isRegExp$3(obj)) {
    var name = nameOf(obj);
    var keys3 = arrObjKeys(obj, inspect2);
    return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys3.length > 0 ? " { " + $join.call(keys3, ", ") + " }" : "");
  }
  if (isSymbol$4(obj)) {
    var symString = hasShammedSymbols ? $replace$1.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i = 0; i < attrs.length; i++) {
      s2 += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
    }
    s2 += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s2 += "...";
    }
    s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s2;
  }
  if (isArray$9(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect2);
    if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable$1.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
      return utilInspect(obj, { depth: maxDepth - depth });
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap$2(obj)) {
    var mapParts = [];
    if (mapForEach) {
      mapForEach.call(obj, function(value, key) {
        mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
      });
    }
    return collectionOf("Map", mapSize$1.call(obj), mapParts, indent);
  }
  if (isSet$2(obj)) {
    var setParts = [];
    if (setForEach) {
      setForEach.call(obj, function(value) {
        setParts.push(inspect2(value, obj));
      });
    }
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString$3(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (typeof window !== "undefined" && obj === window) {
    return "{ [object Window] }";
  }
  if (obj === commonjsGlobal) {
    return "{ [object globalThis] }";
  }
  if (!isDate$1(obj) && !isRegExp$3(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice$1.call(toStr$8(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s2, defaultStyle2, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle2) === "double" ? '"' : "'";
  return quoteChar + s2 + quoteChar;
}
function quote(s2) {
  return $replace$1.call(String(s2), /"/g, "&quot;");
}
function isArray$9(obj) {
  return toStr$8(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate$1(obj) {
  return toStr$8(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$3(obj) {
  return toStr$8(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr$8(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString$3(obj) {
  return toStr$8(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber(obj) {
  return toStr$8(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr$8(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol$4(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
var hasOwn$7 = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has$5(obj, key) {
  return hasOwn$7.call(obj, key);
}
function toStr$8(obj) {
  return objectToString$2.call(obj);
}
function nameOf(f2) {
  if (f2.name) {
    return f2.name;
  }
  var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
  if (m2) {
    return m2[1];
  }
  return null;
}
function indexOf(xs, x2) {
  if (xs.indexOf) {
    return xs.indexOf(x2);
  }
  for (var i = 0, l2 = xs.length; i < l2; i++) {
    if (xs[i] === x2) {
      return i;
    }
  }
  return -1;
}
function isMap$2(x2) {
  if (!mapSize$1 || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    mapSize$1.call(x2);
    try {
      setSize.call(x2);
    } catch (s2) {
      return true;
    }
    return x2 instanceof Map;
  } catch (e2) {
  }
  return false;
}
function isWeakMap(x2) {
  if (!weakMapHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x2, weakMapHas);
    try {
      weakSetHas.call(x2, weakSetHas);
    } catch (s2) {
      return true;
    }
    return x2 instanceof WeakMap;
  } catch (e2) {
  }
  return false;
}
function isWeakRef(x2) {
  if (!weakRefDeref || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x2);
    return true;
  } catch (e2) {
  }
  return false;
}
function isSet$2(x2) {
  if (!setSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    setSize.call(x2);
    try {
      mapSize$1.call(x2);
    } catch (m2) {
      return true;
    }
    return x2 instanceof Set;
  } catch (e2) {
  }
  return false;
}
function isWeakSet(x2) {
  if (!weakSetHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x2, weakSetHas);
    try {
      weakMapHas.call(x2, weakMapHas);
    } catch (s2) {
      return true;
    }
    return x2 instanceof WeakSet;
  } catch (e2) {
  }
  return false;
}
function isElement(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
    return true;
  }
  return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice$1.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var s2 = $replace$1.call($replace$1.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s2, "single", opts);
}
function lowbyte(c) {
  var n2 = c.charCodeAt(0);
  var x2 = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n2];
  if (x2) {
    return "\\" + x2;
  }
  return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type2) {
  return type2 + " { ? }";
}
function collectionOf(type2, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type2 + " (" + size + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i = 0; i < xs.length; i++) {
    if (indexOf(xs[i], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$9(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i = 0; i < obj.length; i++) {
      xs[i] = has$5(obj, i) ? inspect2(obj[i], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k2 = 0; k2 < syms.length; k2++) {
      symMap["$" + syms[k2]] = syms[k2];
    }
  }
  for (var key in obj) {
    if (!has$5(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
    } else {
      xs.push(key + ": " + inspect2(obj[key], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j2 = 0; j2 < syms.length; j2++) {
      if (isEnumerable$1.call(obj, syms[j2])) {
        xs.push("[" + inspect2(syms[j2]) + "]: " + inspect2(obj[syms[j2]], obj));
      }
    }
  }
  return xs;
}
var GetIntrinsic$s = getIntrinsic;
var callBound$a = callBound$b;
var inspect$1 = objectInspect;
var $TypeError$m = type;
var $WeakMap = GetIntrinsic$s("%WeakMap%", true);
var $Map$3 = GetIntrinsic$s("%Map%", true);
var $weakMapGet = callBound$a("WeakMap.prototype.get", true);
var $weakMapSet = callBound$a("WeakMap.prototype.set", true);
var $weakMapHas = callBound$a("WeakMap.prototype.has", true);
var $mapGet = callBound$a("Map.prototype.get", true);
var $mapSet = callBound$a("Map.prototype.set", true);
var $mapHas$2 = callBound$a("Map.prototype.has", true);
var listGetNode = function(list, key) {
  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      curr.next = list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  var node = listGetNode(objects, key);
  return node && node.value;
};
var listSet = function(objects, key, value) {
  var node = listGetNode(objects, key);
  if (node) {
    node.value = value;
  } else {
    objects.next = {
      key,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key) {
  return !!listGetNode(objects, key);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel2 = {
    assert: function(key) {
      if (!channel2.has(key)) {
        throw new $TypeError$m("Side channel does not contain " + inspect$1(key));
      }
    },
    get: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map$3) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o) {
          return listGet($o, key);
        }
      }
    },
    has: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map$3) {
        if ($m) {
          return $mapHas$2($m, key);
        }
      } else {
        if ($o) {
          return listHas($o, key);
        }
      }
      return false;
    },
    set: function(key, value) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key, value);
      } else if ($Map$3) {
        if (!$m) {
          $m = new $Map$3();
        }
        $mapSet($m, key, value);
      } else {
        if (!$o) {
          $o = { key: {}, next: null };
        }
        listSet($o, key, value);
      }
    }
  };
  return channel2;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$4 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$3 = formats$4;
var has$4 = Object.prototype.hasOwnProperty;
var isArray$8 = Array.isArray;
var hexTable = function() {
  var array = [];
  for (var i = 0; i < 256; ++i) {
    array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array;
}();
var compactQueue = function compactQueue2(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];
    if (isArray$8(obj)) {
      var compacted = [];
      for (var j2 = 0; j2 < obj.length; ++j2) {
        if (typeof obj[j2] !== "undefined") {
          compacted.push(obj[j2]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options) {
  var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i = 0; i < source.length; ++i) {
    if (typeof source[i] !== "undefined") {
      obj[i] = source[i];
    }
  }
  return obj;
};
var merge = function merge2(target, source, options) {
  if (!source) {
    return target;
  }
  if (typeof source !== "object") {
    if (isArray$8(target)) {
      target.push(source);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$4.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray$8(target) && !isArray$8(source)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$8(target) && isArray$8(source)) {
    source.forEach(function(item, i) {
      if (has$4.call(target, i)) {
        var targetItem = target[i];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i] = merge2(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function(acc, key) {
    var value = source[key];
    if (has$4.call(acc, key)) {
      acc[key] = merge2(acc[key], value, options);
    } else {
      acc[key] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function(acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};
var decode = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e2) {
    return strWithoutPlus;
  }
};
var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
  if (str.length === 0) {
    return str;
  }
  var string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i = 0; i < string.length; ++i) {
    var c = string.charCodeAt(i);
    if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format2 === formats$3.RFC1738 && (c === 40 || c === 41)) {
      out += string.charAt(i);
      continue;
    }
    if (c < 128) {
      out = out + hexTable[c];
      continue;
    }
    if (c < 2048) {
      out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
      continue;
    }
    if (c < 55296 || c >= 57344) {
      out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
      continue;
    }
    i += 1;
    c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
    out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
  }
  return out;
};
var compact = function compact2(value) {
  var queue = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i = 0; i < queue.length; ++i) {
    var item = queue[i];
    var obj = item.obj[item.prop];
    var keys3 = Object.keys(obj);
    for (var j2 = 0; j2 < keys3.length; ++j2) {
      var key = keys3[j2];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue.push({ obj, prop: key });
        refs.push(val);
      }
    }
  }
  compactQueue(queue);
  return value;
};
var isRegExp$2 = function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a2, b2) {
  return [].concat(a2, b2);
};
var maybeMap = function maybeMap2(val, fn) {
  if (isArray$8(val)) {
    var mapped = [];
    for (var i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
};
var utils$2 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode,
  encode,
  isBuffer,
  isRegExp: isRegExp$2,
  maybeMap,
  merge
};
var getSideChannel2 = sideChannel;
var utils$1 = utils$2;
var formats$2 = formats$4;
var has$3 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + "[]";
  },
  comma: "comma",
  indices: function indices(prefix, key) {
    return prefix + "[" + key + "]";
  },
  repeat: function repeat(prefix) {
    return prefix;
  }
};
var isArray$7 = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push.apply(arr, isArray$7(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$2["default"];
var defaults$1 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$2.formatters[defaultFormat],
  indices: false,
  serializeDate: function serializeDate(date) {
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
  return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
};
var sentinel = {};
var stringify$1 = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate2, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object;
  var tmpSc = sideChannel2;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
    var pos = tmpSc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        findFlag = true;
      }
    }
    if (typeof tmpSc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$7(obj)) {
    obj = utils$1.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, "key", format2) : prefix;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, "key", format2);
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format2))];
    }
    return [formatter(prefix) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$7(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = utils$1.maybeMap(obj, encoder);
    }
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$7(filter)) {
    objKeys = filter;
  } else {
    var keys3 = Object.keys(obj);
    objKeys = sort ? keys3.sort(sort) : keys3;
  }
  var adjustedPrefix = commaRoundTrip && isArray$7(obj) && obj.length === 1 ? prefix + "[]" : prefix;
  for (var j2 = 0; j2 < objKeys.length; ++j2) {
    var key = objKeys[j2];
    var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    var keyPrefix = isArray$7(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
    sideChannel2.set(object, step);
    var valueSideChannel = getSideChannel2();
    valueSideChannel.set(sentinel, sideChannel2);
    pushToArray(values, stringify(
      value,
      keyPrefix,
      generateArrayPrefix,
      commaRoundTrip,
      strictNullHandling,
      skipNulls,
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray$7(obj) ? null : encoder,
      filter,
      sort,
      allowDots,
      serializeDate2,
      format2,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$1.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format2 = formats$2["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$3.call(formats$2.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  var formatter = formats$2.formatters[format2];
  var filter = defaults$1.filter;
  if (typeof opts.filter === "function" || isArray$7(opts.filter)) {
    filter = opts.filter;
  }
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var stringify_1 = function(object, opts) {
  var obj = object;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (isArray$7(options.filter)) {
    filter = options.filter;
    objKeys = filter;
  }
  var keys3 = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && "indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel2 = getSideChannel2();
  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    pushToArray(keys3, stringify$1(
      obj[key],
      key,
      generateArrayPrefix,
      commaRoundTrip,
      options.strictNullHandling,
      options.skipNulls,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel2
    ));
  }
  var joined = keys3.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
};
var utils = utils$2;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$6 = Array.isArray;
var defaults = {
  allowDots: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = { __proto__: null };
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1;
  var i;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i = 0; i < parts.length; ++i) {
      if (parts[i].indexOf("utf8=") === 0) {
        if (parts[i] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i;
        i = parts.length;
      }
    }
  }
  for (i = 0; i < parts.length; ++i) {
    if (i === skipIndex) {
      continue;
    }
    var part = parts[i];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key, val;
    if (pos === -1) {
      key = options.decoder(part, defaults.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
      val = utils.maybeMap(
        parseArrayValue(part.slice(pos + 1), options),
        function(encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, "value");
        }
      );
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray$6(val) ? [val] : val;
    }
    if (has$2.call(obj, key)) {
      obj[key] = utils.combine(obj[key], val);
    } else {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i = chain.length - 1; i >= 0; --i) {
    var obj;
    var root2 = chain[i];
    if (root2 === "[]" && options.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
      var index = parseInt(cleanRoot, 10);
      if (!options.parseArrays && cleanRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index) && root2 !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
        obj = [];
        obj[index] = leaf;
      } else if (cleanRoot !== "__proto__") {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key);
  var parent = segment ? key.slice(0, segment.index) : key;
  var keys3 = [];
  if (parent) {
    if (!options.plainObjects && has$2.call(Object.prototype, parent)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys3.push(parent);
  }
  var i = 0;
  while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
    i += 1;
    if (!options.plainObjects && has$2.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys3.push(segment[1]);
  }
  if (segment) {
    keys3.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys3, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults;
  }
  if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
};
var parse$2 = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  var keys3 = Object.keys(tempObj);
  for (var i = 0; i < keys3.length; ++i) {
    var key = keys3[i];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
    obj = utils.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils.compact(obj);
};
var stringify2 = stringify_1;
var parse$1 = parse$2;
var formats$1 = formats$4;
var lib = {
  formats: formats$1,
  parse: parse$1,
  stringify: stringify2
};
var punycode$1 = punycode$2.exports;
function Url$1() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, delims = [
  "<",
  ">",
  '"',
  "`",
  " ",
  "\r",
  "\n",
  "	"
], unwise = [
  "{",
  "}",
  "|",
  "\\",
  "^",
  "`"
].concat(delims), autoEscape$1 = ["'"].concat(unwise), nonHostChars = [
  "%",
  "/",
  "?",
  ";",
  "#"
].concat(autoEscape$1), hostEndingChars = [
  "/",
  "?",
  "#"
], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  javascript: true,
  "javascript:": true
}, hostlessProtocol = {
  javascript: true,
  "javascript:": true
}, slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
}, querystring$1 = lib;
function urlParse(url2, parseQueryString, slashesDenoteHost) {
  if (url2 && typeof url2 === "object" && url2 instanceof Url$1) {
    return url2;
  }
  var u2 = new Url$1();
  u2.parse(url2, parseQueryString, slashesDenoteHost);
  return u2;
}
Url$1.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
  if (typeof url2 !== "string") {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
  }
  var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url2 = uSplit.join(splitter);
  var rest = url2;
  rest = rest.trim();
  if (!slashesDenoteHost && url2.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring$1.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      return this;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost();
    this.hostname = this.hostname || "";
    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l2 = hostparts.length; i < l2; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j2 = 0, k2 = part.length; j2 < k2; j2++) {
            if (part.charCodeAt(j2) > 127) {
              newpart += "x";
            } else {
              newpart += part[j2];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    } else {
      this.hostname = this.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      this.hostname = punycode$1.toASCII(this.hostname);
    }
    var p2 = this.port ? ":" + this.port : "";
    var h2 = this.hostname || "";
    this.host = h2 + p2;
    this.href += this.host;
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (var i = 0, l2 = autoEscape$1.length; i < l2; i++) {
      var ae = autoEscape$1[i];
      if (rest.indexOf(ae) === -1) {
        continue;
      }
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }
  var hash = rest.indexOf("#");
  if (hash !== -1) {
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring$1.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    this.search = "";
    this.query = {};
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "/";
  }
  if (this.pathname || this.search) {
    var p2 = this.pathname || "";
    var s2 = this.search || "";
    this.path = p2 + s2;
  }
  this.href = this.format();
  return this;
};
function urlFormat(obj) {
  if (typeof obj === "string") {
    obj = urlParse(obj);
  }
  if (!(obj instanceof Url$1)) {
    return Url$1.prototype.format.call(obj);
  }
  return obj.format();
}
Url$1.prototype.format = function() {
  var auth = this.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
    if (this.port) {
      host += ":" + this.port;
    }
  }
  if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
    query = querystring$1.stringify(this.query, {
      arrayFormat: "repeat",
      addQueryPrefix: false
    });
  }
  var search = this.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":") {
    protocol += ":";
  }
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/") {
      pathname = "/" + pathname;
    }
  } else if (!host) {
    host = "";
  }
  if (hash && hash.charAt(0) !== "#") {
    hash = "#" + hash;
  }
  if (search && search.charAt(0) !== "?") {
    search = "?" + search;
  }
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash;
};
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
Url$1.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};
Url$1.prototype.resolveObject = function(relative) {
  if (typeof relative === "string") {
    var rel = new Url$1();
    rel.parse(relative, false, true);
    relative = rel;
  }
  var result = new Url$1();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }
  result.hash = relative.hash;
  if (relative.href === "") {
    result.href = result.format();
    return result;
  }
  if (relative.slashes && !relative.protocol) {
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== "protocol") {
        result[rkey] = relative[rkey];
      }
    }
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = "/";
      result.path = result.pathname;
    }
    result.href = result.format();
    return result;
  }
  if (relative.protocol && relative.protocol !== result.protocol) {
    if (!slashedProtocol[relative.protocol]) {
      var keys3 = Object.keys(relative);
      for (var v2 = 0; v2 < keys3.length; v2++) {
        var k2 = keys3[v2];
        result[k2] = relative[k2];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || "").split("/");
      while (relPath.length && !(relative.host = relPath.shift())) {
      }
      if (!relative.host) {
        relative.host = "";
      }
      if (!relative.hostname) {
        relative.hostname = "";
      }
      if (relPath[0] !== "") {
        relPath.unshift("");
      }
      if (relPath.length < 2) {
        relPath.unshift("");
      }
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || "";
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    if (result.pathname || result.search) {
      var p2 = result.pathname || "";
      var s2 = result.search || "";
      result.path = p2 + s2;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
  if (psychotic) {
    result.hostname = "";
    result.port = null;
    if (result.host) {
      if (srcPath[0] === "") {
        srcPath[0] = result.host;
      } else {
        srcPath.unshift(result.host);
      }
    }
    result.host = "";
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === "") {
          relPath[0] = relative.host;
        } else {
          relPath.unshift(relative.host);
        }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  if (isRelAbs) {
    result.host = relative.host || relative.host === "" ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath) {
      srcPath = [];
    }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = "/" + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === ".") {
      srcPath.splice(i, 1);
    } else if (last === "..") {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
  if (psychotic) {
    result.hostname = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
    result.host = result.hostname;
    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift("");
  }
  if (srcPath.length > 0) {
    result.pathname = srcPath.join("/");
  } else {
    result.pathname = null;
    result.path = null;
  }
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};
Url$1.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse = urlParse;
var resolve = urlResolve;
var format = urlFormat;
/*!
 * @pixi/utils - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var url = {
  parse,
  format,
  resolve
};
settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
var saidHello = false;
var VERSION = "6.5.10";
function sayHello(type2) {
  var _a2;
  if (saidHello) {
    return;
  }
  if (settings.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
    var args = [
      "\n %c %c %c PixiJS " + VERSION + " - \u2730 " + type2 + " \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n",
      "background: #ff66a5; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "color: #ff66a5; background: #030307; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "background: #ffc3dc; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;"
    ];
    (_a2 = globalThis.console).log.apply(_a2, args);
  } else if (globalThis.console) {
    globalThis.console.log("PixiJS " + VERSION + " - " + type2 + " - http://www.pixijs.com/");
  }
  saidHello = true;
}
var supported;
function isWebGLSupported() {
  if (typeof supported === "undefined") {
    supported = function supported2() {
      var contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!settings.ADAPTER.getWebGLRenderingContext()) {
          return false;
        }
        var canvas = settings.ADAPTER.createCanvas();
        var gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
        var success = !!(gl && gl.getContextAttributes().stencil);
        if (gl) {
          var loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e2) {
        return false;
      }
    }();
  }
  return supported;
}
var aliceblue = "#f0f8ff";
var antiquewhite = "#faebd7";
var aqua = "#00ffff";
var aquamarine = "#7fffd4";
var azure = "#f0ffff";
var beige = "#f5f5dc";
var bisque = "#ffe4c4";
var black = "#000000";
var blanchedalmond = "#ffebcd";
var blue = "#0000ff";
var blueviolet = "#8a2be2";
var brown = "#a52a2a";
var burlywood = "#deb887";
var cadetblue = "#5f9ea0";
var chartreuse = "#7fff00";
var chocolate = "#d2691e";
var coral = "#ff7f50";
var cornflowerblue = "#6495ed";
var cornsilk = "#fff8dc";
var crimson = "#dc143c";
var cyan = "#00ffff";
var darkblue = "#00008b";
var darkcyan = "#008b8b";
var darkgoldenrod = "#b8860b";
var darkgray = "#a9a9a9";
var darkgreen = "#006400";
var darkgrey = "#a9a9a9";
var darkkhaki = "#bdb76b";
var darkmagenta = "#8b008b";
var darkolivegreen = "#556b2f";
var darkorange = "#ff8c00";
var darkorchid = "#9932cc";
var darkred = "#8b0000";
var darksalmon = "#e9967a";
var darkseagreen = "#8fbc8f";
var darkslateblue = "#483d8b";
var darkslategray = "#2f4f4f";
var darkslategrey = "#2f4f4f";
var darkturquoise = "#00ced1";
var darkviolet = "#9400d3";
var deeppink = "#ff1493";
var deepskyblue = "#00bfff";
var dimgray = "#696969";
var dimgrey = "#696969";
var dodgerblue = "#1e90ff";
var firebrick = "#b22222";
var floralwhite = "#fffaf0";
var forestgreen = "#228b22";
var fuchsia = "#ff00ff";
var gainsboro = "#dcdcdc";
var ghostwhite = "#f8f8ff";
var goldenrod = "#daa520";
var gold = "#ffd700";
var gray = "#808080";
var green = "#008000";
var greenyellow = "#adff2f";
var grey = "#808080";
var honeydew = "#f0fff0";
var hotpink = "#ff69b4";
var indianred = "#cd5c5c";
var indigo = "#4b0082";
var ivory = "#fffff0";
var khaki = "#f0e68c";
var lavenderblush = "#fff0f5";
var lavender = "#e6e6fa";
var lawngreen = "#7cfc00";
var lemonchiffon = "#fffacd";
var lightblue = "#add8e6";
var lightcoral = "#f08080";
var lightcyan = "#e0ffff";
var lightgoldenrodyellow = "#fafad2";
var lightgray = "#d3d3d3";
var lightgreen = "#90ee90";
var lightgrey = "#d3d3d3";
var lightpink = "#ffb6c1";
var lightsalmon = "#ffa07a";
var lightseagreen = "#20b2aa";
var lightskyblue = "#87cefa";
var lightslategray = "#778899";
var lightslategrey = "#778899";
var lightsteelblue = "#b0c4de";
var lightyellow = "#ffffe0";
var lime = "#00ff00";
var limegreen = "#32cd32";
var linen = "#faf0e6";
var magenta = "#ff00ff";
var maroon = "#800000";
var mediumaquamarine = "#66cdaa";
var mediumblue = "#0000cd";
var mediumorchid = "#ba55d3";
var mediumpurple = "#9370db";
var mediumseagreen = "#3cb371";
var mediumslateblue = "#7b68ee";
var mediumspringgreen = "#00fa9a";
var mediumturquoise = "#48d1cc";
var mediumvioletred = "#c71585";
var midnightblue = "#191970";
var mintcream = "#f5fffa";
var mistyrose = "#ffe4e1";
var moccasin = "#ffe4b5";
var navajowhite = "#ffdead";
var navy = "#000080";
var oldlace = "#fdf5e6";
var olive = "#808000";
var olivedrab = "#6b8e23";
var orange = "#ffa500";
var orangered = "#ff4500";
var orchid = "#da70d6";
var palegoldenrod = "#eee8aa";
var palegreen = "#98fb98";
var paleturquoise = "#afeeee";
var palevioletred = "#db7093";
var papayawhip = "#ffefd5";
var peachpuff = "#ffdab9";
var peru = "#cd853f";
var pink = "#ffc0cb";
var plum = "#dda0dd";
var powderblue = "#b0e0e6";
var purple = "#800080";
var rebeccapurple = "#663399";
var red = "#ff0000";
var rosybrown = "#bc8f8f";
var royalblue = "#4169e1";
var saddlebrown = "#8b4513";
var salmon = "#fa8072";
var sandybrown = "#f4a460";
var seagreen = "#2e8b57";
var seashell = "#fff5ee";
var sienna = "#a0522d";
var silver = "#c0c0c0";
var skyblue = "#87ceeb";
var slateblue = "#6a5acd";
var slategray = "#708090";
var slategrey = "#708090";
var snow = "#fffafa";
var springgreen = "#00ff7f";
var steelblue = "#4682b4";
var tan = "#d2b48c";
var teal = "#008080";
var thistle = "#d8bfd8";
var tomato = "#ff6347";
var turquoise = "#40e0d0";
var violet = "#ee82ee";
var wheat = "#f5deb3";
var white = "#ffffff";
var whitesmoke = "#f5f5f5";
var yellow = "#ffff00";
var yellowgreen = "#9acd32";
var cssColorNames = {
  aliceblue,
  antiquewhite,
  aqua,
  aquamarine,
  azure,
  beige,
  bisque,
  black,
  blanchedalmond,
  blue,
  blueviolet,
  brown,
  burlywood,
  cadetblue,
  chartreuse,
  chocolate,
  coral,
  cornflowerblue,
  cornsilk,
  crimson,
  cyan,
  darkblue,
  darkcyan,
  darkgoldenrod,
  darkgray,
  darkgreen,
  darkgrey,
  darkkhaki,
  darkmagenta,
  darkolivegreen,
  darkorange,
  darkorchid,
  darkred,
  darksalmon,
  darkseagreen,
  darkslateblue,
  darkslategray,
  darkslategrey,
  darkturquoise,
  darkviolet,
  deeppink,
  deepskyblue,
  dimgray,
  dimgrey,
  dodgerblue,
  firebrick,
  floralwhite,
  forestgreen,
  fuchsia,
  gainsboro,
  ghostwhite,
  goldenrod,
  gold,
  gray,
  green,
  greenyellow,
  grey,
  honeydew,
  hotpink,
  indianred,
  indigo,
  ivory,
  khaki,
  lavenderblush,
  lavender,
  lawngreen,
  lemonchiffon,
  lightblue,
  lightcoral,
  lightcyan,
  lightgoldenrodyellow,
  lightgray,
  lightgreen,
  lightgrey,
  lightpink,
  lightsalmon,
  lightseagreen,
  lightskyblue,
  lightslategray,
  lightslategrey,
  lightsteelblue,
  lightyellow,
  lime,
  limegreen,
  linen,
  magenta,
  maroon,
  mediumaquamarine,
  mediumblue,
  mediumorchid,
  mediumpurple,
  mediumseagreen,
  mediumslateblue,
  mediumspringgreen,
  mediumturquoise,
  mediumvioletred,
  midnightblue,
  mintcream,
  mistyrose,
  moccasin,
  navajowhite,
  navy,
  oldlace,
  olive,
  olivedrab,
  orange,
  orangered,
  orchid,
  palegoldenrod,
  palegreen,
  paleturquoise,
  palevioletred,
  papayawhip,
  peachpuff,
  peru,
  pink,
  plum,
  powderblue,
  purple,
  rebeccapurple,
  red,
  rosybrown,
  royalblue,
  saddlebrown,
  salmon,
  sandybrown,
  seagreen,
  seashell,
  sienna,
  silver,
  skyblue,
  slateblue,
  slategray,
  slategrey,
  snow,
  springgreen,
  steelblue,
  tan,
  teal,
  thistle,
  tomato,
  turquoise,
  violet,
  wheat,
  white,
  whitesmoke,
  yellow,
  yellowgreen
};
function hex2rgb(hex, out) {
  if (out === void 0) {
    out = [];
  }
  out[0] = (hex >> 16 & 255) / 255;
  out[1] = (hex >> 8 & 255) / 255;
  out[2] = (hex & 255) / 255;
  return out;
}
function hex2string(hex) {
  var hexString = hex.toString(16);
  hexString = "000000".substring(0, 6 - hexString.length) + hexString;
  return "#" + hexString;
}
function string2hex(string) {
  if (typeof string === "string") {
    string = cssColorNames[string.toLowerCase()] || string;
    if (string[0] === "#") {
      string = string.slice(1);
    }
  }
  return parseInt(string, 16);
}
function mapPremultipliedBlendModes() {
  var pm = [];
  var npm = [];
  for (var i = 0; i < 32; i++) {
    pm[i] = i;
    npm[i] = i;
  }
  pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL;
  pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD;
  pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN;
  npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM;
  npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM;
  npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
  var array = [];
  array.push(npm);
  array.push(pm);
  return array;
}
var premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}
function premultiplyRgba(rgb, alpha, out, premultiply) {
  out = out || new Float32Array(4);
  if (premultiply || premultiply === void 0) {
    out[0] = rgb[0] * alpha;
    out[1] = rgb[1] * alpha;
    out[2] = rgb[2] * alpha;
  } else {
    out[0] = rgb[0];
    out[1] = rgb[1];
    out[2] = rgb[2];
  }
  out[3] = alpha;
  return out;
}
function premultiplyTint(tint, alpha) {
  if (alpha === 1) {
    return (alpha * 255 << 24) + tint;
  }
  if (alpha === 0) {
    return 0;
  }
  var R2 = tint >> 16 & 255;
  var G = tint >> 8 & 255;
  var B = tint & 255;
  R2 = R2 * alpha + 0.5 | 0;
  G = G * alpha + 0.5 | 0;
  B = B * alpha + 0.5 | 0;
  return (alpha * 255 << 24) + (R2 << 16) + (G << 8) + B;
}
function premultiplyTintToRgba(tint, alpha, out, premultiply) {
  out = out || new Float32Array(4);
  out[0] = (tint >> 16 & 255) / 255;
  out[1] = (tint >> 8 & 255) / 255;
  out[2] = (tint & 255) / 255;
  if (premultiply || premultiply === void 0) {
    out[0] *= alpha;
    out[1] *= alpha;
    out[2] *= alpha;
  }
  out[3] = alpha;
  return out;
}
function createIndicesForQuads(size, outBuffer) {
  if (outBuffer === void 0) {
    outBuffer = null;
  }
  var totalIndices = size * 6;
  outBuffer = outBuffer || new Uint16Array(totalIndices);
  if (outBuffer.length !== totalIndices) {
    throw new Error("Out buffer length is incorrect, got " + outBuffer.length + " and expected " + totalIndices);
  }
  for (var i = 0, j2 = 0; i < totalIndices; i += 6, j2 += 4) {
    outBuffer[i + 0] = j2 + 0;
    outBuffer[i + 1] = j2 + 1;
    outBuffer[i + 2] = j2 + 2;
    outBuffer[i + 3] = j2 + 0;
    outBuffer[i + 4] = j2 + 2;
    outBuffer[i + 5] = j2 + 3;
  }
  return outBuffer;
}
function getBufferType(array) {
  if (array.BYTES_PER_ELEMENT === 4) {
    if (array instanceof Float32Array) {
      return "Float32Array";
    } else if (array instanceof Uint32Array) {
      return "Uint32Array";
    }
    return "Int32Array";
  } else if (array.BYTES_PER_ELEMENT === 2) {
    if (array instanceof Uint16Array) {
      return "Uint16Array";
    }
  } else if (array.BYTES_PER_ELEMENT === 1) {
    if (array instanceof Uint8Array) {
      return "Uint8Array";
    }
  }
  return null;
}
function nextPow2(v2) {
  v2 += v2 === 0 ? 1 : 0;
  --v2;
  v2 |= v2 >>> 1;
  v2 |= v2 >>> 2;
  v2 |= v2 >>> 4;
  v2 |= v2 >>> 8;
  v2 |= v2 >>> 16;
  return v2 + 1;
}
function isPow2(v2) {
  return !(v2 & v2 - 1) && !!v2;
}
function log2(v2) {
  var r2 = (v2 > 65535 ? 1 : 0) << 4;
  v2 >>>= r2;
  var shift = (v2 > 255 ? 1 : 0) << 3;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 15 ? 1 : 0) << 2;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 3 ? 1 : 0) << 1;
  v2 >>>= shift;
  r2 |= shift;
  return r2 | v2 >> 1;
}
function removeItems(arr, startIdx, removeCount) {
  var length = arr.length;
  var i;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  var len = length - removeCount;
  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount];
  }
  arr.length = len;
}
function sign(n2) {
  if (n2 === 0) {
    return 0;
  }
  return n2 < 0 ? -1 : 1;
}
var nextUid = 0;
function uid() {
  return ++nextUid;
}
var warnings = {};
function deprecation(version, message, ignoreDepth) {
  if (ignoreDepth === void 0) {
    ignoreDepth = 3;
  }
  if (warnings[message]) {
    return;
  }
  var stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", message + "\nDeprecated since v" + version);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}
var ProgramCache = {};
var TextureCache = /* @__PURE__ */ Object.create(null);
var BaseTextureCache = /* @__PURE__ */ Object.create(null);
var CanvasRenderTarget = function() {
  function CanvasRenderTarget2(width, height, resolution) {
    this.canvas = settings.ADAPTER.createCanvas();
    this.context = this.canvas.getContext("2d");
    this.resolution = resolution || settings.RESOLUTION;
    this.resize(width, height);
  }
  CanvasRenderTarget2.prototype.clear = function() {
    this.context.setTransform(1, 0, 0, 1, 0, 0);
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  };
  CanvasRenderTarget2.prototype.resize = function(desiredWidth, desiredHeight) {
    this.canvas.width = Math.round(desiredWidth * this.resolution);
    this.canvas.height = Math.round(desiredHeight * this.resolution);
  };
  CanvasRenderTarget2.prototype.destroy = function() {
    this.context = null;
    this.canvas = null;
  };
  Object.defineProperty(CanvasRenderTarget2.prototype, "width", {
    get: function() {
      return this.canvas.width;
    },
    set: function(val) {
      this.canvas.width = Math.round(val);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CanvasRenderTarget2.prototype, "height", {
    get: function() {
      return this.canvas.height;
    },
    set: function(val) {
      this.canvas.height = Math.round(val);
    },
    enumerable: false,
    configurable: true
  });
  return CanvasRenderTarget2;
}();
function trimCanvas(canvas) {
  var width = canvas.width;
  var height = canvas.height;
  var context2 = canvas.getContext("2d", {
    willReadFrequently: true
  });
  var imageData = context2.getImageData(0, 0, width, height);
  var pixels = imageData.data;
  var len = pixels.length;
  var bound2 = {
    top: null,
    left: null,
    right: null,
    bottom: null
  };
  var data = null;
  var i;
  var x2;
  var y2;
  for (i = 0; i < len; i += 4) {
    if (pixels[i + 3] !== 0) {
      x2 = i / 4 % width;
      y2 = ~~(i / 4 / width);
      if (bound2.top === null) {
        bound2.top = y2;
      }
      if (bound2.left === null) {
        bound2.left = x2;
      } else if (x2 < bound2.left) {
        bound2.left = x2;
      }
      if (bound2.right === null) {
        bound2.right = x2 + 1;
      } else if (bound2.right < x2) {
        bound2.right = x2 + 1;
      }
      if (bound2.bottom === null) {
        bound2.bottom = y2;
      } else if (bound2.bottom < y2) {
        bound2.bottom = y2;
      }
    }
  }
  if (bound2.top !== null) {
    width = bound2.right - bound2.left;
    height = bound2.bottom - bound2.top + 1;
    data = context2.getImageData(bound2.left, bound2.top, width, height);
  }
  return {
    height,
    width,
    data
  };
}
var tempAnchor$1;
function determineCrossOrigin(url$1, loc) {
  if (loc === void 0) {
    loc = globalThis.location;
  }
  if (url$1.indexOf("data:") === 0) {
    return "";
  }
  loc = loc || globalThis.location;
  if (!tempAnchor$1) {
    tempAnchor$1 = document.createElement("a");
  }
  tempAnchor$1.href = url$1;
  var parsedUrl = url.parse(tempAnchor$1.href);
  var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
function getResolutionOfUrl(url2, defaultValue2) {
  var resolution = settings.RETINA_PREFIX.exec(url2);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue2 !== void 0 ? defaultValue2 : 1;
}
/*!
 * @pixi/math - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var PI_2 = Math.PI * 2;
var RAD_TO_DEG = 180 / Math.PI;
var DEG_TO_RAD = Math.PI / 180;
var SHAPES;
(function(SHAPES2) {
  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
})(SHAPES || (SHAPES = {}));
var Point = function() {
  function Point2(x2, y2) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    this.x = 0;
    this.y = 0;
    this.x = x2;
    this.y = y2;
  }
  Point2.prototype.clone = function() {
    return new Point2(this.x, this.y);
  };
  Point2.prototype.copyFrom = function(p2) {
    this.set(p2.x, p2.y);
    return this;
  };
  Point2.prototype.copyTo = function(p2) {
    p2.set(this.x, this.y);
    return p2;
  };
  Point2.prototype.equals = function(p2) {
    return p2.x === this.x && p2.y === this.y;
  };
  Point2.prototype.set = function(x2, y2) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = x2;
    }
    this.x = x2;
    this.y = y2;
    return this;
  };
  Point2.prototype.toString = function() {
    return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
  };
  return Point2;
}();
var tempPoints$1 = [new Point(), new Point(), new Point(), new Point()];
var Rectangle = function() {
  function Rectangle2(x2, y2, width, height) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    this.x = Number(x2);
    this.y = Number(y2);
    this.width = Number(width);
    this.height = Number(height);
    this.type = SHAPES.RECT;
  }
  Object.defineProperty(Rectangle2.prototype, "left", {
    get: function() {
      return this.x;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rectangle2.prototype, "right", {
    get: function() {
      return this.x + this.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rectangle2.prototype, "top", {
    get: function() {
      return this.y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rectangle2.prototype, "bottom", {
    get: function() {
      return this.y + this.height;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rectangle2, "EMPTY", {
    get: function() {
      return new Rectangle2(0, 0, 0, 0);
    },
    enumerable: false,
    configurable: true
  });
  Rectangle2.prototype.clone = function() {
    return new Rectangle2(this.x, this.y, this.width, this.height);
  };
  Rectangle2.prototype.copyFrom = function(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  };
  Rectangle2.prototype.copyTo = function(rectangle) {
    rectangle.x = this.x;
    rectangle.y = this.y;
    rectangle.width = this.width;
    rectangle.height = this.height;
    return rectangle;
  };
  Rectangle2.prototype.contains = function(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x2 >= this.x && x2 < this.x + this.width) {
      if (y2 >= this.y && y2 < this.y + this.height) {
        return true;
      }
    }
    return false;
  };
  Rectangle2.prototype.intersects = function(other, transform) {
    if (!transform) {
      var x0_1 = this.x < other.x ? other.x : this.x;
      var x1_1 = this.right > other.right ? other.right : this.right;
      if (x1_1 <= x0_1) {
        return false;
      }
      var y0_1 = this.y < other.y ? other.y : this.y;
      var y1_1 = this.bottom > other.bottom ? other.bottom : this.bottom;
      return y1_1 > y0_1;
    }
    var x0 = this.left;
    var x1 = this.right;
    var y0 = this.top;
    var y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0) {
      return false;
    }
    var lt = tempPoints$1[0].set(other.left, other.top);
    var lb = tempPoints$1[1].set(other.left, other.bottom);
    var rt = tempPoints$1[2].set(other.right, other.top);
    var rb = tempPoints$1[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb.y <= lt.y) {
      return false;
    }
    var s2 = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s2 === 0) {
      return false;
    }
    transform.apply(lt, lt);
    transform.apply(lb, lb);
    transform.apply(rt, rt);
    transform.apply(rb, rb);
    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
      return false;
    }
    var nx = s2 * (lb.y - lt.y);
    var ny = s2 * (lt.x - lb.x);
    var n00 = nx * x0 + ny * y0;
    var n10 = nx * x1 + ny * y0;
    var n01 = nx * x0 + ny * y1;
    var n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
      return false;
    }
    var mx = s2 * (lt.y - rt.y);
    var my = s2 * (rt.x - lt.x);
    var m00 = mx * x0 + my * y0;
    var m10 = mx * x1 + my * y0;
    var m01 = mx * x0 + my * y1;
    var m11 = mx * x1 + my * y1;
    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
      return false;
    }
    return true;
  };
  Rectangle2.prototype.pad = function(paddingX, paddingY) {
    if (paddingX === void 0) {
      paddingX = 0;
    }
    if (paddingY === void 0) {
      paddingY = paddingX;
    }
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  };
  Rectangle2.prototype.fit = function(rectangle) {
    var x1 = Math.max(this.x, rectangle.x);
    var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    var y1 = Math.max(this.y, rectangle.y);
    var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
    return this;
  };
  Rectangle2.prototype.ceil = function(resolution, eps) {
    if (resolution === void 0) {
      resolution = 1;
    }
    if (eps === void 0) {
      eps = 1e-3;
    }
    var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;
    this.width = x2 - this.x;
    this.height = y2 - this.y;
    return this;
  };
  Rectangle2.prototype.enlarge = function(rectangle) {
    var x1 = Math.min(this.x, rectangle.x);
    var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    var y1 = Math.min(this.y, rectangle.y);
    var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
    return this;
  };
  Rectangle2.prototype.toString = function() {
    return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
  };
  return Rectangle2;
}();
var Circle = function() {
  function Circle2(x2, y2, radius) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    if (radius === void 0) {
      radius = 0;
    }
    this.x = x2;
    this.y = y2;
    this.radius = radius;
    this.type = SHAPES.CIRC;
  }
  Circle2.prototype.clone = function() {
    return new Circle2(this.x, this.y, this.radius);
  };
  Circle2.prototype.contains = function(x2, y2) {
    if (this.radius <= 0) {
      return false;
    }
    var r2 = this.radius * this.radius;
    var dx = this.x - x2;
    var dy = this.y - y2;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r2;
  };
  Circle2.prototype.getBounds = function() {
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  };
  Circle2.prototype.toString = function() {
    return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
  };
  return Circle2;
}();
var Ellipse = function() {
  function Ellipse2(x2, y2, halfWidth, halfHeight) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    if (halfWidth === void 0) {
      halfWidth = 0;
    }
    if (halfHeight === void 0) {
      halfHeight = 0;
    }
    this.x = x2;
    this.y = y2;
    this.width = halfWidth;
    this.height = halfHeight;
    this.type = SHAPES.ELIP;
  }
  Ellipse2.prototype.clone = function() {
    return new Ellipse2(this.x, this.y, this.width, this.height);
  };
  Ellipse2.prototype.contains = function(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    var normx = (x2 - this.x) / this.width;
    var normy = (y2 - this.y) / this.height;
    normx *= normx;
    normy *= normy;
    return normx + normy <= 1;
  };
  Ellipse2.prototype.getBounds = function() {
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  };
  Ellipse2.prototype.toString = function() {
    return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
  };
  return Ellipse2;
}();
var Polygon = function() {
  function Polygon2() {
    var arguments$1 = arguments;
    var points = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      points[_i] = arguments$1[_i];
    }
    var flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] !== "number") {
      var p2 = [];
      for (var i = 0, il = flat.length; i < il; i++) {
        p2.push(flat[i].x, flat[i].y);
      }
      flat = p2;
    }
    this.points = flat;
    this.type = SHAPES.POLY;
    this.closeStroke = true;
  }
  Polygon2.prototype.clone = function() {
    var points = this.points.slice();
    var polygon = new Polygon2(points);
    polygon.closeStroke = this.closeStroke;
    return polygon;
  };
  Polygon2.prototype.contains = function(x2, y2) {
    var inside = false;
    var length = this.points.length / 2;
    for (var i = 0, j2 = length - 1; i < length; j2 = i++) {
      var xi = this.points[i * 2];
      var yi = this.points[i * 2 + 1];
      var xj = this.points[j2 * 2];
      var yj = this.points[j2 * 2 + 1];
      var intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
      if (intersect) {
        inside = !inside;
      }
    }
    return inside;
  };
  Polygon2.prototype.toString = function() {
    return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(pointsDesc, currentPoint) {
      return pointsDesc + ", " + currentPoint;
    }, "") + "]");
  };
  return Polygon2;
}();
var RoundedRectangle = function() {
  function RoundedRectangle2(x2, y2, width, height, radius) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    if (radius === void 0) {
      radius = 20;
    }
    this.x = x2;
    this.y = y2;
    this.width = width;
    this.height = height;
    this.radius = radius;
    this.type = SHAPES.RREC;
  }
  RoundedRectangle2.prototype.clone = function() {
    return new RoundedRectangle2(this.x, this.y, this.width, this.height, this.radius);
  };
  RoundedRectangle2.prototype.contains = function(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x2 >= this.x && x2 <= this.x + this.width) {
      if (y2 >= this.y && y2 <= this.y + this.height) {
        var radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
          return true;
        }
        var dx = x2 - (this.x + radius);
        var dy = y2 - (this.y + radius);
        var radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x2 - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dy = y2 - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x2 - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
      }
    }
    return false;
  };
  RoundedRectangle2.prototype.toString = function() {
    return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
  };
  return RoundedRectangle2;
}();
var ObservablePoint = function() {
  function ObservablePoint2(cb, scope, x2, y2) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    this._x = x2;
    this._y = y2;
    this.cb = cb;
    this.scope = scope;
  }
  ObservablePoint2.prototype.clone = function(cb, scope) {
    if (cb === void 0) {
      cb = this.cb;
    }
    if (scope === void 0) {
      scope = this.scope;
    }
    return new ObservablePoint2(cb, scope, this._x, this._y);
  };
  ObservablePoint2.prototype.set = function(x2, y2) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = x2;
    }
    if (this._x !== x2 || this._y !== y2) {
      this._x = x2;
      this._y = y2;
      this.cb.call(this.scope);
    }
    return this;
  };
  ObservablePoint2.prototype.copyFrom = function(p2) {
    if (this._x !== p2.x || this._y !== p2.y) {
      this._x = p2.x;
      this._y = p2.y;
      this.cb.call(this.scope);
    }
    return this;
  };
  ObservablePoint2.prototype.copyTo = function(p2) {
    p2.set(this._x, this._y);
    return p2;
  };
  ObservablePoint2.prototype.equals = function(p2) {
    return p2.x === this._x && p2.y === this._y;
  };
  ObservablePoint2.prototype.toString = function() {
    return "[@pixi/math:ObservablePoint x=" + 0 + " y=" + 0 + " scope=" + this.scope + "]";
  };
  Object.defineProperty(ObservablePoint2.prototype, "x", {
    get: function() {
      return this._x;
    },
    set: function(value) {
      if (this._x !== value) {
        this._x = value;
        this.cb.call(this.scope);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ObservablePoint2.prototype, "y", {
    get: function() {
      return this._y;
    },
    set: function(value) {
      if (this._y !== value) {
        this._y = value;
        this.cb.call(this.scope);
      }
    },
    enumerable: false,
    configurable: true
  });
  return ObservablePoint2;
}();
var Matrix = function() {
  function Matrix2(a2, b2, c, d2, tx, ty) {
    if (a2 === void 0) {
      a2 = 1;
    }
    if (b2 === void 0) {
      b2 = 0;
    }
    if (c === void 0) {
      c = 0;
    }
    if (d2 === void 0) {
      d2 = 1;
    }
    if (tx === void 0) {
      tx = 0;
    }
    if (ty === void 0) {
      ty = 0;
    }
    this.array = null;
    this.a = a2;
    this.b = b2;
    this.c = c;
    this.d = d2;
    this.tx = tx;
    this.ty = ty;
  }
  Matrix2.prototype.fromArray = function(array) {
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
  };
  Matrix2.prototype.set = function(a2, b2, c, d2, tx, ty) {
    this.a = a2;
    this.b = b2;
    this.c = c;
    this.d = d2;
    this.tx = tx;
    this.ty = ty;
    return this;
  };
  Matrix2.prototype.toArray = function(transpose, out) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    var array = out || this.array;
    if (transpose) {
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
    } else {
      array[0] = this.a;
      array[1] = this.c;
      array[2] = this.tx;
      array[3] = this.b;
      array[4] = this.d;
      array[5] = this.ty;
      array[6] = 0;
      array[7] = 0;
      array[8] = 1;
    }
    return array;
  };
  Matrix2.prototype.apply = function(pos, newPos) {
    newPos = newPos || new Point();
    var x2 = pos.x;
    var y2 = pos.y;
    newPos.x = this.a * x2 + this.c * y2 + this.tx;
    newPos.y = this.b * x2 + this.d * y2 + this.ty;
    return newPos;
  };
  Matrix2.prototype.applyInverse = function(pos, newPos) {
    newPos = newPos || new Point();
    var id = 1 / (this.a * this.d + this.c * -this.b);
    var x2 = pos.x;
    var y2 = pos.y;
    newPos.x = this.d * id * x2 + -this.c * id * y2 + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y2 + -this.b * id * x2 + (-this.ty * this.a + this.tx * this.b) * id;
    return newPos;
  };
  Matrix2.prototype.translate = function(x2, y2) {
    this.tx += x2;
    this.ty += y2;
    return this;
  };
  Matrix2.prototype.scale = function(x2, y2) {
    this.a *= x2;
    this.d *= y2;
    this.c *= x2;
    this.b *= y2;
    this.tx *= x2;
    this.ty *= y2;
    return this;
  };
  Matrix2.prototype.rotate = function(angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var a1 = this.a;
    var c1 = this.c;
    var tx1 = this.tx;
    this.a = a1 * cos - this.b * sin;
    this.b = a1 * sin + this.b * cos;
    this.c = c1 * cos - this.d * sin;
    this.d = c1 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  };
  Matrix2.prototype.append = function(matrix) {
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;
    this.a = matrix.a * a1 + matrix.b * c1;
    this.b = matrix.a * b1 + matrix.b * d1;
    this.c = matrix.c * a1 + matrix.d * c1;
    this.d = matrix.c * b1 + matrix.d * d1;
    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
    return this;
  };
  Matrix2.prototype.setTransform = function(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x2 - (pivotX * this.a + pivotY * this.c);
    this.ty = y2 - (pivotX * this.b + pivotY * this.d);
    return this;
  };
  Matrix2.prototype.prepend = function(matrix) {
    var tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      var a1 = this.a;
      var c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c;
      this.b = a1 * matrix.b + this.b * matrix.d;
      this.c = c1 * matrix.a + this.d * matrix.c;
      this.d = c1 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  };
  Matrix2.prototype.decompose = function(transform) {
    var a2 = this.a;
    var b2 = this.b;
    var c = this.c;
    var d2 = this.d;
    var pivot = transform.pivot;
    var skewX = -Math.atan2(-c, d2);
    var skewY = Math.atan2(b2, a2);
    var delta = Math.abs(skewX + skewY);
    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
      transform.rotation = skewY;
      transform.skew.x = transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
    transform.scale.y = Math.sqrt(c * c + d2 * d2);
    transform.position.x = this.tx + (pivot.x * a2 + pivot.y * c);
    transform.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);
    return transform;
  };
  Matrix2.prototype.invert = function() {
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;
    var tx1 = this.tx;
    var n2 = a1 * d1 - b1 * c1;
    this.a = d1 / n2;
    this.b = -b1 / n2;
    this.c = -c1 / n2;
    this.d = a1 / n2;
    this.tx = (c1 * this.ty - d1 * tx1) / n2;
    this.ty = -(a1 * this.ty - b1 * tx1) / n2;
    return this;
  };
  Matrix2.prototype.identity = function() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  };
  Matrix2.prototype.clone = function() {
    var matrix = new Matrix2();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  };
  Matrix2.prototype.copyTo = function(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  };
  Matrix2.prototype.copyFrom = function(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  };
  Matrix2.prototype.toString = function() {
    return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
  };
  Object.defineProperty(Matrix2, "IDENTITY", {
    get: function() {
      return new Matrix2();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Matrix2, "TEMP_MATRIX", {
    get: function() {
      return new Matrix2();
    },
    enumerable: false,
    configurable: true
  });
  return Matrix2;
}();
var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
var rotationCayley = [];
var rotationMatrices = [];
var signum = Math.sign;
function init$1() {
  for (var i = 0; i < 16; i++) {
    var row = [];
    rotationCayley.push(row);
    for (var j2 = 0; j2 < 16; j2++) {
      var _ux = signum(ux[i] * ux[j2] + vx[i] * uy[j2]);
      var _uy = signum(uy[i] * ux[j2] + vy[i] * uy[j2]);
      var _vx = signum(ux[i] * vx[j2] + vx[i] * vy[j2]);
      var _vy = signum(uy[i] * vx[j2] + vy[i] * vy[j2]);
      for (var k2 = 0; k2 < 16; k2++) {
        if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
          row.push(k2);
          break;
        }
      }
    }
  }
  for (var i = 0; i < 16; i++) {
    var mat = new Matrix();
    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
    rotationMatrices.push(mat);
  }
}
init$1();
var groupD8 = {
  E: 0,
  SE: 1,
  S: 2,
  SW: 3,
  W: 4,
  NW: 5,
  N: 6,
  NE: 7,
  MIRROR_VERTICAL: 8,
  MAIN_DIAGONAL: 10,
  MIRROR_HORIZONTAL: 12,
  REVERSE_DIAGONAL: 14,
  uX: function(ind) {
    return ux[ind];
  },
  uY: function(ind) {
    return uy[ind];
  },
  vX: function(ind) {
    return vx[ind];
  },
  vY: function(ind) {
    return vy[ind];
  },
  inv: function(rotation) {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  add: function(rotationSecond, rotationFirst) {
    return rotationCayley[rotationSecond][rotationFirst];
  },
  sub: function(rotationSecond, rotationFirst) {
    return rotationCayley[rotationSecond][groupD8.inv(rotationFirst)];
  },
  rotate180: function(rotation) {
    return rotation ^ 4;
  },
  isVertical: function(rotation) {
    return (rotation & 3) === 2;
  },
  byDirection: function(dx, dy) {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  matrixAppendRotationInv: function(matrix, rotation, tx, ty) {
    if (tx === void 0) {
      tx = 0;
    }
    if (ty === void 0) {
      ty = 0;
    }
    var mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  }
};
var Transform = function() {
  function Transform2() {
    this.worldTransform = new Matrix();
    this.localTransform = new Matrix();
    this.position = new ObservablePoint(this.onChange, this, 0, 0);
    this.scale = new ObservablePoint(this.onChange, this, 1, 1);
    this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
    this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
    this._localID = 0;
    this._currentLocalID = 0;
    this._worldID = 0;
    this._parentID = 0;
  }
  Transform2.prototype.onChange = function() {
    this._localID++;
  };
  Transform2.prototype.updateSkew = function() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this._localID++;
  };
  Transform2.prototype.toString = function() {
    return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
  };
  Transform2.prototype.updateLocalTransform = function() {
    var lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
  };
  Transform2.prototype.updateTransform = function(parentTransform) {
    var lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
    if (this._parentID !== parentTransform._worldID) {
      var pt = parentTransform.worldTransform;
      var wt = this.worldTransform;
      wt.a = lt.a * pt.a + lt.b * pt.c;
      wt.b = lt.a * pt.b + lt.b * pt.d;
      wt.c = lt.c * pt.a + lt.d * pt.c;
      wt.d = lt.c * pt.b + lt.d * pt.d;
      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
      this._parentID = parentTransform._worldID;
      this._worldID++;
    }
  };
  Transform2.prototype.setFromMatrix = function(matrix) {
    matrix.decompose(this);
    this._localID++;
  };
  Object.defineProperty(Transform2.prototype, "rotation", {
    get: function() {
      return this._rotation;
    },
    set: function(value) {
      if (this._rotation !== value) {
        this._rotation = value;
        this.updateSkew();
      }
    },
    enumerable: false,
    configurable: true
  });
  Transform2.IDENTITY = new Transform2();
  return Transform2;
}();
/*!
 * @pixi/display - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.SORTABLE_CHILDREN = false;
var Bounds = function() {
  function Bounds2() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.rect = null;
    this.updateID = -1;
  }
  Bounds2.prototype.isEmpty = function() {
    return this.minX > this.maxX || this.minY > this.maxY;
  };
  Bounds2.prototype.clear = function() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
  };
  Bounds2.prototype.getRectangle = function(rect) {
    if (this.minX > this.maxX || this.minY > this.maxY) {
      return Rectangle.EMPTY;
    }
    rect = rect || new Rectangle(0, 0, 1, 1);
    rect.x = this.minX;
    rect.y = this.minY;
    rect.width = this.maxX - this.minX;
    rect.height = this.maxY - this.minY;
    return rect;
  };
  Bounds2.prototype.addPoint = function(point) {
    this.minX = Math.min(this.minX, point.x);
    this.maxX = Math.max(this.maxX, point.x);
    this.minY = Math.min(this.minY, point.y);
    this.maxY = Math.max(this.maxY, point.y);
  };
  Bounds2.prototype.addPointMatrix = function(matrix, point) {
    var a2 = matrix.a, b2 = matrix.b, c = matrix.c, d2 = matrix.d, tx = matrix.tx, ty = matrix.ty;
    var x2 = a2 * point.x + c * point.y + tx;
    var y2 = b2 * point.x + d2 * point.y + ty;
    this.minX = Math.min(this.minX, x2);
    this.maxX = Math.max(this.maxX, x2);
    this.minY = Math.min(this.minY, y2);
    this.maxY = Math.max(this.maxY, y2);
  };
  Bounds2.prototype.addQuad = function(vertices) {
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    var x2 = vertices[0];
    var y2 = vertices[1];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = vertices[2];
    y2 = vertices[3];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = vertices[4];
    y2 = vertices[5];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = vertices[6];
    y2 = vertices[7];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  };
  Bounds2.prototype.addFrame = function(transform, x0, y0, x1, y1) {
    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
  };
  Bounds2.prototype.addFrameMatrix = function(matrix, x0, y0, x1, y1) {
    var a2 = matrix.a;
    var b2 = matrix.b;
    var c = matrix.c;
    var d2 = matrix.d;
    var tx = matrix.tx;
    var ty = matrix.ty;
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    var x2 = a2 * x0 + c * y0 + tx;
    var y2 = b2 * x0 + d2 * y0 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = a2 * x1 + c * y0 + tx;
    y2 = b2 * x1 + d2 * y0 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = a2 * x0 + c * y1 + tx;
    y2 = b2 * x0 + d2 * y1 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = a2 * x1 + c * y1 + tx;
    y2 = b2 * x1 + d2 * y1 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  };
  Bounds2.prototype.addVertexData = function(vertexData, beginOffset, endOffset) {
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    for (var i = beginOffset; i < endOffset; i += 2) {
      var x2 = vertexData[i];
      var y2 = vertexData[i + 1];
      minX = x2 < minX ? x2 : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x2 > maxX ? x2 : maxX;
      maxY = y2 > maxY ? y2 : maxY;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  };
  Bounds2.prototype.addVertices = function(transform, vertices, beginOffset, endOffset) {
    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
  };
  Bounds2.prototype.addVerticesMatrix = function(matrix, vertices, beginOffset, endOffset, padX, padY) {
    if (padX === void 0) {
      padX = 0;
    }
    if (padY === void 0) {
      padY = padX;
    }
    var a2 = matrix.a;
    var b2 = matrix.b;
    var c = matrix.c;
    var d2 = matrix.d;
    var tx = matrix.tx;
    var ty = matrix.ty;
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    for (var i = beginOffset; i < endOffset; i += 2) {
      var rawX = vertices[i];
      var rawY = vertices[i + 1];
      var x2 = a2 * rawX + c * rawY + tx;
      var y2 = d2 * rawY + b2 * rawX + ty;
      minX = Math.min(minX, x2 - padX);
      maxX = Math.max(maxX, x2 + padX);
      minY = Math.min(minY, y2 - padY);
      maxY = Math.max(maxY, y2 + padY);
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  };
  Bounds2.prototype.addBounds = function(bounds) {
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    this.minX = bounds.minX < minX ? bounds.minX : minX;
    this.minY = bounds.minY < minY ? bounds.minY : minY;
    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
  };
  Bounds2.prototype.addBoundsMask = function(bounds, mask) {
    var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
    var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
    var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
    var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
    if (_minX <= _maxX && _minY <= _maxY) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  };
  Bounds2.prototype.addBoundsMatrix = function(bounds, matrix) {
    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
  };
  Bounds2.prototype.addBoundsArea = function(bounds, area2) {
    var _minX = bounds.minX > area2.x ? bounds.minX : area2.x;
    var _minY = bounds.minY > area2.y ? bounds.minY : area2.y;
    var _maxX = bounds.maxX < area2.x + area2.width ? bounds.maxX : area2.x + area2.width;
    var _maxY = bounds.maxY < area2.y + area2.height ? bounds.maxY : area2.y + area2.height;
    if (_minX <= _maxX && _minY <= _maxY) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  };
  Bounds2.prototype.pad = function(paddingX, paddingY) {
    if (paddingX === void 0) {
      paddingX = 0;
    }
    if (paddingY === void 0) {
      paddingY = paddingX;
    }
    if (!this.isEmpty()) {
      this.minX -= paddingX;
      this.maxX += paddingX;
      this.minY -= paddingY;
      this.maxY += paddingY;
    }
  };
  Bounds2.prototype.addFramePad = function(x0, y0, x1, y1, padX, padY) {
    x0 -= padX;
    y0 -= padY;
    x1 += padX;
    y1 += padY;
    this.minX = this.minX < x0 ? this.minX : x0;
    this.maxX = this.maxX > x1 ? this.maxX : x1;
    this.minY = this.minY < y0 ? this.minY : y0;
    this.maxY = this.maxY > y1 ? this.maxY : y1;
  };
  return Bounds2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$j = function(d2, b2) {
  extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$j(d2, b2);
};
function __extends$j(d2, b2) {
  extendStatics$j(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var DisplayObject = function(_super) {
  __extends$j(DisplayObject2, _super);
  function DisplayObject2() {
    var _this = _super.call(this) || this;
    _this.tempDisplayObjectParent = null;
    _this.transform = new Transform();
    _this.alpha = 1;
    _this.visible = true;
    _this.renderable = true;
    _this.cullable = false;
    _this.cullArea = null;
    _this.parent = null;
    _this.worldAlpha = 1;
    _this._lastSortedIndex = 0;
    _this._zIndex = 0;
    _this.filterArea = null;
    _this.filters = null;
    _this._enabledFilters = null;
    _this._bounds = new Bounds();
    _this._localBounds = null;
    _this._boundsID = 0;
    _this._boundsRect = null;
    _this._localBoundsRect = null;
    _this._mask = null;
    _this._maskRefCount = 0;
    _this._destroyed = false;
    _this.isSprite = false;
    _this.isMask = false;
    return _this;
  }
  DisplayObject2.mixin = function(source) {
    var keys3 = Object.keys(source);
    for (var i = 0; i < keys3.length; ++i) {
      var propertyName = keys3[i];
      Object.defineProperty(DisplayObject2.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  };
  Object.defineProperty(DisplayObject2.prototype, "destroyed", {
    get: function() {
      return this._destroyed;
    },
    enumerable: false,
    configurable: true
  });
  DisplayObject2.prototype._recursivePostUpdateTransform = function() {
    if (this.parent) {
      this.parent._recursivePostUpdateTransform();
      this.transform.updateTransform(this.parent.transform);
    } else {
      this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }
  };
  DisplayObject2.prototype.updateTransform = function() {
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
  };
  DisplayObject2.prototype.getBounds = function(skipUpdate, rect) {
    if (!skipUpdate) {
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
      } else {
        this._recursivePostUpdateTransform();
        this.updateTransform();
      }
    }
    if (this._bounds.updateID !== this._boundsID) {
      this.calculateBounds();
      this._bounds.updateID = this._boundsID;
    }
    if (!rect) {
      if (!this._boundsRect) {
        this._boundsRect = new Rectangle();
      }
      rect = this._boundsRect;
    }
    return this._bounds.getRectangle(rect);
  };
  DisplayObject2.prototype.getLocalBounds = function(rect) {
    if (!rect) {
      if (!this._localBoundsRect) {
        this._localBoundsRect = new Rectangle();
      }
      rect = this._localBoundsRect;
    }
    if (!this._localBounds) {
      this._localBounds = new Bounds();
    }
    var transformRef = this.transform;
    var parentRef = this.parent;
    this.parent = null;
    this.transform = this._tempDisplayObjectParent.transform;
    var worldBounds = this._bounds;
    var worldBoundsID = this._boundsID;
    this._bounds = this._localBounds;
    var bounds = this.getBounds(false, rect);
    this.parent = parentRef;
    this.transform = transformRef;
    this._bounds = worldBounds;
    this._bounds.updateID += this._boundsID - worldBoundsID;
    return bounds;
  };
  DisplayObject2.prototype.toGlobal = function(position, point, skipUpdate) {
    if (skipUpdate === void 0) {
      skipUpdate = false;
    }
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.apply(position, point);
  };
  DisplayObject2.prototype.toLocal = function(position, from, point, skipUpdate) {
    if (from) {
      position = from.toGlobal(position, point, skipUpdate);
    }
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.applyInverse(position, point);
  };
  DisplayObject2.prototype.setParent = function(container) {
    if (!container || !container.addChild) {
      throw new Error("setParent: Argument must be a Container");
    }
    container.addChild(this);
    return container;
  };
  DisplayObject2.prototype.setTransform = function(x2, y2, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    if (scaleX === void 0) {
      scaleX = 1;
    }
    if (scaleY === void 0) {
      scaleY = 1;
    }
    if (rotation === void 0) {
      rotation = 0;
    }
    if (skewX === void 0) {
      skewX = 0;
    }
    if (skewY === void 0) {
      skewY = 0;
    }
    if (pivotX === void 0) {
      pivotX = 0;
    }
    if (pivotY === void 0) {
      pivotY = 0;
    }
    this.position.x = x2;
    this.position.y = y2;
    this.scale.x = !scaleX ? 1 : scaleX;
    this.scale.y = !scaleY ? 1 : scaleY;
    this.rotation = rotation;
    this.skew.x = skewX;
    this.skew.y = skewY;
    this.pivot.x = pivotX;
    this.pivot.y = pivotY;
    return this;
  };
  DisplayObject2.prototype.destroy = function(_options) {
    if (this.parent) {
      this.parent.removeChild(this);
    }
    this._destroyed = true;
    this.transform = null;
    this.parent = null;
    this._bounds = null;
    this.mask = null;
    this.cullArea = null;
    this.filters = null;
    this.filterArea = null;
    this.hitArea = null;
    this.interactive = false;
    this.interactiveChildren = false;
    this.emit("destroyed");
    this.removeAllListeners();
  };
  Object.defineProperty(DisplayObject2.prototype, "_tempDisplayObjectParent", {
    get: function() {
      if (this.tempDisplayObjectParent === null) {
        this.tempDisplayObjectParent = new TemporaryDisplayObject();
      }
      return this.tempDisplayObjectParent;
    },
    enumerable: false,
    configurable: true
  });
  DisplayObject2.prototype.enableTempParent = function() {
    var myParent = this.parent;
    this.parent = this._tempDisplayObjectParent;
    return myParent;
  };
  DisplayObject2.prototype.disableTempParent = function(cacheParent) {
    this.parent = cacheParent;
  };
  Object.defineProperty(DisplayObject2.prototype, "x", {
    get: function() {
      return this.position.x;
    },
    set: function(value) {
      this.transform.position.x = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "y", {
    get: function() {
      return this.position.y;
    },
    set: function(value) {
      this.transform.position.y = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "worldTransform", {
    get: function() {
      return this.transform.worldTransform;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "localTransform", {
    get: function() {
      return this.transform.localTransform;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "position", {
    get: function() {
      return this.transform.position;
    },
    set: function(value) {
      this.transform.position.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "scale", {
    get: function() {
      return this.transform.scale;
    },
    set: function(value) {
      this.transform.scale.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "pivot", {
    get: function() {
      return this.transform.pivot;
    },
    set: function(value) {
      this.transform.pivot.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "skew", {
    get: function() {
      return this.transform.skew;
    },
    set: function(value) {
      this.transform.skew.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "rotation", {
    get: function() {
      return this.transform.rotation;
    },
    set: function(value) {
      this.transform.rotation = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "angle", {
    get: function() {
      return this.transform.rotation * RAD_TO_DEG;
    },
    set: function(value) {
      this.transform.rotation = value * DEG_TO_RAD;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "zIndex", {
    get: function() {
      return this._zIndex;
    },
    set: function(value) {
      this._zIndex = value;
      if (this.parent) {
        this.parent.sortDirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "worldVisible", {
    get: function() {
      var item = this;
      do {
        if (!item.visible) {
          return false;
        }
        item = item.parent;
      } while (item);
      return true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "mask", {
    get: function() {
      return this._mask;
    },
    set: function(value) {
      if (this._mask === value) {
        return;
      }
      if (this._mask) {
        var maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
        if (maskObject) {
          maskObject._maskRefCount--;
          if (maskObject._maskRefCount === 0) {
            maskObject.renderable = true;
            maskObject.isMask = false;
          }
        }
      }
      this._mask = value;
      if (this._mask) {
        var maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
        if (maskObject) {
          if (maskObject._maskRefCount === 0) {
            maskObject.renderable = false;
            maskObject.isMask = true;
          }
          maskObject._maskRefCount++;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  return DisplayObject2;
}(EventEmitter$1);
var TemporaryDisplayObject = function(_super) {
  __extends$j(TemporaryDisplayObject2, _super);
  function TemporaryDisplayObject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.sortDirty = null;
    return _this;
  }
  return TemporaryDisplayObject2;
}(DisplayObject);
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
function sortChildren(a2, b2) {
  if (a2.zIndex === b2.zIndex) {
    return a2._lastSortedIndex - b2._lastSortedIndex;
  }
  return a2.zIndex - b2.zIndex;
}
var Container = function(_super) {
  __extends$j(Container2, _super);
  function Container2() {
    var _this = _super.call(this) || this;
    _this.children = [];
    _this.sortableChildren = settings.SORTABLE_CHILDREN;
    _this.sortDirty = false;
    return _this;
  }
  Container2.prototype.onChildrenChange = function(_length) {
  };
  Container2.prototype.addChild = function() {
    var arguments$1 = arguments;
    var children = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      children[_i] = arguments$1[_i];
    }
    if (children.length > 1) {
      for (var i = 0; i < children.length; i++) {
        this.addChild(children[i]);
      }
    } else {
      var child = children[0];
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.push(child);
      this._boundsID++;
      this.onChildrenChange(this.children.length - 1);
      this.emit("childAdded", child, this, this.children.length - 1);
      child.emit("added", this);
    }
    return children[0];
  };
  Container2.prototype.addChildAt = function(child, index) {
    if (index < 0 || index > this.children.length) {
      throw new Error(child + "addChildAt: The index " + index + " supplied is out of bounds " + this.children.length);
    }
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.sortDirty = true;
    child.transform._parentID = -1;
    this.children.splice(index, 0, child);
    this._boundsID++;
    this.onChildrenChange(index);
    child.emit("added", this);
    this.emit("childAdded", child, this, index);
    return child;
  };
  Container2.prototype.swapChildren = function(child, child2) {
    if (child === child2) {
      return;
    }
    var index1 = this.getChildIndex(child);
    var index2 = this.getChildIndex(child2);
    this.children[index1] = child2;
    this.children[index2] = child;
    this.onChildrenChange(index1 < index2 ? index1 : index2);
  };
  Container2.prototype.getChildIndex = function(child) {
    var index = this.children.indexOf(child);
    if (index === -1) {
      throw new Error("The supplied DisplayObject must be a child of the caller");
    }
    return index;
  };
  Container2.prototype.setChildIndex = function(child, index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error("The index " + index + " supplied is out of bounds " + this.children.length);
    }
    var currentIndex = this.getChildIndex(child);
    removeItems(this.children, currentIndex, 1);
    this.children.splice(index, 0, child);
    this.onChildrenChange(index);
  };
  Container2.prototype.getChildAt = function(index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error("getChildAt: Index (" + index + ") does not exist.");
    }
    return this.children[index];
  };
  Container2.prototype.removeChild = function() {
    var arguments$1 = arguments;
    var children = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      children[_i] = arguments$1[_i];
    }
    if (children.length > 1) {
      for (var i = 0; i < children.length; i++) {
        this.removeChild(children[i]);
      }
    } else {
      var child = children[0];
      var index = this.children.indexOf(child);
      if (index === -1) {
        return null;
      }
      child.parent = null;
      child.transform._parentID = -1;
      removeItems(this.children, index, 1);
      this._boundsID++;
      this.onChildrenChange(index);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index);
    }
    return children[0];
  };
  Container2.prototype.removeChildAt = function(index) {
    var child = this.getChildAt(index);
    child.parent = null;
    child.transform._parentID = -1;
    removeItems(this.children, index, 1);
    this._boundsID++;
    this.onChildrenChange(index);
    child.emit("removed", this);
    this.emit("childRemoved", child, this, index);
    return child;
  };
  Container2.prototype.removeChildren = function(beginIndex, endIndex) {
    if (beginIndex === void 0) {
      beginIndex = 0;
    }
    if (endIndex === void 0) {
      endIndex = this.children.length;
    }
    var begin = beginIndex;
    var end = endIndex;
    var range2 = end - begin;
    var removed;
    if (range2 > 0 && range2 <= end) {
      removed = this.children.splice(begin, range2);
      for (var i = 0; i < removed.length; ++i) {
        removed[i].parent = null;
        if (removed[i].transform) {
          removed[i].transform._parentID = -1;
        }
      }
      this._boundsID++;
      this.onChildrenChange(beginIndex);
      for (var i = 0; i < removed.length; ++i) {
        removed[i].emit("removed", this);
        this.emit("childRemoved", removed[i], this, i);
      }
      return removed;
    } else if (range2 === 0 && this.children.length === 0) {
      return [];
    }
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  };
  Container2.prototype.sortChildren = function() {
    var sortRequired = false;
    for (var i = 0, j2 = this.children.length; i < j2; ++i) {
      var child = this.children[i];
      child._lastSortedIndex = i;
      if (!sortRequired && child.zIndex !== 0) {
        sortRequired = true;
      }
    }
    if (sortRequired && this.children.length > 1) {
      this.children.sort(sortChildren);
    }
    this.sortDirty = false;
  };
  Container2.prototype.updateTransform = function() {
    if (this.sortableChildren && this.sortDirty) {
      this.sortChildren();
    }
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (var i = 0, j2 = this.children.length; i < j2; ++i) {
      var child = this.children[i];
      if (child.visible) {
        child.updateTransform();
      }
    }
  };
  Container2.prototype.calculateBounds = function() {
    this._bounds.clear();
    this._calculateBounds();
    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];
      if (!child.visible || !child.renderable) {
        continue;
      }
      child.calculateBounds();
      if (child._mask) {
        var maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
        if (maskObject) {
          maskObject.calculateBounds();
          this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
        } else {
          this._bounds.addBounds(child._bounds);
        }
      } else if (child.filterArea) {
        this._bounds.addBoundsArea(child._bounds, child.filterArea);
      } else {
        this._bounds.addBounds(child._bounds);
      }
    }
    this._bounds.updateID = this._boundsID;
  };
  Container2.prototype.getLocalBounds = function(rect, skipChildrenUpdate) {
    if (skipChildrenUpdate === void 0) {
      skipChildrenUpdate = false;
    }
    var result = _super.prototype.getLocalBounds.call(this, rect);
    if (!skipChildrenUpdate) {
      for (var i = 0, j2 = this.children.length; i < j2; ++i) {
        var child = this.children[i];
        if (child.visible) {
          child.updateTransform();
        }
      }
    }
    return result;
  };
  Container2.prototype._calculateBounds = function() {
  };
  Container2.prototype._renderWithCulling = function(renderer2) {
    var sourceFrame = renderer2.renderTexture.sourceFrame;
    if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
      return;
    }
    var bounds;
    var transform;
    if (this.cullArea) {
      bounds = this.cullArea;
      transform = this.worldTransform;
    } else if (this._render !== Container2.prototype._render) {
      bounds = this.getBounds(true);
    }
    if (bounds && sourceFrame.intersects(bounds, transform)) {
      this._render(renderer2);
    } else if (this.cullArea) {
      return;
    }
    for (var i = 0, j2 = this.children.length; i < j2; ++i) {
      var child = this.children[i];
      var childCullable = child.cullable;
      child.cullable = childCullable || !this.cullArea;
      child.render(renderer2);
      child.cullable = childCullable;
    }
  };
  Container2.prototype.render = function(renderer2) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    if (this._mask || this.filters && this.filters.length) {
      this.renderAdvanced(renderer2);
    } else if (this.cullable) {
      this._renderWithCulling(renderer2);
    } else {
      this._render(renderer2);
      for (var i = 0, j2 = this.children.length; i < j2; ++i) {
        this.children[i].render(renderer2);
      }
    }
  };
  Container2.prototype.renderAdvanced = function(renderer2) {
    var filters = this.filters;
    var mask = this._mask;
    if (filters) {
      if (!this._enabledFilters) {
        this._enabledFilters = [];
      }
      this._enabledFilters.length = 0;
      for (var i = 0; i < filters.length; i++) {
        if (filters[i].enabled) {
          this._enabledFilters.push(filters[i]);
        }
      }
    }
    var flush = filters && this._enabledFilters && this._enabledFilters.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE));
    if (flush) {
      renderer2.batch.flush();
    }
    if (filters && this._enabledFilters && this._enabledFilters.length) {
      renderer2.filter.push(this, this._enabledFilters);
    }
    if (mask) {
      renderer2.mask.push(this, this._mask);
    }
    if (this.cullable) {
      this._renderWithCulling(renderer2);
    } else {
      this._render(renderer2);
      for (var i = 0, j2 = this.children.length; i < j2; ++i) {
        this.children[i].render(renderer2);
      }
    }
    if (flush) {
      renderer2.batch.flush();
    }
    if (mask) {
      renderer2.mask.pop(this);
    }
    if (filters && this._enabledFilters && this._enabledFilters.length) {
      renderer2.filter.pop();
    }
  };
  Container2.prototype._render = function(_renderer) {
  };
  Container2.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this);
    this.sortDirty = false;
    var destroyChildren = typeof options === "boolean" ? options : options && options.children;
    var oldChildren = this.removeChildren(0, this.children.length);
    if (destroyChildren) {
      for (var i = 0; i < oldChildren.length; ++i) {
        oldChildren[i].destroy(options);
      }
    }
  };
  Object.defineProperty(Container2.prototype, "width", {
    get: function() {
      return this.scale.x * this.getLocalBounds().width;
    },
    set: function(value) {
      var width = this.getLocalBounds().width;
      if (width !== 0) {
        this.scale.x = value / width;
      } else {
        this.scale.x = 1;
      }
      this._width = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Container2.prototype, "height", {
    get: function() {
      return this.scale.y * this.getLocalBounds().height;
    },
    set: function(value) {
      var height = this.getLocalBounds().height;
      if (height !== 0) {
        this.scale.y = value / height;
      } else {
        this.scale.y = 1;
      }
      this._height = value;
    },
    enumerable: false,
    configurable: true
  });
  return Container2;
}(DisplayObject);
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
/*!
 * @pixi/extensions - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/extensions is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t2) {
    var arguments$1 = arguments;
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments$1[i];
      for (var p2 in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p2)) {
          t2[p2] = s2[p2];
        }
      }
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
var ExtensionType;
(function(ExtensionType2) {
  ExtensionType2["Application"] = "application";
  ExtensionType2["RendererPlugin"] = "renderer-webgl-plugin";
  ExtensionType2["CanvasRendererPlugin"] = "renderer-canvas-plugin";
  ExtensionType2["Loader"] = "loader";
  ExtensionType2["LoadParser"] = "load-parser";
  ExtensionType2["ResolveParser"] = "resolve-parser";
  ExtensionType2["CacheParser"] = "cache-parser";
  ExtensionType2["DetectionParser"] = "detection-parser";
})(ExtensionType || (ExtensionType = {}));
var normalizeExtension = function(ext) {
  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
    if (!ext.extension) {
      throw new Error("Extension class must have an extension object");
    }
    var metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
    ext = __assign$1(__assign$1({}, metadata), { ref: ext });
  }
  if (typeof ext === "object") {
    ext = __assign$1({}, ext);
  } else {
    throw new Error("Invalid extension type");
  }
  if (typeof ext.type === "string") {
    ext.type = [ext.type];
  }
  return ext;
};
var extensions = {
  _addHandlers: null,
  _removeHandlers: null,
  _queue: {},
  remove: function() {
    var arguments$1 = arguments;
    var _this = this;
    var extensions2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      extensions2[_i] = arguments$1[_i];
    }
    extensions2.map(normalizeExtension).forEach(function(ext) {
      ext.type.forEach(function(type2) {
        var _a2, _b2;
        return (_b2 = (_a2 = _this._removeHandlers)[type2]) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, ext);
      });
    });
    return this;
  },
  add: function() {
    var arguments$1 = arguments;
    var _this = this;
    var extensions2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      extensions2[_i] = arguments$1[_i];
    }
    extensions2.map(normalizeExtension).forEach(function(ext) {
      ext.type.forEach(function(type2) {
        var handlers = _this._addHandlers;
        var queue = _this._queue;
        if (!handlers[type2]) {
          queue[type2] = queue[type2] || [];
          queue[type2].push(ext);
        } else {
          handlers[type2](ext);
        }
      });
    });
    return this;
  },
  handle: function(type2, onAdd, onRemove) {
    var addHandlers = this._addHandlers = this._addHandlers || {};
    var removeHandlers = this._removeHandlers = this._removeHandlers || {};
    if (addHandlers[type2] || removeHandlers[type2]) {
      throw new Error("Extension type " + type2 + " already has a handler");
    }
    addHandlers[type2] = onAdd;
    removeHandlers[type2] = onRemove;
    var queue = this._queue;
    if (queue[type2]) {
      queue[type2].forEach(function(ext) {
        return onAdd(ext);
      });
      delete queue[type2];
    }
    return this;
  },
  handleByMap: function(type2, map4) {
    return this.handle(type2, function(extension) {
      map4[extension.name] = extension.ref;
    }, function(extension) {
      delete map4[extension.name];
    });
  },
  handleByList: function(type2, list) {
    return this.handle(type2, function(extension) {
      var _a2, _b2;
      if (list.includes(extension.ref)) {
        return;
      }
      list.push(extension.ref);
      if (type2 === ExtensionType.Loader) {
        (_b2 = (_a2 = extension.ref).add) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      }
    }, function(extension) {
      var index = list.indexOf(extension.ref);
      if (index !== -1) {
        list.splice(index, 1);
      }
    });
  }
};
/*!
 * @pixi/runner - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Runner = function() {
  function Runner2(name) {
    this.items = [];
    this._name = name;
    this._aliasCount = 0;
  }
  Runner2.prototype.emit = function(a0, a1, a2, a3, a4, a5, a6, a7) {
    if (arguments.length > 8) {
      throw new Error("max arguments reached");
    }
    var _a2 = this, name = _a2.name, items = _a2.items;
    this._aliasCount++;
    for (var i = 0, len = items.length; i < len; i++) {
      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
    }
    if (items === this.items) {
      this._aliasCount--;
    }
    return this;
  };
  Runner2.prototype.ensureNonAliasedItems = function() {
    if (this._aliasCount > 0 && this.items.length > 1) {
      this._aliasCount = 0;
      this.items = this.items.slice(0);
    }
  };
  Runner2.prototype.add = function(item) {
    if (item[this._name]) {
      this.ensureNonAliasedItems();
      this.remove(item);
      this.items.push(item);
    }
    return this;
  };
  Runner2.prototype.remove = function(item) {
    var index = this.items.indexOf(item);
    if (index !== -1) {
      this.ensureNonAliasedItems();
      this.items.splice(index, 1);
    }
    return this;
  };
  Runner2.prototype.contains = function(item) {
    return this.items.indexOf(item) !== -1;
  };
  Runner2.prototype.removeAll = function() {
    this.ensureNonAliasedItems();
    this.items.length = 0;
    return this;
  };
  Runner2.prototype.destroy = function() {
    this.removeAll();
    this.items = null;
    this._name = null;
  };
  Object.defineProperty(Runner2.prototype, "empty", {
    get: function() {
      return this.items.length === 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Runner2.prototype, "name", {
    get: function() {
      return this._name;
    },
    enumerable: false,
    configurable: true
  });
  return Runner2;
}();
Object.defineProperties(Runner.prototype, {
  dispatch: { value: Runner.prototype.emit },
  run: { value: Runner.prototype.emit }
});
/*!
 * @pixi/ticker - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.TARGET_FPMS = 0.06;
var UPDATE_PRIORITY;
(function(UPDATE_PRIORITY2) {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
var TickerListener = function() {
  function TickerListener2(fn, context2, priority, once3) {
    if (context2 === void 0) {
      context2 = null;
    }
    if (priority === void 0) {
      priority = 0;
    }
    if (once3 === void 0) {
      once3 = false;
    }
    this.next = null;
    this.previous = null;
    this._destroyed = false;
    this.fn = fn;
    this.context = context2;
    this.priority = priority;
    this.once = once3;
  }
  TickerListener2.prototype.match = function(fn, context2) {
    if (context2 === void 0) {
      context2 = null;
    }
    return this.fn === fn && this.context === context2;
  };
  TickerListener2.prototype.emit = function(deltaTime) {
    if (this.fn) {
      if (this.context) {
        this.fn.call(this.context, deltaTime);
      } else {
        this.fn(deltaTime);
      }
    }
    var redirect = this.next;
    if (this.once) {
      this.destroy(true);
    }
    if (this._destroyed) {
      this.next = null;
    }
    return redirect;
  };
  TickerListener2.prototype.connect = function(previous) {
    this.previous = previous;
    if (previous.next) {
      previous.next.previous = this;
    }
    this.next = previous.next;
    previous.next = this;
  };
  TickerListener2.prototype.destroy = function(hard) {
    if (hard === void 0) {
      hard = false;
    }
    this._destroyed = true;
    this.fn = null;
    this.context = null;
    if (this.previous) {
      this.previous.next = this.next;
    }
    if (this.next) {
      this.next.previous = this.previous;
    }
    var redirect = this.next;
    this.next = hard ? null : redirect;
    this.previous = null;
    return redirect;
  };
  return TickerListener2;
}();
var Ticker = function() {
  function Ticker2() {
    var _this = this;
    this.autoStart = false;
    this.deltaTime = 1;
    this.lastTime = -1;
    this.speed = 1;
    this.started = false;
    this._requestId = null;
    this._maxElapsedMS = 100;
    this._minElapsedMS = 0;
    this._protected = false;
    this._lastFrame = -1;
    this._head = new TickerListener(null, null, Infinity);
    this.deltaMS = 1 / settings.TARGET_FPMS;
    this.elapsedMS = 1 / settings.TARGET_FPMS;
    this._tick = function(time) {
      _this._requestId = null;
      if (_this.started) {
        _this.update(time);
        if (_this.started && _this._requestId === null && _this._head.next) {
          _this._requestId = requestAnimationFrame(_this._tick);
        }
      }
    };
  }
  Ticker2.prototype._requestIfNeeded = function() {
    if (this._requestId === null && this._head.next) {
      this.lastTime = performance.now();
      this._lastFrame = this.lastTime;
      this._requestId = requestAnimationFrame(this._tick);
    }
  };
  Ticker2.prototype._cancelIfNeeded = function() {
    if (this._requestId !== null) {
      cancelAnimationFrame(this._requestId);
      this._requestId = null;
    }
  };
  Ticker2.prototype._startIfPossible = function() {
    if (this.started) {
      this._requestIfNeeded();
    } else if (this.autoStart) {
      this.start();
    }
  };
  Ticker2.prototype.add = function(fn, context2, priority) {
    if (priority === void 0) {
      priority = UPDATE_PRIORITY.NORMAL;
    }
    return this._addListener(new TickerListener(fn, context2, priority));
  };
  Ticker2.prototype.addOnce = function(fn, context2, priority) {
    if (priority === void 0) {
      priority = UPDATE_PRIORITY.NORMAL;
    }
    return this._addListener(new TickerListener(fn, context2, priority, true));
  };
  Ticker2.prototype._addListener = function(listener) {
    var current2 = this._head.next;
    var previous = this._head;
    if (!current2) {
      listener.connect(previous);
    } else {
      while (current2) {
        if (listener.priority > current2.priority) {
          listener.connect(previous);
          break;
        }
        previous = current2;
        current2 = current2.next;
      }
      if (!listener.previous) {
        listener.connect(previous);
      }
    }
    this._startIfPossible();
    return this;
  };
  Ticker2.prototype.remove = function(fn, context2) {
    var listener = this._head.next;
    while (listener) {
      if (listener.match(fn, context2)) {
        listener = listener.destroy();
      } else {
        listener = listener.next;
      }
    }
    if (!this._head.next) {
      this._cancelIfNeeded();
    }
    return this;
  };
  Object.defineProperty(Ticker2.prototype, "count", {
    get: function() {
      if (!this._head) {
        return 0;
      }
      var count = 0;
      var current2 = this._head;
      while (current2 = current2.next) {
        count++;
      }
      return count;
    },
    enumerable: false,
    configurable: true
  });
  Ticker2.prototype.start = function() {
    if (!this.started) {
      this.started = true;
      this._requestIfNeeded();
    }
  };
  Ticker2.prototype.stop = function() {
    if (this.started) {
      this.started = false;
      this._cancelIfNeeded();
    }
  };
  Ticker2.prototype.destroy = function() {
    if (!this._protected) {
      this.stop();
      var listener = this._head.next;
      while (listener) {
        listener = listener.destroy(true);
      }
      this._head.destroy();
      this._head = null;
    }
  };
  Ticker2.prototype.update = function(currentTime) {
    if (currentTime === void 0) {
      currentTime = performance.now();
    }
    var elapsedMS;
    if (currentTime > this.lastTime) {
      elapsedMS = this.elapsedMS = currentTime - this.lastTime;
      if (elapsedMS > this._maxElapsedMS) {
        elapsedMS = this._maxElapsedMS;
      }
      elapsedMS *= this.speed;
      if (this._minElapsedMS) {
        var delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS) {
          return;
        }
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS;
      this.deltaTime = this.deltaMS * settings.TARGET_FPMS;
      var head = this._head;
      var listener = head.next;
      while (listener) {
        listener = listener.emit(this.deltaTime);
      }
      if (!head.next) {
        this._cancelIfNeeded();
      }
    } else {
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    }
    this.lastTime = currentTime;
  };
  Object.defineProperty(Ticker2.prototype, "FPS", {
    get: function() {
      return 1e3 / this.elapsedMS;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Ticker2.prototype, "minFPS", {
    get: function() {
      return 1e3 / this._maxElapsedMS;
    },
    set: function(fps) {
      var minFPS = Math.min(this.maxFPS, fps);
      var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings.TARGET_FPMS);
      this._maxElapsedMS = 1 / minFPMS;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Ticker2.prototype, "maxFPS", {
    get: function() {
      if (this._minElapsedMS) {
        return Math.round(1e3 / this._minElapsedMS);
      }
      return 0;
    },
    set: function(fps) {
      if (fps === 0) {
        this._minElapsedMS = 0;
      } else {
        var maxFPS = Math.max(this.minFPS, fps);
        this._minElapsedMS = 1 / (maxFPS / 1e3);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Ticker2, "shared", {
    get: function() {
      if (!Ticker2._shared) {
        var shared = Ticker2._shared = new Ticker2();
        shared.autoStart = true;
        shared._protected = true;
      }
      return Ticker2._shared;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Ticker2, "system", {
    get: function() {
      if (!Ticker2._system) {
        var system = Ticker2._system = new Ticker2();
        system.autoStart = true;
        system._protected = true;
      }
      return Ticker2._system;
    },
    enumerable: false,
    configurable: true
  });
  return Ticker2;
}();
var TickerPlugin = function() {
  function TickerPlugin2() {
  }
  TickerPlugin2.init = function(options) {
    var _this = this;
    options = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options);
    Object.defineProperty(this, "ticker", {
      set: function(ticker) {
        if (this._ticker) {
          this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
          ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
        }
      },
      get: function() {
        return this._ticker;
      }
    });
    this.stop = function() {
      _this._ticker.stop();
    };
    this.start = function() {
      _this._ticker.start();
    };
    this._ticker = null;
    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
    if (options.autoStart) {
      this.start();
    }
  };
  TickerPlugin2.destroy = function() {
    if (this._ticker) {
      var oldTicker = this._ticker;
      this.ticker = null;
      oldTicker.destroy();
    }
  };
  TickerPlugin2.extension = ExtensionType.Application;
  return TickerPlugin2;
}();
/*!
 * @pixi/core - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.PREFER_ENV = isMobile.any ? ENV.WEBGL : ENV.WEBGL2;
settings.STRICT_TEXTURE_CACHE = false;
var INSTALLED = [];
function autoDetectResource(source, options) {
  if (!source) {
    return null;
  }
  var extension = "";
  if (typeof source === "string") {
    var result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (var i = INSTALLED.length - 1; i >= 0; --i) {
    var ResourcePlugin = INSTALLED[i];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$i = function(d2, b2) {
  extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$i(d2, b2);
};
function __extends$i(d2, b2) {
  extendStatics$i(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    var arguments$1 = arguments;
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments$1[i];
      for (var p2 in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p2)) {
          t2[p2] = s2[p2];
        }
      }
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) {
      t2[p2] = s2[p2];
    }
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") {
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i])) {
        t2[p2[i]] = s2[p2[i]];
      }
    }
  }
  return t2;
}
var Resource = function() {
  function Resource2(width, height) {
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    this._width = width;
    this._height = height;
    this.destroyed = false;
    this.internal = false;
    this.onResize = new Runner("setRealSize");
    this.onUpdate = new Runner("update");
    this.onError = new Runner("onError");
  }
  Resource2.prototype.bind = function(baseTexture) {
    this.onResize.add(baseTexture);
    this.onUpdate.add(baseTexture);
    this.onError.add(baseTexture);
    if (this._width || this._height) {
      this.onResize.emit(this._width, this._height);
    }
  };
  Resource2.prototype.unbind = function(baseTexture) {
    this.onResize.remove(baseTexture);
    this.onUpdate.remove(baseTexture);
    this.onError.remove(baseTexture);
  };
  Resource2.prototype.resize = function(width, height) {
    if (width !== this._width || height !== this._height) {
      this._width = width;
      this._height = height;
      this.onResize.emit(width, height);
    }
  };
  Object.defineProperty(Resource2.prototype, "valid", {
    get: function() {
      return !!this._width && !!this._height;
    },
    enumerable: false,
    configurable: true
  });
  Resource2.prototype.update = function() {
    if (!this.destroyed) {
      this.onUpdate.emit();
    }
  };
  Resource2.prototype.load = function() {
    return Promise.resolve(this);
  };
  Object.defineProperty(Resource2.prototype, "width", {
    get: function() {
      return this._width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Resource2.prototype, "height", {
    get: function() {
      return this._height;
    },
    enumerable: false,
    configurable: true
  });
  Resource2.prototype.style = function(_renderer, _baseTexture, _glTexture) {
    return false;
  };
  Resource2.prototype.dispose = function() {
  };
  Resource2.prototype.destroy = function() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.dispose();
      this.onError.removeAll();
      this.onError = null;
      this.onResize.removeAll();
      this.onResize = null;
      this.onUpdate.removeAll();
      this.onUpdate = null;
    }
  };
  Resource2.test = function(_source, _extension) {
    return false;
  };
  return Resource2;
}();
var BufferResource = function(_super) {
  __extends$i(BufferResource2, _super);
  function BufferResource2(source, options) {
    var _this = this;
    var _a2 = options || {}, width = _a2.width, height = _a2.height;
    if (!width || !height) {
      throw new Error("BufferResource width or height invalid");
    }
    _this = _super.call(this, width, height) || this;
    _this.data = source;
    return _this;
  }
  BufferResource2.prototype.upload = function(renderer2, baseTexture, glTexture) {
    var gl = renderer2.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    var width = baseTexture.realWidth;
    var height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  };
  BufferResource2.prototype.dispose = function() {
    this.data = null;
  };
  BufferResource2.test = function(source) {
    return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
  };
  return BufferResource2;
}(Resource);
var defaultBufferOptions = {
  scaleMode: SCALE_MODES.NEAREST,
  format: FORMATS.RGBA,
  alphaMode: ALPHA_MODES.NPM
};
var BaseTexture = function(_super) {
  __extends$i(BaseTexture2, _super);
  function BaseTexture2(resource, options) {
    if (resource === void 0) {
      resource = null;
    }
    if (options === void 0) {
      options = null;
    }
    var _this = _super.call(this) || this;
    options = options || {};
    var alphaMode = options.alphaMode, mipmap = options.mipmap, anisotropicLevel = options.anisotropicLevel, scaleMode = options.scaleMode, width = options.width, height = options.height, wrapMode = options.wrapMode, format2 = options.format, type2 = options.type, target = options.target, resolution = options.resolution, resourceOptions = options.resourceOptions;
    if (resource && !(resource instanceof Resource)) {
      resource = autoDetectResource(resource, resourceOptions);
      resource.internal = true;
    }
    _this.resolution = resolution || settings.RESOLUTION;
    _this.width = Math.round((width || 0) * _this.resolution) / _this.resolution;
    _this.height = Math.round((height || 0) * _this.resolution) / _this.resolution;
    _this._mipmap = mipmap !== void 0 ? mipmap : settings.MIPMAP_TEXTURES;
    _this.anisotropicLevel = anisotropicLevel !== void 0 ? anisotropicLevel : settings.ANISOTROPIC_LEVEL;
    _this._wrapMode = wrapMode || settings.WRAP_MODE;
    _this._scaleMode = scaleMode !== void 0 ? scaleMode : settings.SCALE_MODE;
    _this.format = format2 || FORMATS.RGBA;
    _this.type = type2 || TYPES.UNSIGNED_BYTE;
    _this.target = target || TARGETS.TEXTURE_2D;
    _this.alphaMode = alphaMode !== void 0 ? alphaMode : ALPHA_MODES.UNPACK;
    _this.uid = uid();
    _this.touched = 0;
    _this.isPowerOfTwo = false;
    _this._refreshPOT();
    _this._glTextures = {};
    _this.dirtyId = 0;
    _this.dirtyStyleId = 0;
    _this.cacheId = null;
    _this.valid = width > 0 && height > 0;
    _this.textureCacheIds = [];
    _this.destroyed = false;
    _this.resource = null;
    _this._batchEnabled = 0;
    _this._batchLocation = 0;
    _this.parentTextureArray = null;
    _this.setResource(resource);
    return _this;
  }
  Object.defineProperty(BaseTexture2.prototype, "realWidth", {
    get: function() {
      return Math.round(this.width * this.resolution);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "realHeight", {
    get: function() {
      return Math.round(this.height * this.resolution);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "mipmap", {
    get: function() {
      return this._mipmap;
    },
    set: function(value) {
      if (this._mipmap !== value) {
        this._mipmap = value;
        this.dirtyStyleId++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "scaleMode", {
    get: function() {
      return this._scaleMode;
    },
    set: function(value) {
      if (this._scaleMode !== value) {
        this._scaleMode = value;
        this.dirtyStyleId++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "wrapMode", {
    get: function() {
      return this._wrapMode;
    },
    set: function(value) {
      if (this._wrapMode !== value) {
        this._wrapMode = value;
        this.dirtyStyleId++;
      }
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype.setStyle = function(scaleMode, mipmap) {
    var dirty;
    if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
      this.scaleMode = scaleMode;
      dirty = true;
    }
    if (mipmap !== void 0 && mipmap !== this.mipmap) {
      this.mipmap = mipmap;
      dirty = true;
    }
    if (dirty) {
      this.dirtyStyleId++;
    }
    return this;
  };
  BaseTexture2.prototype.setSize = function(desiredWidth, desiredHeight, resolution) {
    resolution = resolution || this.resolution;
    return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
  };
  BaseTexture2.prototype.setRealSize = function(realWidth, realHeight, resolution) {
    this.resolution = resolution || this.resolution;
    this.width = Math.round(realWidth) / this.resolution;
    this.height = Math.round(realHeight) / this.resolution;
    this._refreshPOT();
    this.update();
    return this;
  };
  BaseTexture2.prototype._refreshPOT = function() {
    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
  };
  BaseTexture2.prototype.setResolution = function(resolution) {
    var oldResolution = this.resolution;
    if (oldResolution === resolution) {
      return this;
    }
    this.resolution = resolution;
    if (this.valid) {
      this.width = Math.round(this.width * oldResolution) / resolution;
      this.height = Math.round(this.height * oldResolution) / resolution;
      this.emit("update", this);
    }
    this._refreshPOT();
    return this;
  };
  BaseTexture2.prototype.setResource = function(resource) {
    if (this.resource === resource) {
      return this;
    }
    if (this.resource) {
      throw new Error("Resource can be set only once");
    }
    resource.bind(this);
    this.resource = resource;
    return this;
  };
  BaseTexture2.prototype.update = function() {
    if (!this.valid) {
      if (this.width > 0 && this.height > 0) {
        this.valid = true;
        this.emit("loaded", this);
        this.emit("update", this);
      }
    } else {
      this.dirtyId++;
      this.dirtyStyleId++;
      this.emit("update", this);
    }
  };
  BaseTexture2.prototype.onError = function(event) {
    this.emit("error", this, event);
  };
  BaseTexture2.prototype.destroy = function() {
    if (this.resource) {
      this.resource.unbind(this);
      if (this.resource.internal) {
        this.resource.destroy();
      }
      this.resource = null;
    }
    if (this.cacheId) {
      delete BaseTextureCache[this.cacheId];
      delete TextureCache[this.cacheId];
      this.cacheId = null;
    }
    this.dispose();
    BaseTexture2.removeFromCache(this);
    this.textureCacheIds = null;
    this.destroyed = true;
  };
  BaseTexture2.prototype.dispose = function() {
    this.emit("dispose", this);
  };
  BaseTexture2.prototype.castToBaseTexture = function() {
    return this;
  };
  BaseTexture2.from = function(source, options, strict) {
    if (strict === void 0) {
      strict = settings.STRICT_TEXTURE_CACHE;
    }
    var isFrame = typeof source === "string";
    var cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else {
      if (!source._pixiId) {
        var prefix = options && options.pixiIdPrefix || "pixiid";
        source._pixiId = prefix + "_" + uid();
      }
      cacheId = source._pixiId;
    }
    var baseTexture = BaseTextureCache[cacheId];
    if (isFrame && strict && !baseTexture) {
      throw new Error('The cacheId "' + cacheId + '" does not exist in BaseTextureCache.');
    }
    if (!baseTexture) {
      baseTexture = new BaseTexture2(source, options);
      baseTexture.cacheId = cacheId;
      BaseTexture2.addToCache(baseTexture, cacheId);
    }
    return baseTexture;
  };
  BaseTexture2.fromBuffer = function(buffer, width, height, options) {
    buffer = buffer || new Float32Array(width * height * 4);
    var resource = new BufferResource(buffer, { width, height });
    var type2 = buffer instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
    return new BaseTexture2(resource, Object.assign({}, defaultBufferOptions, options || { width, height, type: type2 }));
  };
  BaseTexture2.addToCache = function(baseTexture, id) {
    if (id) {
      if (baseTexture.textureCacheIds.indexOf(id) === -1) {
        baseTexture.textureCacheIds.push(id);
      }
      if (BaseTextureCache[id]) {
        console.warn("BaseTexture added to the cache with an id [" + id + "] that already had an entry");
      }
      BaseTextureCache[id] = baseTexture;
    }
  };
  BaseTexture2.removeFromCache = function(baseTexture) {
    if (typeof baseTexture === "string") {
      var baseTextureFromCache = BaseTextureCache[baseTexture];
      if (baseTextureFromCache) {
        var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
        if (index > -1) {
          baseTextureFromCache.textureCacheIds.splice(index, 1);
        }
        delete BaseTextureCache[baseTexture];
        return baseTextureFromCache;
      }
    } else if (baseTexture && baseTexture.textureCacheIds) {
      for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
        delete BaseTextureCache[baseTexture.textureCacheIds[i]];
      }
      baseTexture.textureCacheIds.length = 0;
      return baseTexture;
    }
    return null;
  };
  BaseTexture2._globalBatch = 0;
  return BaseTexture2;
}(EventEmitter$1);
var AbstractMultiResource = function(_super) {
  __extends$i(AbstractMultiResource2, _super);
  function AbstractMultiResource2(length, options) {
    var _this = this;
    var _a2 = options || {}, width = _a2.width, height = _a2.height;
    _this = _super.call(this, width, height) || this;
    _this.items = [];
    _this.itemDirtyIds = [];
    for (var i = 0; i < length; i++) {
      var partTexture = new BaseTexture();
      _this.items.push(partTexture);
      _this.itemDirtyIds.push(-2);
    }
    _this.length = length;
    _this._load = null;
    _this.baseTexture = null;
    return _this;
  }
  AbstractMultiResource2.prototype.initFromArray = function(resources, options) {
    for (var i = 0; i < this.length; i++) {
      if (!resources[i]) {
        continue;
      }
      if (resources[i].castToBaseTexture) {
        this.addBaseTextureAt(resources[i].castToBaseTexture(), i);
      } else if (resources[i] instanceof Resource) {
        this.addResourceAt(resources[i], i);
      } else {
        this.addResourceAt(autoDetectResource(resources[i], options), i);
      }
    }
  };
  AbstractMultiResource2.prototype.dispose = function() {
    for (var i = 0, len = this.length; i < len; i++) {
      this.items[i].destroy();
    }
    this.items = null;
    this.itemDirtyIds = null;
    this._load = null;
  };
  AbstractMultiResource2.prototype.addResourceAt = function(resource, index) {
    if (!this.items[index]) {
      throw new Error("Index " + index + " is out of bounds");
    }
    if (resource.valid && !this.valid) {
      this.resize(resource.width, resource.height);
    }
    this.items[index].setResource(resource);
    return this;
  };
  AbstractMultiResource2.prototype.bind = function(baseTexture) {
    if (this.baseTexture !== null) {
      throw new Error("Only one base texture per TextureArray is allowed");
    }
    _super.prototype.bind.call(this, baseTexture);
    for (var i = 0; i < this.length; i++) {
      this.items[i].parentTextureArray = baseTexture;
      this.items[i].on("update", baseTexture.update, baseTexture);
    }
  };
  AbstractMultiResource2.prototype.unbind = function(baseTexture) {
    _super.prototype.unbind.call(this, baseTexture);
    for (var i = 0; i < this.length; i++) {
      this.items[i].parentTextureArray = null;
      this.items[i].off("update", baseTexture.update, baseTexture);
    }
  };
  AbstractMultiResource2.prototype.load = function() {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    var resources = this.items.map(function(item) {
      return item.resource;
    }).filter(function(item) {
      return item;
    });
    var promises = resources.map(function(item) {
      return item.load();
    });
    this._load = Promise.all(promises).then(function() {
      var _a2 = _this.items[0], realWidth = _a2.realWidth, realHeight = _a2.realHeight;
      _this.resize(realWidth, realHeight);
      return Promise.resolve(_this);
    });
    return this._load;
  };
  return AbstractMultiResource2;
}(Resource);
var ArrayResource = function(_super) {
  __extends$i(ArrayResource2, _super);
  function ArrayResource2(source, options) {
    var _this = this;
    var _a2 = options || {}, width = _a2.width, height = _a2.height;
    var urls;
    var length;
    if (Array.isArray(source)) {
      urls = source;
      length = source.length;
    } else {
      length = source;
    }
    _this = _super.call(this, length, { width, height }) || this;
    if (urls) {
      _this.initFromArray(urls, options);
    }
    return _this;
  }
  ArrayResource2.prototype.addBaseTextureAt = function(baseTexture, index) {
    if (baseTexture.resource) {
      this.addResourceAt(baseTexture.resource, index);
    } else {
      throw new Error("ArrayResource does not support RenderTexture");
    }
    return this;
  };
  ArrayResource2.prototype.bind = function(baseTexture) {
    _super.prototype.bind.call(this, baseTexture);
    baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
  };
  ArrayResource2.prototype.upload = function(renderer2, texture, glTexture) {
    var _a2 = this, length = _a2.length, itemDirtyIds = _a2.itemDirtyIds, items = _a2.items;
    var gl = renderer2.gl;
    if (glTexture.dirtyId < 0) {
      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);
    }
    for (var i = 0; i < length; i++) {
      var item = items[i];
      if (itemDirtyIds[i] < item.dirtyId) {
        itemDirtyIds[i] = item.dirtyId;
        if (item.valid) {
          gl.texSubImage3D(
            gl.TEXTURE_2D_ARRAY,
            0,
            0,
            0,
            i,
            item.resource.width,
            item.resource.height,
            1,
            texture.format,
            glTexture.type,
            item.resource.source
          );
        }
      }
    }
    return true;
  };
  return ArrayResource2;
}(AbstractMultiResource);
var BaseImageResource = function(_super) {
  __extends$i(BaseImageResource2, _super);
  function BaseImageResource2(source) {
    var _this = this;
    var sourceAny = source;
    var width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
    var height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
    _this = _super.call(this, width, height) || this;
    _this.source = source;
    _this.noSubImage = false;
    return _this;
  }
  BaseImageResource2.crossOrigin = function(element, url2, crossorigin) {
    if (crossorigin === void 0 && url2.indexOf("data:") !== 0) {
      element.crossOrigin = determineCrossOrigin(url2);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  };
  BaseImageResource2.prototype.upload = function(renderer2, baseTexture, glTexture, source) {
    var gl = renderer2.gl;
    var width = baseTexture.realWidth;
    var height = baseTexture.realHeight;
    source = source || this.source;
    if (source instanceof HTMLImageElement) {
      if (!source.complete || source.naturalWidth === 0) {
        return false;
      }
    } else if (source instanceof HTMLVideoElement) {
      if (source.readyState <= 1) {
        return false;
      }
    }
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
    }
    return true;
  };
  BaseImageResource2.prototype.update = function() {
    if (this.destroyed) {
      return;
    }
    var source = this.source;
    var width = source.naturalWidth || source.videoWidth || source.width;
    var height = source.naturalHeight || source.videoHeight || source.height;
    this.resize(width, height);
    _super.prototype.update.call(this);
  };
  BaseImageResource2.prototype.dispose = function() {
    this.source = null;
  };
  return BaseImageResource2;
}(Resource);
var CanvasResource = function(_super) {
  __extends$i(CanvasResource2, _super);
  function CanvasResource2(source) {
    return _super.call(this, source) || this;
  }
  CanvasResource2.test = function(source) {
    var OffscreenCanvas2 = globalThis.OffscreenCanvas;
    if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
      return true;
    }
    return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
  };
  return CanvasResource2;
}(BaseImageResource);
var CubeResource = function(_super) {
  __extends$i(CubeResource2, _super);
  function CubeResource2(source, options) {
    var _this = this;
    var _a2 = options || {}, width = _a2.width, height = _a2.height, autoLoad = _a2.autoLoad, linkBaseTexture = _a2.linkBaseTexture;
    if (source && source.length !== CubeResource2.SIDES) {
      throw new Error("Invalid length. Got " + source.length + ", expected 6");
    }
    _this = _super.call(this, 6, { width, height }) || this;
    for (var i = 0; i < CubeResource2.SIDES; i++) {
      _this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
    }
    _this.linkBaseTexture = linkBaseTexture !== false;
    if (source) {
      _this.initFromArray(source, options);
    }
    if (autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  CubeResource2.prototype.bind = function(baseTexture) {
    _super.prototype.bind.call(this, baseTexture);
    baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
  };
  CubeResource2.prototype.addBaseTextureAt = function(baseTexture, index, linkBaseTexture) {
    if (!this.items[index]) {
      throw new Error("Index " + index + " is out of bounds");
    }
    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index);
      } else {
        throw new Error("CubeResource does not support copying of renderTexture.");
      }
    } else {
      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;
      baseTexture.parentTextureArray = this.baseTexture;
      this.items[index] = baseTexture;
    }
    if (baseTexture.valid && !this.valid) {
      this.resize(baseTexture.realWidth, baseTexture.realHeight);
    }
    this.items[index] = baseTexture;
    return this;
  };
  CubeResource2.prototype.upload = function(renderer2, _baseTexture, glTexture) {
    var dirty = this.itemDirtyIds;
    for (var i = 0; i < CubeResource2.SIDES; i++) {
      var side = this.items[i];
      if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {
        if (side.valid && side.resource) {
          side.resource.upload(renderer2, side, glTexture);
          dirty[i] = side.dirtyId;
        } else if (dirty[i] < -1) {
          renderer2.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
          dirty[i] = -1;
        }
      }
    }
    return true;
  };
  CubeResource2.test = function(source) {
    return Array.isArray(source) && source.length === CubeResource2.SIDES;
  };
  CubeResource2.SIDES = 6;
  return CubeResource2;
}(AbstractMultiResource);
var ImageResource = function(_super) {
  __extends$i(ImageResource2, _super);
  function ImageResource2(source, options) {
    var _this = this;
    options = options || {};
    if (!(source instanceof HTMLImageElement)) {
      var imageElement = new Image();
      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
      imageElement.src = source;
      source = imageElement;
    }
    _this = _super.call(this, source) || this;
    if (!source.complete && !!_this._width && !!_this._height) {
      _this._width = 0;
      _this._height = 0;
    }
    _this.url = source.src;
    _this._process = null;
    _this.preserveBitmap = false;
    _this.createBitmap = (options.createBitmap !== void 0 ? options.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
    _this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    _this.bitmap = null;
    _this._load = null;
    if (options.autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  ImageResource2.prototype.load = function(createBitmap) {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    if (createBitmap !== void 0) {
      this.createBitmap = createBitmap;
    }
    this._load = new Promise(function(resolve2, reject2) {
      var source = _this.source;
      _this.url = source.src;
      var completed = function() {
        if (_this.destroyed) {
          return;
        }
        source.onload = null;
        source.onerror = null;
        _this.resize(source.width, source.height);
        _this._load = null;
        if (_this.createBitmap) {
          resolve2(_this.process());
        } else {
          resolve2(_this);
        }
      };
      if (source.complete && source.src) {
        completed();
      } else {
        source.onload = completed;
        source.onerror = function(event) {
          reject2(event);
          _this.onError.emit(event);
        };
      }
    });
    return this._load;
  };
  ImageResource2.prototype.process = function() {
    var _this = this;
    var source = this.source;
    if (this._process !== null) {
      return this._process;
    }
    if (this.bitmap !== null || !globalThis.createImageBitmap) {
      return Promise.resolve(this);
    }
    var createImageBitmap = globalThis.createImageBitmap;
    var cors = !source.crossOrigin || source.crossOrigin === "anonymous";
    this._process = fetch(source.src, {
      mode: cors ? "cors" : "no-cors"
    }).then(function(r2) {
      return r2.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, 0, 0, source.width, source.height, {
        premultiplyAlpha: _this.alphaMode === null || _this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
      });
    }).then(function(bitmap) {
      if (_this.destroyed) {
        return Promise.reject();
      }
      _this.bitmap = bitmap;
      _this.update();
      _this._process = null;
      return Promise.resolve(_this);
    });
    return this._process;
  };
  ImageResource2.prototype.upload = function(renderer2, baseTexture, glTexture) {
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    if (!this.createBitmap) {
      return _super.prototype.upload.call(this, renderer2, baseTexture, glTexture);
    }
    if (!this.bitmap) {
      this.process();
      if (!this.bitmap) {
        return false;
      }
    }
    _super.prototype.upload.call(this, renderer2, baseTexture, glTexture, this.bitmap);
    if (!this.preserveBitmap) {
      var flag = true;
      var glTextures = baseTexture._glTextures;
      for (var key in glTextures) {
        var otherTex = glTextures[key];
        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
          flag = false;
          break;
        }
      }
      if (flag) {
        if (this.bitmap.close) {
          this.bitmap.close();
        }
        this.bitmap = null;
      }
    }
    return true;
  };
  ImageResource2.prototype.dispose = function() {
    this.source.onload = null;
    this.source.onerror = null;
    _super.prototype.dispose.call(this);
    if (this.bitmap) {
      this.bitmap.close();
      this.bitmap = null;
    }
    this._process = null;
    this._load = null;
  };
  ImageResource2.test = function(source) {
    return typeof source === "string" || source instanceof HTMLImageElement;
  };
  return ImageResource2;
}(BaseImageResource);
var SVGResource = function(_super) {
  __extends$i(SVGResource2, _super);
  function SVGResource2(sourceBase64, options) {
    var _this = this;
    options = options || {};
    _this = _super.call(this, settings.ADAPTER.createCanvas()) || this;
    _this._width = 0;
    _this._height = 0;
    _this.svg = sourceBase64;
    _this.scale = options.scale || 1;
    _this._overrideWidth = options.width;
    _this._overrideHeight = options.height;
    _this._resolve = null;
    _this._crossorigin = options.crossorigin;
    _this._load = null;
    if (options.autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  SVGResource2.prototype.load = function() {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    this._load = new Promise(function(resolve2) {
      _this._resolve = function() {
        _this.resize(_this.source.width, _this.source.height);
        resolve2(_this);
      };
      if (SVGResource2.SVG_XML.test(_this.svg.trim())) {
        if (!btoa) {
          throw new Error("Your browser doesn't support base64 conversions.");
        }
        _this.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(_this.svg)));
      }
      _this._loadSvg();
    });
    return this._load;
  };
  SVGResource2.prototype._loadSvg = function() {
    var _this = this;
    var tempImage = new Image();
    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
    tempImage.src = this.svg;
    tempImage.onerror = function(event) {
      if (!_this._resolve) {
        return;
      }
      tempImage.onerror = null;
      _this.onError.emit(event);
    };
    tempImage.onload = function() {
      if (!_this._resolve) {
        return;
      }
      var svgWidth = tempImage.width;
      var svgHeight = tempImage.height;
      if (!svgWidth || !svgHeight) {
        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
      }
      var width = svgWidth * _this.scale;
      var height = svgHeight * _this.scale;
      if (_this._overrideWidth || _this._overrideHeight) {
        width = _this._overrideWidth || _this._overrideHeight / svgHeight * svgWidth;
        height = _this._overrideHeight || _this._overrideWidth / svgWidth * svgHeight;
      }
      width = Math.round(width);
      height = Math.round(height);
      var canvas = _this.source;
      canvas.width = width;
      canvas.height = height;
      canvas._pixiId = "canvas_" + uid();
      canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
      _this._resolve();
      _this._resolve = null;
    };
  };
  SVGResource2.getSize = function(svgString) {
    var sizeMatch = SVGResource2.SVG_SIZE.exec(svgString);
    var size = {};
    if (sizeMatch) {
      size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
      size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
    }
    return size;
  };
  SVGResource2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this._resolve = null;
    this._crossorigin = null;
  };
  SVGResource2.test = function(source, extension) {
    return extension === "svg" || typeof source === "string" && source.startsWith("data:image/svg+xml") || typeof source === "string" && SVGResource2.SVG_XML.test(source);
  };
  SVGResource2.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
  SVGResource2.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
  return SVGResource2;
}(BaseImageResource);
var VideoResource = function(_super) {
  __extends$i(VideoResource2, _super);
  function VideoResource2(source, options) {
    var _this = this;
    options = options || {};
    if (!(source instanceof HTMLVideoElement)) {
      var videoElement = document.createElement("video");
      videoElement.setAttribute("preload", "auto");
      videoElement.setAttribute("webkit-playsinline", "");
      videoElement.setAttribute("playsinline", "");
      if (typeof source === "string") {
        source = [source];
      }
      var firstSrc = source[0].src || source[0];
      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
      for (var i = 0; i < source.length; ++i) {
        var sourceElement = document.createElement("source");
        var _a2 = source[i], src = _a2.src, mime = _a2.mime;
        src = src || source[i];
        var baseSrc = src.split("?").shift().toLowerCase();
        var ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
        mime = mime || VideoResource2.MIME_TYPES[ext] || "video/" + ext;
        sourceElement.src = src;
        sourceElement.type = mime;
        videoElement.appendChild(sourceElement);
      }
      source = videoElement;
    }
    _this = _super.call(this, source) || this;
    _this.noSubImage = true;
    _this._autoUpdate = true;
    _this._isConnectedToTicker = false;
    _this._updateFPS = options.updateFPS || 0;
    _this._msToNextUpdate = 0;
    _this.autoPlay = options.autoPlay !== false;
    _this._load = null;
    _this._resolve = null;
    _this._onCanPlay = _this._onCanPlay.bind(_this);
    _this._onError = _this._onError.bind(_this);
    if (options.autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  VideoResource2.prototype.update = function(_deltaTime) {
    if (!this.destroyed) {
      var elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      if (!this._updateFPS || this._msToNextUpdate <= 0) {
        _super.prototype.update.call(this);
        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
      }
    }
  };
  VideoResource2.prototype.load = function() {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    var source = this.source;
    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
      source.complete = true;
    }
    source.addEventListener("play", this._onPlayStart.bind(this));
    source.addEventListener("pause", this._onPlayStop.bind(this));
    if (!this._isSourceReady()) {
      source.addEventListener("canplay", this._onCanPlay);
      source.addEventListener("canplaythrough", this._onCanPlay);
      source.addEventListener("error", this._onError, true);
    } else {
      this._onCanPlay();
    }
    this._load = new Promise(function(resolve2) {
      if (_this.valid) {
        resolve2(_this);
      } else {
        _this._resolve = resolve2;
        source.load();
      }
    });
    return this._load;
  };
  VideoResource2.prototype._onError = function(event) {
    this.source.removeEventListener("error", this._onError, true);
    this.onError.emit(event);
  };
  VideoResource2.prototype._isSourcePlaying = function() {
    var source = this.source;
    return !source.paused && !source.ended && this._isSourceReady();
  };
  VideoResource2.prototype._isSourceReady = function() {
    var source = this.source;
    return source.readyState > 2;
  };
  VideoResource2.prototype._onPlayStart = function() {
    if (!this.valid) {
      this._onCanPlay();
    }
    if (this.autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this);
      this._isConnectedToTicker = true;
    }
  };
  VideoResource2.prototype._onPlayStop = function() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  };
  VideoResource2.prototype._onCanPlay = function() {
    var source = this.source;
    source.removeEventListener("canplay", this._onCanPlay);
    source.removeEventListener("canplaythrough", this._onCanPlay);
    var valid = this.valid;
    this.resize(source.videoWidth, source.videoHeight);
    if (!valid && this._resolve) {
      this._resolve(this);
      this._resolve = null;
    }
    if (this._isSourcePlaying()) {
      this._onPlayStart();
    } else if (this.autoPlay) {
      source.play();
    }
  };
  VideoResource2.prototype.dispose = function() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
    var source = this.source;
    if (source) {
      source.removeEventListener("error", this._onError, true);
      source.pause();
      source.src = "";
      source.load();
    }
    _super.prototype.dispose.call(this);
  };
  Object.defineProperty(VideoResource2.prototype, "autoUpdate", {
    get: function() {
      return this._autoUpdate;
    },
    set: function(value) {
      if (value !== this._autoUpdate) {
        this._autoUpdate = value;
        if (!this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VideoResource2.prototype, "updateFPS", {
    get: function() {
      return this._updateFPS;
    },
    set: function(value) {
      if (value !== this._updateFPS) {
        this._updateFPS = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  VideoResource2.test = function(source, extension) {
    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || VideoResource2.TYPES.indexOf(extension) > -1;
  };
  VideoResource2.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
  VideoResource2.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  };
  return VideoResource2;
}(BaseImageResource);
var ImageBitmapResource = function(_super) {
  __extends$i(ImageBitmapResource2, _super);
  function ImageBitmapResource2(source) {
    return _super.call(this, source) || this;
  }
  ImageBitmapResource2.test = function(source) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap !== "undefined" && source instanceof ImageBitmap;
  };
  return ImageBitmapResource2;
}(BaseImageResource);
INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
var DepthResource = function(_super) {
  __extends$i(DepthResource2, _super);
  function DepthResource2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DepthResource2.prototype.upload = function(renderer2, baseTexture, glTexture) {
    var gl = renderer2.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    var width = baseTexture.realWidth;
    var height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  };
  return DepthResource2;
}(BufferResource);
var Framebuffer = function() {
  function Framebuffer2(width, height) {
    this.width = Math.round(width || 100);
    this.height = Math.round(height || 100);
    this.stencil = false;
    this.depth = false;
    this.dirtyId = 0;
    this.dirtyFormat = 0;
    this.dirtySize = 0;
    this.depthTexture = null;
    this.colorTextures = [];
    this.glFramebuffers = {};
    this.disposeRunner = new Runner("disposeFramebuffer");
    this.multisample = MSAA_QUALITY.NONE;
  }
  Object.defineProperty(Framebuffer2.prototype, "colorTexture", {
    get: function() {
      return this.colorTextures[0];
    },
    enumerable: false,
    configurable: true
  });
  Framebuffer2.prototype.addColorTexture = function(index, texture) {
    if (index === void 0) {
      index = 0;
    }
    this.colorTextures[index] = texture || new BaseTexture(null, {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      mipmap: MIPMAP_MODES.OFF,
      width: this.width,
      height: this.height
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.addDepthTexture = function(texture) {
    this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: MIPMAP_MODES.OFF,
      format: FORMATS.DEPTH_COMPONENT,
      type: TYPES.UNSIGNED_SHORT
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.enableDepth = function() {
    this.depth = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.enableStencil = function() {
    this.stencil = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.resize = function(width, height) {
    width = Math.round(width);
    height = Math.round(height);
    if (width === this.width && height === this.height) {
      return;
    }
    this.width = width;
    this.height = height;
    this.dirtyId++;
    this.dirtySize++;
    for (var i = 0; i < this.colorTextures.length; i++) {
      var texture = this.colorTextures[i];
      var resolution = texture.resolution;
      texture.setSize(width / resolution, height / resolution);
    }
    if (this.depthTexture) {
      var resolution = this.depthTexture.resolution;
      this.depthTexture.setSize(width / resolution, height / resolution);
    }
  };
  Framebuffer2.prototype.dispose = function() {
    this.disposeRunner.emit(this, false);
  };
  Framebuffer2.prototype.destroyDepthTexture = function() {
    if (this.depthTexture) {
      this.depthTexture.destroy();
      this.depthTexture = null;
      ++this.dirtyId;
      ++this.dirtyFormat;
    }
  };
  return Framebuffer2;
}();
var BaseRenderTexture = function(_super) {
  __extends$i(BaseRenderTexture2, _super);
  function BaseRenderTexture2(options) {
    if (options === void 0) {
      options = {};
    }
    var _this = this;
    if (typeof options === "number") {
      var width = arguments[0];
      var height = arguments[1];
      var scaleMode = arguments[2];
      var resolution = arguments[3];
      options = { width, height, scaleMode, resolution };
    }
    options.width = options.width || 100;
    options.height = options.height || 100;
    options.multisample = options.multisample !== void 0 ? options.multisample : MSAA_QUALITY.NONE;
    _this = _super.call(this, null, options) || this;
    _this.mipmap = MIPMAP_MODES.OFF;
    _this.valid = true;
    _this.clearColor = [0, 0, 0, 0];
    _this.framebuffer = new Framebuffer(_this.realWidth, _this.realHeight).addColorTexture(0, _this);
    _this.framebuffer.multisample = options.multisample;
    _this.maskStack = [];
    _this.filterStack = [{}];
    return _this;
  }
  BaseRenderTexture2.prototype.resize = function(desiredWidth, desiredHeight) {
    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
    this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  };
  BaseRenderTexture2.prototype.dispose = function() {
    this.framebuffer.dispose();
    _super.prototype.dispose.call(this);
  };
  BaseRenderTexture2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.framebuffer.destroyDepthTexture();
    this.framebuffer = null;
  };
  return BaseRenderTexture2;
}(BaseTexture);
var TextureUvs = function() {
  function TextureUvs2() {
    this.x0 = 0;
    this.y0 = 0;
    this.x1 = 1;
    this.y1 = 0;
    this.x2 = 1;
    this.y2 = 1;
    this.x3 = 0;
    this.y3 = 1;
    this.uvsFloat32 = new Float32Array(8);
  }
  TextureUvs2.prototype.set = function(frame, baseFrame, rotate) {
    var tw = baseFrame.width;
    var th = baseFrame.height;
    if (rotate) {
      var w2 = frame.width / 2 / tw;
      var h2 = frame.height / 2 / th;
      var cX = frame.x / tw + w2;
      var cY = frame.y / th + h2;
      rotate = groupD8.add(rotate, groupD8.NW);
      this.x0 = cX + w2 * groupD8.uX(rotate);
      this.y0 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x1 = cX + w2 * groupD8.uX(rotate);
      this.y1 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x2 = cX + w2 * groupD8.uX(rotate);
      this.y2 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x3 = cX + w2 * groupD8.uX(rotate);
      this.y3 = cY + h2 * groupD8.uY(rotate);
    } else {
      this.x0 = frame.x / tw;
      this.y0 = frame.y / th;
      this.x1 = (frame.x + frame.width) / tw;
      this.y1 = frame.y / th;
      this.x2 = (frame.x + frame.width) / tw;
      this.y2 = (frame.y + frame.height) / th;
      this.x3 = frame.x / tw;
      this.y3 = (frame.y + frame.height) / th;
    }
    this.uvsFloat32[0] = this.x0;
    this.uvsFloat32[1] = this.y0;
    this.uvsFloat32[2] = this.x1;
    this.uvsFloat32[3] = this.y1;
    this.uvsFloat32[4] = this.x2;
    this.uvsFloat32[5] = this.y2;
    this.uvsFloat32[6] = this.x3;
    this.uvsFloat32[7] = this.y3;
  };
  TextureUvs2.prototype.toString = function() {
    return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
  };
  return TextureUvs2;
}();
var DEFAULT_UVS = new TextureUvs();
function removeAllHandlers(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
}
var Texture = function(_super) {
  __extends$i(Texture2, _super);
  function Texture2(baseTexture, frame, orig, trim3, rotate, anchor) {
    var _this = _super.call(this) || this;
    _this.noFrame = false;
    if (!frame) {
      _this.noFrame = true;
      frame = new Rectangle(0, 0, 1, 1);
    }
    if (baseTexture instanceof Texture2) {
      baseTexture = baseTexture.baseTexture;
    }
    _this.baseTexture = baseTexture;
    _this._frame = frame;
    _this.trim = trim3;
    _this.valid = false;
    _this._uvs = DEFAULT_UVS;
    _this.uvMatrix = null;
    _this.orig = orig || frame;
    _this._rotate = Number(rotate || 0);
    if (rotate === true) {
      _this._rotate = 2;
    } else if (_this._rotate % 2 !== 0) {
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    }
    _this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
    _this._updateID = 0;
    _this.textureCacheIds = [];
    if (!baseTexture.valid) {
      baseTexture.once("loaded", _this.onBaseTextureUpdated, _this);
    } else if (_this.noFrame) {
      if (baseTexture.valid) {
        _this.onBaseTextureUpdated(baseTexture);
      }
    } else {
      _this.frame = frame;
    }
    if (_this.noFrame) {
      baseTexture.on("update", _this.onBaseTextureUpdated, _this);
    }
    return _this;
  }
  Texture2.prototype.update = function() {
    if (this.baseTexture.resource) {
      this.baseTexture.resource.update();
    }
  };
  Texture2.prototype.onBaseTextureUpdated = function(baseTexture) {
    if (this.noFrame) {
      if (!this.baseTexture.valid) {
        return;
      }
      this._frame.width = baseTexture.width;
      this._frame.height = baseTexture.height;
      this.valid = true;
      this.updateUvs();
    } else {
      this.frame = this._frame;
    }
    this.emit("update", this);
  };
  Texture2.prototype.destroy = function(destroyBase) {
    if (this.baseTexture) {
      if (destroyBase) {
        var resource = this.baseTexture.resource;
        if (resource && resource.url && TextureCache[resource.url]) {
          Texture2.removeFromCache(resource.url);
        }
        this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
      this.baseTexture.off("update", this.onBaseTextureUpdated, this);
      this.baseTexture = null;
    }
    this._frame = null;
    this._uvs = null;
    this.trim = null;
    this.orig = null;
    this.valid = false;
    Texture2.removeFromCache(this);
    this.textureCacheIds = null;
  };
  Texture2.prototype.clone = function() {
    var clonedFrame = this._frame.clone();
    var clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
    var clonedTexture = new Texture2(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
    if (this.noFrame) {
      clonedTexture._frame = clonedFrame;
    }
    return clonedTexture;
  };
  Texture2.prototype.updateUvs = function() {
    if (this._uvs === DEFAULT_UVS) {
      this._uvs = new TextureUvs();
    }
    this._uvs.set(this._frame, this.baseTexture, this.rotate);
    this._updateID++;
  };
  Texture2.from = function(source, options, strict) {
    if (options === void 0) {
      options = {};
    }
    if (strict === void 0) {
      strict = settings.STRICT_TEXTURE_CACHE;
    }
    var isFrame = typeof source === "string";
    var cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else if (source instanceof BaseTexture) {
      if (!source.cacheId) {
        var prefix = options && options.pixiIdPrefix || "pixiid";
        source.cacheId = prefix + "-" + uid();
        BaseTexture.addToCache(source, source.cacheId);
      }
      cacheId = source.cacheId;
    } else {
      if (!source._pixiId) {
        var prefix = options && options.pixiIdPrefix || "pixiid";
        source._pixiId = prefix + "_" + uid();
      }
      cacheId = source._pixiId;
    }
    var texture = TextureCache[cacheId];
    if (isFrame && strict && !texture) {
      throw new Error('The cacheId "' + cacheId + '" does not exist in TextureCache.');
    }
    if (!texture && !(source instanceof BaseTexture)) {
      if (!options.resolution) {
        options.resolution = getResolutionOfUrl(source);
      }
      texture = new Texture2(new BaseTexture(source, options));
      texture.baseTexture.cacheId = cacheId;
      BaseTexture.addToCache(texture.baseTexture, cacheId);
      Texture2.addToCache(texture, cacheId);
    } else if (!texture && source instanceof BaseTexture) {
      texture = new Texture2(source);
      Texture2.addToCache(texture, cacheId);
    }
    return texture;
  };
  Texture2.fromURL = function(url2, options) {
    var resourceOptions = Object.assign({ autoLoad: false }, options === null || options === void 0 ? void 0 : options.resourceOptions);
    var texture = Texture2.from(url2, Object.assign({ resourceOptions }, options), false);
    var resource = texture.baseTexture.resource;
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return resource.load().then(function() {
      return Promise.resolve(texture);
    });
  };
  Texture2.fromBuffer = function(buffer, width, height, options) {
    return new Texture2(BaseTexture.fromBuffer(buffer, width, height, options));
  };
  Texture2.fromLoader = function(source, imageUrl, name, options) {
    var baseTexture = new BaseTexture(source, Object.assign({
      scaleMode: settings.SCALE_MODE,
      resolution: getResolutionOfUrl(imageUrl)
    }, options));
    var resource = baseTexture.resource;
    if (resource instanceof ImageResource) {
      resource.url = imageUrl;
    }
    var texture = new Texture2(baseTexture);
    if (!name) {
      name = imageUrl;
    }
    BaseTexture.addToCache(texture.baseTexture, name);
    Texture2.addToCache(texture, name);
    if (name !== imageUrl) {
      BaseTexture.addToCache(texture.baseTexture, imageUrl);
      Texture2.addToCache(texture, imageUrl);
    }
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return new Promise(function(resolve2) {
      texture.baseTexture.once("loaded", function() {
        return resolve2(texture);
      });
    });
  };
  Texture2.addToCache = function(texture, id) {
    if (id) {
      if (texture.textureCacheIds.indexOf(id) === -1) {
        texture.textureCacheIds.push(id);
      }
      if (TextureCache[id]) {
        console.warn("Texture added to the cache with an id [" + id + "] that already had an entry");
      }
      TextureCache[id] = texture;
    }
  };
  Texture2.removeFromCache = function(texture) {
    if (typeof texture === "string") {
      var textureFromCache = TextureCache[texture];
      if (textureFromCache) {
        var index = textureFromCache.textureCacheIds.indexOf(texture);
        if (index > -1) {
          textureFromCache.textureCacheIds.splice(index, 1);
        }
        delete TextureCache[texture];
        return textureFromCache;
      }
    } else if (texture && texture.textureCacheIds) {
      for (var i = 0; i < texture.textureCacheIds.length; ++i) {
        if (TextureCache[texture.textureCacheIds[i]] === texture) {
          delete TextureCache[texture.textureCacheIds[i]];
        }
      }
      texture.textureCacheIds.length = 0;
      return texture;
    }
    return null;
  };
  Object.defineProperty(Texture2.prototype, "resolution", {
    get: function() {
      return this.baseTexture.resolution;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "frame", {
    get: function() {
      return this._frame;
    },
    set: function(frame) {
      this._frame = frame;
      this.noFrame = false;
      var x2 = frame.x, y2 = frame.y, width = frame.width, height = frame.height;
      var xNotFit = x2 + width > this.baseTexture.width;
      var yNotFit = y2 + height > this.baseTexture.height;
      if (xNotFit || yNotFit) {
        var relationship = xNotFit && yNotFit ? "and" : "or";
        var errorX = "X: " + x2 + " + " + width + " = " + (x2 + width) + " > " + this.baseTexture.width;
        var errorY = "Y: " + y2 + " + " + height + " = " + (y2 + height) + " > " + this.baseTexture.height;
        throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (errorX + " " + relationship + " " + errorY));
      }
      this.valid = width && height && this.baseTexture.valid;
      if (!this.trim && !this.rotate) {
        this.orig = frame;
      }
      if (this.valid) {
        this.updateUvs();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "rotate", {
    get: function() {
      return this._rotate;
    },
    set: function(rotate) {
      this._rotate = rotate;
      if (this.valid) {
        this.updateUvs();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "width", {
    get: function() {
      return this.orig.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "height", {
    get: function() {
      return this.orig.height;
    },
    enumerable: false,
    configurable: true
  });
  Texture2.prototype.castToBaseTexture = function() {
    return this.baseTexture;
  };
  Object.defineProperty(Texture2, "EMPTY", {
    get: function() {
      if (!Texture2._EMPTY) {
        Texture2._EMPTY = new Texture2(new BaseTexture());
        removeAllHandlers(Texture2._EMPTY);
        removeAllHandlers(Texture2._EMPTY.baseTexture);
      }
      return Texture2._EMPTY;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2, "WHITE", {
    get: function() {
      if (!Texture2._WHITE) {
        var canvas = settings.ADAPTER.createCanvas(16, 16);
        var context2 = canvas.getContext("2d");
        canvas.width = 16;
        canvas.height = 16;
        context2.fillStyle = "white";
        context2.fillRect(0, 0, 16, 16);
        Texture2._WHITE = new Texture2(BaseTexture.from(canvas));
        removeAllHandlers(Texture2._WHITE);
        removeAllHandlers(Texture2._WHITE.baseTexture);
      }
      return Texture2._WHITE;
    },
    enumerable: false,
    configurable: true
  });
  return Texture2;
}(EventEmitter$1);
var RenderTexture = function(_super) {
  __extends$i(RenderTexture2, _super);
  function RenderTexture2(baseRenderTexture, frame) {
    var _this = _super.call(this, baseRenderTexture, frame) || this;
    _this.valid = true;
    _this.filterFrame = null;
    _this.filterPoolKey = null;
    _this.updateUvs();
    return _this;
  }
  Object.defineProperty(RenderTexture2.prototype, "framebuffer", {
    get: function() {
      return this.baseTexture.framebuffer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTexture2.prototype, "multisample", {
    get: function() {
      return this.framebuffer.multisample;
    },
    set: function(value) {
      this.framebuffer.multisample = value;
    },
    enumerable: false,
    configurable: true
  });
  RenderTexture2.prototype.resize = function(desiredWidth, desiredHeight, resizeBaseTexture) {
    if (resizeBaseTexture === void 0) {
      resizeBaseTexture = true;
    }
    var resolution = this.baseTexture.resolution;
    var width = Math.round(desiredWidth * resolution) / resolution;
    var height = Math.round(desiredHeight * resolution) / resolution;
    this.valid = width > 0 && height > 0;
    this._frame.width = this.orig.width = width;
    this._frame.height = this.orig.height = height;
    if (resizeBaseTexture) {
      this.baseTexture.resize(width, height);
    }
    this.updateUvs();
  };
  RenderTexture2.prototype.setResolution = function(resolution) {
    var baseTexture = this.baseTexture;
    if (baseTexture.resolution === resolution) {
      return;
    }
    baseTexture.setResolution(resolution);
    this.resize(baseTexture.width, baseTexture.height, false);
  };
  RenderTexture2.create = function(options) {
    var arguments$1 = arguments;
    var rest = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      rest[_i - 1] = arguments$1[_i];
    }
    if (typeof options === "number") {
      deprecation("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated.");
      options = {
        width: options,
        height: rest[0],
        scaleMode: rest[1],
        resolution: rest[2]
      };
    }
    return new RenderTexture2(new BaseRenderTexture(options));
  };
  return RenderTexture2;
}(Texture);
var RenderTexturePool = function() {
  function RenderTexturePool2(textureOptions) {
    this.texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
    this._pixelsWidth = 0;
    this._pixelsHeight = 0;
  }
  RenderTexturePool2.prototype.createTexture = function(realWidth, realHeight, multisample) {
    if (multisample === void 0) {
      multisample = MSAA_QUALITY.NONE;
    }
    var baseRenderTexture = new BaseRenderTexture(Object.assign({
      width: realWidth,
      height: realHeight,
      resolution: 1,
      multisample
    }, this.textureOptions));
    return new RenderTexture(baseRenderTexture);
  };
  RenderTexturePool2.prototype.getOptimalTexture = function(minWidth, minHeight, resolution, multisample) {
    if (resolution === void 0) {
      resolution = 1;
    }
    if (multisample === void 0) {
      multisample = MSAA_QUALITY.NONE;
    }
    var key;
    minWidth = Math.ceil(minWidth * resolution - 1e-6);
    minHeight = Math.ceil(minHeight * resolution - 1e-6);
    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
      minWidth = nextPow2(minWidth);
      minHeight = nextPow2(minHeight);
      key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
      if (multisample > 1) {
        key += multisample * 4294967296;
      }
    } else {
      key = multisample > 1 ? -multisample : -1;
    }
    if (!this.texturePool[key]) {
      this.texturePool[key] = [];
    }
    var renderTexture = this.texturePool[key].pop();
    if (!renderTexture) {
      renderTexture = this.createTexture(minWidth, minHeight, multisample);
    }
    renderTexture.filterPoolKey = key;
    renderTexture.setResolution(resolution);
    return renderTexture;
  };
  RenderTexturePool2.prototype.getFilterTexture = function(input, resolution, multisample) {
    var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  };
  RenderTexturePool2.prototype.returnTexture = function(renderTexture) {
    var key = renderTexture.filterPoolKey;
    renderTexture.filterFrame = null;
    this.texturePool[key].push(renderTexture);
  };
  RenderTexturePool2.prototype.returnFilterTexture = function(renderTexture) {
    this.returnTexture(renderTexture);
  };
  RenderTexturePool2.prototype.clear = function(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (var i in this.texturePool) {
        var textures = this.texturePool[i];
        if (textures) {
          for (var j2 = 0; j2 < textures.length; j2++) {
            textures[j2].destroy(true);
          }
        }
      }
    }
    this.texturePool = {};
  };
  RenderTexturePool2.prototype.setScreenSize = function(size) {
    if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
      return;
    }
    this.enableFullScreen = size.width > 0 && size.height > 0;
    for (var i in this.texturePool) {
      if (!(Number(i) < 0)) {
        continue;
      }
      var textures = this.texturePool[i];
      if (textures) {
        for (var j2 = 0; j2 < textures.length; j2++) {
          textures[j2].destroy(true);
        }
      }
      this.texturePool[i] = [];
    }
    this._pixelsWidth = size.width;
    this._pixelsHeight = size.height;
  };
  RenderTexturePool2.SCREEN_KEY = -1;
  return RenderTexturePool2;
}();
var Attribute = function() {
  function Attribute2(buffer, size, normalized, type2, stride, start, instance) {
    if (size === void 0) {
      size = 0;
    }
    if (normalized === void 0) {
      normalized = false;
    }
    if (type2 === void 0) {
      type2 = TYPES.FLOAT;
    }
    this.buffer = buffer;
    this.size = size;
    this.normalized = normalized;
    this.type = type2;
    this.stride = stride;
    this.start = start;
    this.instance = instance;
  }
  Attribute2.prototype.destroy = function() {
    this.buffer = null;
  };
  Attribute2.from = function(buffer, size, normalized, type2, stride) {
    return new Attribute2(buffer, size, normalized, type2, stride);
  };
  return Attribute2;
}();
var UID$4 = 0;
var Buffer = function() {
  function Buffer2(data, _static, index) {
    if (_static === void 0) {
      _static = true;
    }
    if (index === void 0) {
      index = false;
    }
    this.data = data || new Float32Array(1);
    this._glBuffers = {};
    this._updateID = 0;
    this.index = index;
    this.static = _static;
    this.id = UID$4++;
    this.disposeRunner = new Runner("disposeBuffer");
  }
  Buffer2.prototype.update = function(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    this.data = data || this.data;
    this._updateID++;
  };
  Buffer2.prototype.dispose = function() {
    this.disposeRunner.emit(this, false);
  };
  Buffer2.prototype.destroy = function() {
    this.dispose();
    this.data = null;
  };
  Object.defineProperty(Buffer2.prototype, "index", {
    get: function() {
      return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    },
    set: function(value) {
      this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
    },
    enumerable: false,
    configurable: true
  });
  Buffer2.from = function(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    return new Buffer2(data);
  };
  return Buffer2;
}();
var map$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(arrays, sizes) {
  var outSize = 0;
  var stride = 0;
  var views = {};
  for (var i = 0; i < arrays.length; i++) {
    stride += sizes[i];
    outSize += arrays[i].length;
  }
  var buffer = new ArrayBuffer(outSize * 4);
  var out = null;
  var littleOffset = 0;
  for (var i = 0; i < arrays.length; i++) {
    var size = sizes[i];
    var array = arrays[i];
    var type2 = getBufferType(array);
    if (!views[type2]) {
      views[type2] = new map$1[type2](buffer);
    }
    out = views[type2];
    for (var j2 = 0; j2 < array.length; j2++) {
      var indexStart = (j2 / size | 0) * stride + littleOffset;
      var index = j2 % size;
      out[indexStart + index] = array[j2];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}
var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
var UID$3 = 0;
var map$2 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
var Geometry = function() {
  function Geometry2(buffers, attributes) {
    if (buffers === void 0) {
      buffers = [];
    }
    if (attributes === void 0) {
      attributes = {};
    }
    this.buffers = buffers;
    this.indexBuffer = null;
    this.attributes = attributes;
    this.glVertexArrayObjects = {};
    this.id = UID$3++;
    this.instanced = false;
    this.instanceCount = 1;
    this.disposeRunner = new Runner("disposeGeometry");
    this.refCount = 0;
  }
  Geometry2.prototype.addAttribute = function(id, buffer, size, normalized, type2, stride, start, instance) {
    if (size === void 0) {
      size = 0;
    }
    if (normalized === void 0) {
      normalized = false;
    }
    if (instance === void 0) {
      instance = false;
    }
    if (!buffer) {
      throw new Error("You must pass a buffer when creating an attribute");
    }
    if (!(buffer instanceof Buffer)) {
      if (buffer instanceof Array) {
        buffer = new Float32Array(buffer);
      }
      buffer = new Buffer(buffer);
    }
    var ids = id.split("|");
    if (ids.length > 1) {
      for (var i = 0; i < ids.length; i++) {
        this.addAttribute(ids[i], buffer, size, normalized, type2);
      }
      return this;
    }
    var bufferIndex = this.buffers.indexOf(buffer);
    if (bufferIndex === -1) {
      this.buffers.push(buffer);
      bufferIndex = this.buffers.length - 1;
    }
    this.attributes[id] = new Attribute(bufferIndex, size, normalized, type2, stride, start, instance);
    this.instanced = this.instanced || instance;
    return this;
  };
  Geometry2.prototype.getAttribute = function(id) {
    return this.attributes[id];
  };
  Geometry2.prototype.getBuffer = function(id) {
    return this.buffers[this.getAttribute(id).buffer];
  };
  Geometry2.prototype.addIndex = function(buffer) {
    if (!(buffer instanceof Buffer)) {
      if (buffer instanceof Array) {
        buffer = new Uint16Array(buffer);
      }
      buffer = new Buffer(buffer);
    }
    buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    this.indexBuffer = buffer;
    if (this.buffers.indexOf(buffer) === -1) {
      this.buffers.push(buffer);
    }
    return this;
  };
  Geometry2.prototype.getIndex = function() {
    return this.indexBuffer;
  };
  Geometry2.prototype.interleave = function() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) {
      return this;
    }
    var arrays = [];
    var sizes = [];
    var interleavedBuffer = new Buffer();
    var i;
    for (i in this.attributes) {
      var attribute = this.attributes[i];
      var buffer = this.buffers[attribute.buffer];
      arrays.push(buffer.data);
      sizes.push(attribute.size * byteSizeMap$1[attribute.type] / 4);
      attribute.buffer = 0;
    }
    interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);
    for (i = 0; i < this.buffers.length; i++) {
      if (this.buffers[i] !== this.indexBuffer) {
        this.buffers[i].destroy();
      }
    }
    this.buffers = [interleavedBuffer];
    if (this.indexBuffer) {
      this.buffers.push(this.indexBuffer);
    }
    return this;
  };
  Geometry2.prototype.getSize = function() {
    for (var i in this.attributes) {
      var attribute = this.attributes[i];
      var buffer = this.buffers[attribute.buffer];
      return buffer.data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  };
  Geometry2.prototype.dispose = function() {
    this.disposeRunner.emit(this, false);
  };
  Geometry2.prototype.destroy = function() {
    this.dispose();
    this.buffers = null;
    this.indexBuffer = null;
    this.attributes = null;
  };
  Geometry2.prototype.clone = function() {
    var geometry = new Geometry2();
    for (var i = 0; i < this.buffers.length; i++) {
      geometry.buffers[i] = new Buffer(this.buffers[i].data.slice(0));
    }
    for (var i in this.attributes) {
      var attrib = this.attributes[i];
      geometry.attributes[i] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
    }
    if (this.indexBuffer) {
      geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
      geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    }
    return geometry;
  };
  Geometry2.merge = function(geometries) {
    var geometryOut = new Geometry2();
    var arrays = [];
    var sizes = [];
    var offsets = [];
    var geometry;
    for (var i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (var j2 = 0; j2 < geometry.buffers.length; j2++) {
        sizes[j2] = sizes[j2] || 0;
        sizes[j2] += geometry.buffers[j2].data.length;
        offsets[j2] = 0;
      }
    }
    for (var i = 0; i < geometry.buffers.length; i++) {
      arrays[i] = new map$2[getBufferType(geometry.buffers[i].data)](sizes[i]);
      geometryOut.buffers[i] = new Buffer(arrays[i]);
    }
    for (var i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (var j2 = 0; j2 < geometry.buffers.length; j2++) {
        arrays[j2].set(geometry.buffers[j2].data, offsets[j2]);
        offsets[j2] += geometry.buffers[j2].data.length;
      }
    }
    geometryOut.attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
      geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      var offset = 0;
      var stride = 0;
      var offset2 = 0;
      var bufferIndexToCount = 0;
      for (var i = 0; i < geometry.buffers.length; i++) {
        if (geometry.buffers[i] !== geometry.indexBuffer) {
          bufferIndexToCount = i;
          break;
        }
      }
      for (var i in geometry.attributes) {
        var attribute = geometry.attributes[i];
        if ((attribute.buffer | 0) === bufferIndexToCount) {
          stride += attribute.size * byteSizeMap$1[attribute.type] / 4;
        }
      }
      for (var i = 0; i < geometries.length; i++) {
        var indexBufferData = geometries[i].indexBuffer.data;
        for (var j2 = 0; j2 < indexBufferData.length; j2++) {
          geometryOut.indexBuffer.data[j2 + offset2] += offset;
        }
        offset += geometries[i].buffers[bufferIndexToCount].data.length / stride;
        offset2 += indexBufferData.length;
      }
    }
    return geometryOut;
  };
  return Geometry2;
}();
var Quad = function(_super) {
  __extends$i(Quad2, _super);
  function Quad2() {
    var _this = _super.call(this) || this;
    _this.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]);
    return _this;
  }
  return Quad2;
}(Geometry);
var QuadUv = function(_super) {
  __extends$i(QuadUv2, _super);
  function QuadUv2() {
    var _this = _super.call(this) || this;
    _this.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    _this.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]);
    _this.vertexBuffer = new Buffer(_this.vertices);
    _this.uvBuffer = new Buffer(_this.uvs);
    _this.addAttribute("aVertexPosition", _this.vertexBuffer).addAttribute("aTextureCoord", _this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
    return _this;
  }
  QuadUv2.prototype.map = function(targetTextureFrame, destinationFrame) {
    var x2 = 0;
    var y2 = 0;
    this.uvs[0] = x2;
    this.uvs[1] = y2;
    this.uvs[2] = x2 + destinationFrame.width / targetTextureFrame.width;
    this.uvs[3] = y2;
    this.uvs[4] = x2 + destinationFrame.width / targetTextureFrame.width;
    this.uvs[5] = y2 + destinationFrame.height / targetTextureFrame.height;
    this.uvs[6] = x2;
    this.uvs[7] = y2 + destinationFrame.height / targetTextureFrame.height;
    x2 = destinationFrame.x;
    y2 = destinationFrame.y;
    this.vertices[0] = x2;
    this.vertices[1] = y2;
    this.vertices[2] = x2 + destinationFrame.width;
    this.vertices[3] = y2;
    this.vertices[4] = x2 + destinationFrame.width;
    this.vertices[5] = y2 + destinationFrame.height;
    this.vertices[6] = x2;
    this.vertices[7] = y2 + destinationFrame.height;
    this.invalidate();
    return this;
  };
  QuadUv2.prototype.invalidate = function() {
    this.vertexBuffer._updateID++;
    this.uvBuffer._updateID++;
    return this;
  };
  return QuadUv2;
}(Geometry);
var UID$2 = 0;
var UniformGroup = function() {
  function UniformGroup2(uniforms, isStatic, isUbo) {
    this.group = true;
    this.syncUniforms = {};
    this.dirtyId = 0;
    this.id = UID$2++;
    this.static = !!isStatic;
    this.ubo = !!isUbo;
    if (uniforms instanceof Buffer) {
      this.buffer = uniforms;
      this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
      this.autoManage = false;
      this.ubo = true;
    } else {
      this.uniforms = uniforms;
      if (this.ubo) {
        this.buffer = new Buffer(new Float32Array(1));
        this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
        this.autoManage = true;
      }
    }
  }
  UniformGroup2.prototype.update = function() {
    this.dirtyId++;
    if (!this.autoManage && this.buffer) {
      this.buffer.update();
    }
  };
  UniformGroup2.prototype.add = function(name, uniforms, _static) {
    if (!this.ubo) {
      this.uniforms[name] = new UniformGroup2(uniforms, _static);
    } else {
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }
  };
  UniformGroup2.from = function(uniforms, _static, _ubo) {
    return new UniformGroup2(uniforms, _static, _ubo);
  };
  UniformGroup2.uboFrom = function(uniforms, _static) {
    return new UniformGroup2(uniforms, _static !== null && _static !== void 0 ? _static : true, true);
  };
  return UniformGroup2;
}();
var FilterState = function() {
  function FilterState2() {
    this.renderTexture = null;
    this.target = null;
    this.legacy = false;
    this.resolution = 1;
    this.multisample = MSAA_QUALITY.NONE;
    this.sourceFrame = new Rectangle();
    this.destinationFrame = new Rectangle();
    this.bindingSourceFrame = new Rectangle();
    this.bindingDestinationFrame = new Rectangle();
    this.filters = [];
    this.transform = null;
  }
  FilterState2.prototype.clear = function() {
    this.target = null;
    this.filters = null;
    this.renderTexture = null;
  };
  return FilterState2;
}();
var tempPoints = [new Point(), new Point(), new Point(), new Point()];
var tempMatrix$2 = new Matrix();
var FilterSystem = function() {
  function FilterSystem2(renderer2) {
    this.renderer = renderer2;
    this.defaultFilterStack = [{}];
    this.texturePool = new RenderTexturePool();
    this.texturePool.setScreenSize(renderer2.view);
    this.statePool = [];
    this.quad = new Quad();
    this.quadUv = new QuadUv();
    this.tempRect = new Rectangle();
    this.activeState = {};
    this.globalUniforms = new UniformGroup({
      outputFrame: new Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, true);
    this.forceClear = false;
    this.useMaxPadding = false;
  }
  FilterSystem2.prototype.push = function(target, filters) {
    var _a2, _b2;
    var renderer2 = this.renderer;
    var filterStack = this.defaultFilterStack;
    var state = this.statePool.pop() || new FilterState();
    var renderTextureSystem = this.renderer.renderTexture;
    var resolution = filters[0].resolution;
    var multisample = filters[0].multisample;
    var padding = filters[0].padding;
    var autoFit = filters[0].autoFit;
    var legacy = (_a2 = filters[0].legacy) !== null && _a2 !== void 0 ? _a2 : true;
    for (var i = 1; i < filters.length; i++) {
      var filter = filters[i];
      resolution = Math.min(resolution, filter.resolution);
      multisample = Math.min(multisample, filter.multisample);
      padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
      autoFit = autoFit && filter.autoFit;
      legacy = legacy || ((_b2 = filter.legacy) !== null && _b2 !== void 0 ? _b2 : true);
    }
    if (filterStack.length === 1) {
      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
    }
    filterStack.push(state);
    state.resolution = resolution;
    state.multisample = multisample;
    state.legacy = legacy;
    state.target = target;
    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
    state.sourceFrame.pad(padding);
    var sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
    if (renderer2.projection.transform) {
      this.transformAABB(tempMatrix$2.copyFrom(renderer2.projection.transform).invert(), sourceFrameProjected);
    }
    if (autoFit) {
      state.sourceFrame.fit(sourceFrameProjected);
      if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
        state.sourceFrame.width = 0;
        state.sourceFrame.height = 0;
      }
    } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
      state.sourceFrame.width = 0;
      state.sourceFrame.height = 0;
    }
    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer2.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer2.projection.transform);
    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
    state.filters = filters;
    state.destinationFrame.width = state.renderTexture.width;
    state.destinationFrame.height = state.renderTexture.height;
    var destinationFrame = this.tempRect;
    destinationFrame.x = 0;
    destinationFrame.y = 0;
    destinationFrame.width = state.sourceFrame.width;
    destinationFrame.height = state.sourceFrame.height;
    state.renderTexture.filterFrame = state.sourceFrame;
    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
    state.transform = renderer2.projection.transform;
    renderer2.projection.transform = null;
    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
    renderer2.framebuffer.clear(0, 0, 0, 0);
  };
  FilterSystem2.prototype.pop = function() {
    var filterStack = this.defaultFilterStack;
    var state = filterStack.pop();
    var filters = state.filters;
    this.activeState = state;
    var globalUniforms = this.globalUniforms.uniforms;
    globalUniforms.outputFrame = state.sourceFrame;
    globalUniforms.resolution = state.resolution;
    var inputSize = globalUniforms.inputSize;
    var inputPixel = globalUniforms.inputPixel;
    var inputClamp = globalUniforms.inputClamp;
    inputSize[0] = state.destinationFrame.width;
    inputSize[1] = state.destinationFrame.height;
    inputSize[2] = 1 / inputSize[0];
    inputSize[3] = 1 / inputSize[1];
    inputPixel[0] = Math.round(inputSize[0] * state.resolution);
    inputPixel[1] = Math.round(inputSize[1] * state.resolution);
    inputPixel[2] = 1 / inputPixel[0];
    inputPixel[3] = 1 / inputPixel[1];
    inputClamp[0] = 0.5 * inputPixel[2];
    inputClamp[1] = 0.5 * inputPixel[3];
    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
    if (state.legacy) {
      var filterArea = globalUniforms.filterArea;
      filterArea[0] = state.destinationFrame.width;
      filterArea[1] = state.destinationFrame.height;
      filterArea[2] = state.sourceFrame.x;
      filterArea[3] = state.sourceFrame.y;
      globalUniforms.filterClamp = globalUniforms.inputClamp;
    }
    this.globalUniforms.update();
    var lastState = filterStack[filterStack.length - 1];
    this.renderer.framebuffer.blit();
    if (filters.length === 1) {
      filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);
      this.returnFilterTexture(state.renderTexture);
    } else {
      var flip = state.renderTexture;
      var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
      flop.filterFrame = flip.filterFrame;
      var i = 0;
      for (i = 0; i < filters.length - 1; ++i) {
        if (i === 1 && state.multisample > 1) {
          flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
        }
        filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);
        var t2 = flip;
        flip = flop;
        flop = t2;
      }
      filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);
      if (i > 1 && state.multisample > 1) {
        this.returnFilterTexture(state.renderTexture);
      }
      this.returnFilterTexture(flip);
      this.returnFilterTexture(flop);
    }
    state.clear();
    this.statePool.push(state);
  };
  FilterSystem2.prototype.bindAndClear = function(filterTexture, clearMode) {
    if (clearMode === void 0) {
      clearMode = CLEAR_MODES.CLEAR;
    }
    var _a2 = this.renderer, renderTextureSystem = _a2.renderTexture, stateSystem = _a2.state;
    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      this.renderer.projection.transform = this.activeState.transform;
    } else {
      this.renderer.projection.transform = null;
    }
    if (filterTexture && filterTexture.filterFrame) {
      var destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = filterTexture.filterFrame.width;
      destinationFrame.height = filterTexture.filterFrame.height;
      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      renderTextureSystem.bind(filterTexture);
    } else {
      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
    }
    var autoClear = stateSystem.stateId & 1 || this.forceClear;
    if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) {
      this.renderer.framebuffer.clear(0, 0, 0, 0);
    }
  };
  FilterSystem2.prototype.applyFilter = function(filter, input, output, clearMode) {
    var renderer2 = this.renderer;
    renderer2.state.set(filter.state);
    this.bindAndClear(output, clearMode);
    filter.uniforms.uSampler = input;
    filter.uniforms.filterGlobals = this.globalUniforms;
    renderer2.shader.bind(filter);
    filter.legacy = !!filter.program.attributeData.aTextureCoord;
    if (filter.legacy) {
      this.quadUv.map(input._frame, input.filterFrame);
      renderer2.geometry.bind(this.quadUv);
      renderer2.geometry.draw(DRAW_MODES.TRIANGLES);
    } else {
      renderer2.geometry.bind(this.quad);
      renderer2.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);
    }
  };
  FilterSystem2.prototype.calculateSpriteMatrix = function(outputMatrix, sprite) {
    var _a2 = this.activeState, sourceFrame = _a2.sourceFrame, destinationFrame = _a2.destinationFrame;
    var orig = sprite._texture.orig;
    var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
    var worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(1 / orig.width, 1 / orig.height);
    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
    return mappedMatrix;
  };
  FilterSystem2.prototype.destroy = function() {
    this.renderer = null;
    this.texturePool.clear(false);
  };
  FilterSystem2.prototype.getOptimalFilterTexture = function(minWidth, minHeight, resolution, multisample) {
    if (resolution === void 0) {
      resolution = 1;
    }
    if (multisample === void 0) {
      multisample = MSAA_QUALITY.NONE;
    }
    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
  };
  FilterSystem2.prototype.getFilterTexture = function(input, resolution, multisample) {
    if (typeof input === "number") {
      var swap = input;
      input = resolution;
      resolution = swap;
    }
    input = input || this.activeState.renderTexture;
    var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  };
  FilterSystem2.prototype.returnFilterTexture = function(renderTexture) {
    this.texturePool.returnTexture(renderTexture);
  };
  FilterSystem2.prototype.emptyPool = function() {
    this.texturePool.clear(true);
  };
  FilterSystem2.prototype.resize = function() {
    this.texturePool.setScreenSize(this.renderer.view);
  };
  FilterSystem2.prototype.transformAABB = function(matrix, rect) {
    var lt = tempPoints[0];
    var lb = tempPoints[1];
    var rt = tempPoints[2];
    var rb = tempPoints[3];
    lt.set(rect.left, rect.top);
    lb.set(rect.left, rect.bottom);
    rt.set(rect.right, rect.top);
    rb.set(rect.right, rect.bottom);
    matrix.apply(lt, lt);
    matrix.apply(lb, lb);
    matrix.apply(rt, rt);
    matrix.apply(rb, rb);
    var x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
    var y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
    var x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
    var y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
    rect.x = x0;
    rect.y = y0;
    rect.width = x1 - x0;
    rect.height = y1 - y0;
  };
  FilterSystem2.prototype.roundFrame = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
      return;
    }
    if (transform) {
      var a2 = transform.a, b2 = transform.b, c = transform.c, d2 = transform.d;
      if ((Math.abs(b2) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d2) > 1e-4)) {
        return;
      }
    }
    transform = transform ? tempMatrix$2.copyFrom(transform) : tempMatrix$2.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.transformAABB(transform, frame);
    frame.ceil(resolution);
    this.transformAABB(transform.invert(), frame);
  };
  return FilterSystem2;
}();
var ObjectRenderer = function() {
  function ObjectRenderer2(renderer2) {
    this.renderer = renderer2;
  }
  ObjectRenderer2.prototype.flush = function() {
  };
  ObjectRenderer2.prototype.destroy = function() {
    this.renderer = null;
  };
  ObjectRenderer2.prototype.start = function() {
  };
  ObjectRenderer2.prototype.stop = function() {
    this.flush();
  };
  ObjectRenderer2.prototype.render = function(_object) {
  };
  return ObjectRenderer2;
}();
var BatchSystem = function() {
  function BatchSystem2(renderer2) {
    this.renderer = renderer2;
    this.emptyRenderer = new ObjectRenderer(renderer2);
    this.currentRenderer = this.emptyRenderer;
  }
  BatchSystem2.prototype.setObjectRenderer = function(objectRenderer) {
    if (this.currentRenderer === objectRenderer) {
      return;
    }
    this.currentRenderer.stop();
    this.currentRenderer = objectRenderer;
    this.currentRenderer.start();
  };
  BatchSystem2.prototype.flush = function() {
    this.setObjectRenderer(this.emptyRenderer);
  };
  BatchSystem2.prototype.reset = function() {
    this.setObjectRenderer(this.emptyRenderer);
  };
  BatchSystem2.prototype.copyBoundTextures = function(arr, maxTextures) {
    var boundTextures = this.renderer.texture.boundTextures;
    for (var i = maxTextures - 1; i >= 0; --i) {
      arr[i] = boundTextures[i] || null;
      if (arr[i]) {
        arr[i]._batchLocation = i;
      }
    }
  };
  BatchSystem2.prototype.boundArray = function(texArray, boundTextures, batchId, maxTextures) {
    var elements = texArray.elements, ids = texArray.ids, count = texArray.count;
    var j2 = 0;
    for (var i = 0; i < count; i++) {
      var tex = elements[i];
      var loc = tex._batchLocation;
      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
        ids[i] = loc;
        continue;
      }
      while (j2 < maxTextures) {
        var bound2 = boundTextures[j2];
        if (bound2 && bound2._batchEnabled === batchId && bound2._batchLocation === j2) {
          j2++;
          continue;
        }
        ids[i] = j2;
        tex._batchLocation = j2;
        boundTextures[j2] = tex;
        break;
      }
    }
  };
  BatchSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return BatchSystem2;
}();
var CONTEXT_UID_COUNTER = 0;
var ContextSystem = function() {
  function ContextSystem2(renderer2) {
    this.renderer = renderer2;
    this.webGLVersion = 1;
    this.extensions = {};
    this.supports = {
      uint32Indices: false
    };
    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);
    renderer2.view.addEventListener("webglcontextlost", this.handleContextLost, false);
    renderer2.view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
  }
  Object.defineProperty(ContextSystem2.prototype, "isLost", {
    get: function() {
      return !this.gl || this.gl.isContextLost();
    },
    enumerable: false,
    configurable: true
  });
  ContextSystem2.prototype.contextChange = function(gl) {
    this.gl = gl;
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
  };
  ContextSystem2.prototype.initFromContext = function(gl) {
    this.gl = gl;
    this.validateContext(gl);
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    this.renderer.runners.contextChange.emit(gl);
  };
  ContextSystem2.prototype.initFromOptions = function(options) {
    var gl = this.createContext(this.renderer.view, options);
    this.initFromContext(gl);
  };
  ContextSystem2.prototype.createContext = function(canvas, options) {
    var gl;
    if (settings.PREFER_ENV >= ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", options);
    }
    if (gl) {
      this.webGLVersion = 2;
    } else {
      this.webGLVersion = 1;
      gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
      if (!gl) {
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      }
    }
    this.gl = gl;
    this.getExtensions();
    return this.gl;
  };
  ContextSystem2.prototype.getExtensions = function() {
    var gl = this.gl;
    var common = {
      loseContext: gl.getExtension("WEBGL_lose_context"),
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    if (this.webGLVersion === 1) {
      Object.assign(this.extensions, common, {
        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
        depthTexture: gl.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
        floatTexture: gl.getExtension("OES_texture_float"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        textureHalfFloat: gl.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
      });
    } else if (this.webGLVersion === 2) {
      Object.assign(this.extensions, common, {
        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
      });
    }
  };
  ContextSystem2.prototype.handleContextLost = function(event) {
    var _this = this;
    event.preventDefault();
    setTimeout(function() {
      if (_this.gl.isContextLost() && _this.extensions.loseContext) {
        _this.extensions.loseContext.restoreContext();
      }
    }, 0);
  };
  ContextSystem2.prototype.handleContextRestored = function() {
    this.renderer.runners.contextChange.emit(this.gl);
  };
  ContextSystem2.prototype.destroy = function() {
    var view = this.renderer.view;
    this.renderer = null;
    view.removeEventListener("webglcontextlost", this.handleContextLost);
    view.removeEventListener("webglcontextrestored", this.handleContextRestored);
    this.gl.useProgram(null);
    if (this.extensions.loseContext) {
      this.extensions.loseContext.loseContext();
    }
  };
  ContextSystem2.prototype.postrender = function() {
    if (this.renderer.renderingToScreen) {
      this.gl.flush();
    }
  };
  ContextSystem2.prototype.validateContext = function(gl) {
    var attributes = gl.getContextAttributes();
    var isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
    if (isWebGl2) {
      this.webGLVersion = 2;
    }
    if (attributes && !attributes.stencil) {
      console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    }
    var hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = hasuint32;
    if (!hasuint32) {
      console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }
  };
  return ContextSystem2;
}();
var GLFramebuffer = function() {
  function GLFramebuffer2(framebuffer) {
    this.framebuffer = framebuffer;
    this.stencil = null;
    this.dirtyId = -1;
    this.dirtyFormat = -1;
    this.dirtySize = -1;
    this.multisample = MSAA_QUALITY.NONE;
    this.msaaBuffer = null;
    this.blitFramebuffer = null;
    this.mipLevel = 0;
  }
  return GLFramebuffer2;
}();
var tempRectangle = new Rectangle();
var FramebufferSystem = function() {
  function FramebufferSystem2(renderer2) {
    this.renderer = renderer2;
    this.managedFramebuffers = [];
    this.unknownFramebuffer = new Framebuffer(10, 10);
    this.msaaSamples = null;
  }
  FramebufferSystem2.prototype.contextChange = function() {
    this.disposeAll(true);
    var gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle();
    this.hasMRT = true;
    this.writeDepthTexture = true;
    if (this.renderer.context.webGLVersion === 1) {
      var nativeDrawBuffersExtension_1 = this.renderer.context.extensions.drawBuffers;
      var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        nativeDrawBuffersExtension_1 = null;
        nativeDepthTextureExtension = null;
      }
      if (nativeDrawBuffersExtension_1) {
        gl.drawBuffers = function(activeTextures) {
          return nativeDrawBuffersExtension_1.drawBuffersWEBGL(activeTextures);
        };
      } else {
        this.hasMRT = false;
        gl.drawBuffers = function() {
        };
      }
      if (!nativeDepthTextureExtension) {
        this.writeDepthTexture = false;
      }
    } else {
      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
    }
  };
  FramebufferSystem2.prototype.bind = function(framebuffer, frame, mipLevel) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    var gl = this.gl;
    if (framebuffer) {
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
      if (this.current !== framebuffer) {
        this.current = framebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
      }
      if (fbo.mipLevel !== mipLevel) {
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
        fbo.mipLevel = mipLevel;
      }
      if (fbo.dirtyId !== framebuffer.dirtyId) {
        fbo.dirtyId = framebuffer.dirtyId;
        if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
          fbo.dirtyFormat = framebuffer.dirtyFormat;
          fbo.dirtySize = framebuffer.dirtySize;
          this.updateFramebuffer(framebuffer, mipLevel);
        } else if (fbo.dirtySize !== framebuffer.dirtySize) {
          fbo.dirtySize = framebuffer.dirtySize;
          this.resizeFramebuffer(framebuffer);
        }
      }
      for (var i = 0; i < framebuffer.colorTextures.length; i++) {
        var tex = framebuffer.colorTextures[i];
        this.renderer.texture.unbind(tex.parentTextureArray || tex);
      }
      if (framebuffer.depthTexture) {
        this.renderer.texture.unbind(framebuffer.depthTexture);
      }
      if (frame) {
        var mipWidth = frame.width >> mipLevel;
        var mipHeight = frame.height >> mipLevel;
        var scale = mipWidth / frame.width;
        this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);
      } else {
        var mipWidth = framebuffer.width >> mipLevel;
        var mipHeight = framebuffer.height >> mipLevel;
        this.setViewport(0, 0, mipWidth, mipHeight);
      }
    } else {
      if (this.current) {
        this.current = null;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      if (frame) {
        this.setViewport(frame.x, frame.y, frame.width, frame.height);
      } else {
        this.setViewport(0, 0, this.renderer.width, this.renderer.height);
      }
    }
  };
  FramebufferSystem2.prototype.setViewport = function(x2, y2, width, height) {
    var v2 = this.viewport;
    x2 = Math.round(x2);
    y2 = Math.round(y2);
    width = Math.round(width);
    height = Math.round(height);
    if (v2.width !== width || v2.height !== height || v2.x !== x2 || v2.y !== y2) {
      v2.x = x2;
      v2.y = y2;
      v2.width = width;
      v2.height = height;
      this.gl.viewport(x2, y2, width, height);
    }
  };
  Object.defineProperty(FramebufferSystem2.prototype, "size", {
    get: function() {
      if (this.current) {
        return { x: 0, y: 0, width: this.current.width, height: this.current.height };
      }
      return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    },
    enumerable: false,
    configurable: true
  });
  FramebufferSystem2.prototype.clear = function(r2, g2, b2, a2, mask) {
    if (mask === void 0) {
      mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH;
    }
    var gl = this.gl;
    gl.clearColor(r2, g2, b2, a2);
    gl.clear(mask);
  };
  FramebufferSystem2.prototype.initFramebuffer = function(framebuffer) {
    var gl = this.gl;
    var fbo = new GLFramebuffer(gl.createFramebuffer());
    fbo.multisample = this.detectSamples(framebuffer.multisample);
    framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
    this.managedFramebuffers.push(framebuffer);
    framebuffer.disposeRunner.add(this);
    return fbo;
  };
  FramebufferSystem2.prototype.resizeFramebuffer = function(framebuffer) {
    var gl = this.gl;
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (fbo.msaaBuffer) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
    }
    if (fbo.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
    }
    var colorTextures = framebuffer.colorTextures;
    var count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    for (var i = 0; i < count; i++) {
      var texture = colorTextures[i];
      var parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
    }
    if (framebuffer.depthTexture && this.writeDepthTexture) {
      this.renderer.texture.bind(framebuffer.depthTexture, 0);
    }
  };
  FramebufferSystem2.prototype.updateFramebuffer = function(framebuffer, mipLevel) {
    var gl = this.gl;
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    var colorTextures = framebuffer.colorTextures;
    var count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
      fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
    } else if (fbo.msaaBuffer) {
      gl.deleteRenderbuffer(fbo.msaaBuffer);
      fbo.msaaBuffer = null;
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
        fbo.blitFramebuffer = null;
      }
    }
    var activeTextures = [];
    for (var i = 0; i < count; i++) {
      var texture = colorTextures[i];
      var parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i === 0 && fbo.msaaBuffer) {
        continue;
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
    }
    if (activeTextures.length > 1) {
      gl.drawBuffers(activeTextures);
    }
    if (framebuffer.depthTexture) {
      var writeDepthTexture = this.writeDepthTexture;
      if (writeDepthTexture) {
        var depthTexture = framebuffer.depthTexture;
        this.renderer.texture.bind(depthTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      }
    }
    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
      fbo.stencil = fbo.stencil || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
    } else if (fbo.stencil) {
      gl.deleteRenderbuffer(fbo.stencil);
      fbo.stencil = null;
    }
  };
  FramebufferSystem2.prototype.canMultisampleFramebuffer = function(framebuffer) {
    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
  };
  FramebufferSystem2.prototype.detectSamples = function(samples) {
    var msaaSamples = this.msaaSamples;
    var res = MSAA_QUALITY.NONE;
    if (samples <= 1 || msaaSamples === null) {
      return res;
    }
    for (var i = 0; i < msaaSamples.length; i++) {
      if (msaaSamples[i] <= samples) {
        res = msaaSamples[i];
        break;
      }
    }
    if (res === 1) {
      res = MSAA_QUALITY.NONE;
    }
    return res;
  };
  FramebufferSystem2.prototype.blit = function(framebuffer, sourcePixels, destPixels) {
    var _a2 = this, current2 = _a2.current, renderer2 = _a2.renderer, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
    if (renderer2.context.webGLVersion !== 2) {
      return;
    }
    if (!current2) {
      return;
    }
    var fbo = current2.glFramebuffers[CONTEXT_UID];
    if (!fbo) {
      return;
    }
    if (!framebuffer) {
      if (!fbo.msaaBuffer) {
        return;
      }
      var colorTexture = current2.colorTextures[0];
      if (!colorTexture) {
        return;
      }
      if (!fbo.blitFramebuffer) {
        fbo.blitFramebuffer = new Framebuffer(current2.width, current2.height);
        fbo.blitFramebuffer.addColorTexture(0, colorTexture);
      }
      framebuffer = fbo.blitFramebuffer;
      if (framebuffer.colorTextures[0] !== colorTexture) {
        framebuffer.colorTextures[0] = colorTexture;
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
      }
      if (framebuffer.width !== current2.width || framebuffer.height !== current2.height) {
        framebuffer.width = current2.width;
        framebuffer.height = current2.height;
        framebuffer.dirtyId++;
        framebuffer.dirtySize++;
      }
    }
    if (!sourcePixels) {
      sourcePixels = tempRectangle;
      sourcePixels.width = current2.width;
      sourcePixels.height = current2.height;
    }
    if (!destPixels) {
      destPixels = sourcePixels;
    }
    var sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
    this.bind(framebuffer);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
    gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
  };
  FramebufferSystem2.prototype.disposeFramebuffer = function(framebuffer, contextLost) {
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    var gl = this.gl;
    if (!fbo) {
      return;
    }
    delete framebuffer.glFramebuffers[this.CONTEXT_UID];
    var index = this.managedFramebuffers.indexOf(framebuffer);
    if (index >= 0) {
      this.managedFramebuffers.splice(index, 1);
    }
    framebuffer.disposeRunner.remove(this);
    if (!contextLost) {
      gl.deleteFramebuffer(fbo.framebuffer);
      if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
      }
      if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
      }
    }
    if (fbo.blitFramebuffer) {
      fbo.blitFramebuffer.dispose();
    }
  };
  FramebufferSystem2.prototype.disposeAll = function(contextLost) {
    var list = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (var i = 0; i < list.length; i++) {
      this.disposeFramebuffer(list[i], contextLost);
    }
  };
  FramebufferSystem2.prototype.forceStencil = function() {
    var framebuffer = this.current;
    if (!framebuffer) {
      return;
    }
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (!fbo || fbo.stencil) {
      return;
    }
    framebuffer.stencil = true;
    var w2 = framebuffer.width;
    var h2 = framebuffer.height;
    var gl = this.gl;
    var stencil = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
    if (fbo.msaaBuffer) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w2, h2);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w2, h2);
    }
    fbo.stencil = stencil;
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
  };
  FramebufferSystem2.prototype.reset = function() {
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle();
  };
  FramebufferSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return FramebufferSystem2;
}();
var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
var GeometrySystem = function() {
  function GeometrySystem2(renderer2) {
    this.renderer = renderer2;
    this._activeGeometry = null;
    this._activeVao = null;
    this.hasVao = true;
    this.hasInstance = true;
    this.canUseUInt32ElementIndex = false;
    this.managedGeometries = {};
  }
  GeometrySystem2.prototype.contextChange = function() {
    this.disposeAll(true);
    var gl = this.gl = this.renderer.gl;
    var context2 = this.renderer.context;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    if (context2.webGLVersion !== 2) {
      var nativeVaoExtension_1 = this.renderer.context.extensions.vertexArrayObject;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        nativeVaoExtension_1 = null;
      }
      if (nativeVaoExtension_1) {
        gl.createVertexArray = function() {
          return nativeVaoExtension_1.createVertexArrayOES();
        };
        gl.bindVertexArray = function(vao) {
          return nativeVaoExtension_1.bindVertexArrayOES(vao);
        };
        gl.deleteVertexArray = function(vao) {
          return nativeVaoExtension_1.deleteVertexArrayOES(vao);
        };
      } else {
        this.hasVao = false;
        gl.createVertexArray = function() {
          return null;
        };
        gl.bindVertexArray = function() {
          return null;
        };
        gl.deleteVertexArray = function() {
          return null;
        };
      }
    }
    if (context2.webGLVersion !== 2) {
      var instanceExt_1 = gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExt_1) {
        gl.vertexAttribDivisor = function(a2, b2) {
          return instanceExt_1.vertexAttribDivisorANGLE(a2, b2);
        };
        gl.drawElementsInstanced = function(a2, b2, c, d2, e2) {
          return instanceExt_1.drawElementsInstancedANGLE(a2, b2, c, d2, e2);
        };
        gl.drawArraysInstanced = function(a2, b2, c, d2) {
          return instanceExt_1.drawArraysInstancedANGLE(a2, b2, c, d2);
        };
      } else {
        this.hasInstance = false;
      }
    }
    this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
  };
  GeometrySystem2.prototype.bind = function(geometry, shader) {
    shader = shader || this.renderer.shader.shader;
    var gl = this.gl;
    var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    var incRefCount = false;
    if (!vaos) {
      this.managedGeometries[geometry.id] = geometry;
      geometry.disposeRunner.add(this);
      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
      incRefCount = true;
    }
    var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
    this._activeGeometry = geometry;
    if (this._activeVao !== vao) {
      this._activeVao = vao;
      if (this.hasVao) {
        gl.bindVertexArray(vao);
      } else {
        this.activateVao(geometry, shader.program);
      }
    }
    this.updateBuffers();
  };
  GeometrySystem2.prototype.reset = function() {
    this.unbind();
  };
  GeometrySystem2.prototype.updateBuffers = function() {
    var geometry = this._activeGeometry;
    var bufferSystem = this.renderer.buffer;
    for (var i = 0; i < geometry.buffers.length; i++) {
      var buffer = geometry.buffers[i];
      bufferSystem.update(buffer);
    }
  };
  GeometrySystem2.prototype.checkCompatibility = function(geometry, program) {
    var geometryAttributes = geometry.attributes;
    var shaderAttributes = program.attributeData;
    for (var j2 in shaderAttributes) {
      if (!geometryAttributes[j2]) {
        throw new Error('shader and geometry incompatible, geometry missing the "' + j2 + '" attribute');
      }
    }
  };
  GeometrySystem2.prototype.getSignature = function(geometry, program) {
    var attribs = geometry.attributes;
    var shaderAttributes = program.attributeData;
    var strings = ["g", geometry.id];
    for (var i in attribs) {
      if (shaderAttributes[i]) {
        strings.push(i, shaderAttributes[i].location);
      }
    }
    return strings.join("-");
  };
  GeometrySystem2.prototype.initGeometryVao = function(geometry, shader, incRefCount) {
    if (incRefCount === void 0) {
      incRefCount = true;
    }
    var gl = this.gl;
    var CONTEXT_UID = this.CONTEXT_UID;
    var bufferSystem = this.renderer.buffer;
    var program = shader.program;
    if (!program.glPrograms[CONTEXT_UID]) {
      this.renderer.shader.generateProgram(shader);
    }
    this.checkCompatibility(geometry, program);
    var signature = this.getSignature(geometry, program);
    var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    var vao = vaoObjectHash[signature];
    if (vao) {
      vaoObjectHash[program.id] = vao;
      return vao;
    }
    var buffers = geometry.buffers;
    var attributes = geometry.attributes;
    var tempStride = {};
    var tempStart = {};
    for (var j2 in buffers) {
      tempStride[j2] = 0;
      tempStart[j2] = 0;
    }
    for (var j2 in attributes) {
      if (!attributes[j2].size && program.attributeData[j2]) {
        attributes[j2].size = program.attributeData[j2].size;
      } else if (!attributes[j2].size) {
        console.warn("PIXI Geometry attribute '" + j2 + "' size cannot be determined (likely the bound shader does not have the attribute)");
      }
      tempStride[attributes[j2].buffer] += attributes[j2].size * byteSizeMap[attributes[j2].type];
    }
    for (var j2 in attributes) {
      var attribute = attributes[j2];
      var attribSize = attribute.size;
      if (attribute.stride === void 0) {
        if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {
          attribute.stride = 0;
        } else {
          attribute.stride = tempStride[attribute.buffer];
        }
      }
      if (attribute.start === void 0) {
        attribute.start = tempStart[attribute.buffer];
        tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];
      }
    }
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    for (var i = 0; i < buffers.length; i++) {
      var buffer = buffers[i];
      bufferSystem.bind(buffer);
      if (incRefCount) {
        buffer._glBuffers[CONTEXT_UID].refCount++;
      }
    }
    this.activateVao(geometry, program);
    this._activeVao = vao;
    vaoObjectHash[program.id] = vao;
    vaoObjectHash[signature] = vao;
    return vao;
  };
  GeometrySystem2.prototype.disposeGeometry = function(geometry, contextLost) {
    var _a2;
    if (!this.managedGeometries[geometry.id]) {
      return;
    }
    delete this.managedGeometries[geometry.id];
    var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    var gl = this.gl;
    var buffers = geometry.buffers;
    var bufferSystem = (_a2 = this.renderer) === null || _a2 === void 0 ? void 0 : _a2.buffer;
    geometry.disposeRunner.remove(this);
    if (!vaos) {
      return;
    }
    if (bufferSystem) {
      for (var i = 0; i < buffers.length; i++) {
        var buf = buffers[i]._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffers[i], contextLost);
          }
        }
      }
    }
    if (!contextLost) {
      for (var vaoId in vaos) {
        if (vaoId[0] === "g") {
          var vao = vaos[vaoId];
          if (this._activeVao === vao) {
            this.unbind();
          }
          gl.deleteVertexArray(vao);
        }
      }
    }
    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
  };
  GeometrySystem2.prototype.disposeAll = function(contextLost) {
    var all2 = Object.keys(this.managedGeometries);
    for (var i = 0; i < all2.length; i++) {
      this.disposeGeometry(this.managedGeometries[all2[i]], contextLost);
    }
  };
  GeometrySystem2.prototype.activateVao = function(geometry, program) {
    var gl = this.gl;
    var CONTEXT_UID = this.CONTEXT_UID;
    var bufferSystem = this.renderer.buffer;
    var buffers = geometry.buffers;
    var attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      bufferSystem.bind(geometry.indexBuffer);
    }
    var lastBuffer = null;
    for (var j2 in attributes) {
      var attribute = attributes[j2];
      var buffer = buffers[attribute.buffer];
      var glBuffer = buffer._glBuffers[CONTEXT_UID];
      if (program.attributeData[j2]) {
        if (lastBuffer !== glBuffer) {
          bufferSystem.bind(buffer);
          lastBuffer = glBuffer;
        }
        var location = program.attributeData[j2].location;
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
        if (attribute.instance) {
          if (this.hasInstance) {
            gl.vertexAttribDivisor(location, 1);
          } else {
            throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
  };
  GeometrySystem2.prototype.draw = function(type2, size, start, instanceCount) {
    var gl = this.gl;
    var geometry = this._activeGeometry;
    if (geometry.indexBuffer) {
      var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
        if (geometry.instanced) {
          gl.drawElementsInstanced(type2, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
        } else {
          gl.drawElements(type2, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
        }
      } else {
        console.warn("unsupported index buffer type: uint32");
      }
    } else if (geometry.instanced) {
      gl.drawArraysInstanced(type2, start, size || geometry.getSize(), instanceCount || 1);
    } else {
      gl.drawArrays(type2, start, size || geometry.getSize());
    }
    return this;
  };
  GeometrySystem2.prototype.unbind = function() {
    this.gl.bindVertexArray(null);
    this._activeVao = null;
    this._activeGeometry = null;
  };
  GeometrySystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return GeometrySystem2;
}();
var MaskData = function() {
  function MaskData2(maskObject) {
    if (maskObject === void 0) {
      maskObject = null;
    }
    this.type = MASK_TYPES.NONE;
    this.autoDetect = true;
    this.maskObject = maskObject || null;
    this.pooled = false;
    this.isMaskData = true;
    this.resolution = null;
    this.multisample = settings.FILTER_MULTISAMPLE;
    this.enabled = true;
    this.colorMask = 15;
    this._filters = null;
    this._stencilCounter = 0;
    this._scissorCounter = 0;
    this._scissorRect = null;
    this._scissorRectLocal = null;
    this._colorMask = 15;
    this._target = null;
  }
  Object.defineProperty(MaskData2.prototype, "filter", {
    get: function() {
      return this._filters ? this._filters[0] : null;
    },
    set: function(value) {
      if (value) {
        if (this._filters) {
          this._filters[0] = value;
        } else {
          this._filters = [value];
        }
      } else {
        this._filters = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  MaskData2.prototype.reset = function() {
    if (this.pooled) {
      this.maskObject = null;
      this.type = MASK_TYPES.NONE;
      this.autoDetect = true;
    }
    this._target = null;
    this._scissorRectLocal = null;
  };
  MaskData2.prototype.copyCountersOrReset = function(maskAbove) {
    if (maskAbove) {
      this._stencilCounter = maskAbove._stencilCounter;
      this._scissorCounter = maskAbove._scissorCounter;
      this._scissorRect = maskAbove._scissorRect;
    } else {
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
    }
  };
  return MaskData2;
}();
function compileShader(gl, type2, src) {
  var shader = gl.createShader(type2);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
function logPrettyShaderError(gl, shader) {
  var shaderSrc = gl.getShaderSource(shader).split("\n").map(function(line, index) {
    return index + ": " + line;
  });
  var shaderLog = gl.getShaderInfoLog(shader);
  var splitShader = shaderLog.split("\n");
  var dedupe = {};
  var lineNumbers = splitShader.map(function(line) {
    return parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function(n2) {
    if (n2 && !dedupe[n2]) {
      dedupe[n2] = true;
      return true;
    }
    return false;
  });
  var logArgs = [""];
  lineNumbers.forEach(function(number) {
    shaderSrc[number - 1] = "%c" + shaderSrc[number - 1] + "%c";
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn.apply(console, logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
function booleanArray(size) {
  var array = new Array(size);
  for (var i = 0; i < array.length; i++) {
    array[i] = false;
  }
  return array;
}
function defaultValue(type2, size) {
  switch (type2) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var unknownContext = {};
var context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context && context.isContextLost()) {
    var canvas = settings.ADAPTER.createCanvas();
    var gl = void 0;
    if (settings.PREFER_ENV >= ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context = gl;
  }
  return context;
}
var maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION.MEDIUM;
    var gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision;
}
function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    var precision = requestedPrecision;
    if (requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH) {
      precision = PRECISION.MEDIUM;
    }
    return "precision " + precision + " float;\n" + src;
  } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type2) {
  return GLSL_TO_SIZE[type2];
}
var GL_TABLE = null;
var GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl, type2) {
  if (!GL_TABLE) {
    var typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (var i = 0; i < typeNames.length; ++i) {
      var tn = typeNames[i];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type2];
}
var uniformParsers = [
  {
    test: function(data) {
      return data.type === "float" && data.size === 1 && !data.isArray;
    },
    code: function(name) {
      return '\n            if(uv["' + name + '"] !== ud["' + name + '"].value)\n            {\n                ud["' + name + '"].value = uv["' + name + '"]\n                gl.uniform1f(ud["' + name + '"].location, uv["' + name + '"])\n            }\n            ';
    }
  },
  {
    test: function(data, uniform) {
      return (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0);
    },
    code: function(name) {
      return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + name + '"], t);\n\n            if(ud["' + name + '"].value !== t)\n            {\n                ud["' + name + '"].value = t;\n                gl.uniform1i(ud["' + name + '"].location, t);\n; // eslint-disable-line max-len\n            }';
    }
  },
  {
    test: function(data, uniform) {
      return data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0;
    },
    code: function(name) {
      return '\n            gl.uniformMatrix3fv(ud["' + name + '"].location, false, uv["' + name + '"].toArray(true));\n            ';
    },
    codeUbo: function(name) {
      return "\n                var " + name + "_matrix = uv." + name + ".toArray(true);\n\n                data[offset] = " + name + "_matrix[0];\n                data[offset+1] = " + name + "_matrix[1];\n                data[offset+2] = " + name + "_matrix[2];\n        \n                data[offset + 4] = " + name + "_matrix[3];\n                data[offset + 5] = " + name + "_matrix[4];\n                data[offset + 6] = " + name + "_matrix[5];\n        \n                data[offset + 8] = " + name + "_matrix[6];\n                data[offset + 9] = " + name + "_matrix[7];\n                data[offset + 10] = " + name + "_matrix[8];\n            ";
    }
  },
  {
    test: function(data, uniform) {
      return data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + name + '"].location, v.x, v.y);\n                }';
    },
    codeUbo: function(name) {
      return "\n                v = uv." + name + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            ";
    }
  },
  {
    test: function(data) {
      return data.type === "vec2" && data.size === 1 && !data.isArray;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + name + '"].location, v[0], v[1]);\n                }\n            ';
    }
  },
  {
    test: function(data, uniform) {
      return data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + name + '"].location, v.x, v.y, v.width, v.height)\n                }';
    },
    codeUbo: function(name) {
      return "\n                    v = uv." + name + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                ";
    }
  },
  {
    test: function(data) {
      return data.type === "vec4" && data.size === 1 && !data.isArray;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + name + '"].location, v[0], v[1], v[2], v[3])\n                }';
    }
  }
];
var GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }",
  vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }",
  vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
  vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }",
  int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
  ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
  ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
  ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
  uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }",
  uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }",
  uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }",
  uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }",
  bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }",
  bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
  bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
  bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
  samplerCube: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
  sampler2DArray: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }"
};
var GLSL_TO_ARRAY_SETTERS = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group, uniformData) {
  var _a2;
  var funcFragments = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
  for (var i in group.uniforms) {
    var data = uniformData[i];
    if (!data) {
      if ((_a2 = group.uniforms[i]) === null || _a2 === void 0 ? void 0 : _a2.group) {
        if (group.uniforms[i].ubo) {
          funcFragments.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + i + ", '" + i + "');\n                    ");
        } else {
          funcFragments.push("\n                        renderer.shader.syncUniformGroup(uv." + i + ", syncData);\n                    ");
        }
      }
      continue;
    }
    var uniform = group.uniforms[i];
    var parsed = false;
    for (var j2 = 0; j2 < uniformParsers.length; j2++) {
      if (uniformParsers[j2].test(data, uniform)) {
        funcFragments.push(uniformParsers[j2].code(i, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      var templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      var template = templateType[data.type].replace("location", 'ud["' + i + '"].location');
      funcFragments.push('\n            cu = ud["' + i + '"];\n            cv = cu.value;\n            v = uv["' + i + '"];\n            ' + template + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
var fragTemplate$1 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  var src = "";
  for (var i = 0; i < maxIfs; ++i) {
    if (i > 0) {
      src += "\nelse ";
    }
    if (i < maxIfs - 1) {
      src += "if(test == " + i + ".0){}";
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  var shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    var fragmentSrc = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
}
var unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    var func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e2) {
    unsafeEval = false;
  }
  return unsafeEval;
}
var defaultFragment$2 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
var defaultVertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
var UID$1 = 0;
var nameCache = {};
var Program = function() {
  function Program2(vertexSrc, fragmentSrc, name) {
    if (name === void 0) {
      name = "pixi-shader";
    }
    this.id = UID$1++;
    this.vertexSrc = vertexSrc || Program2.defaultVertexSrc;
    this.fragmentSrc = fragmentSrc || Program2.defaultFragmentSrc;
    this.vertexSrc = this.vertexSrc.trim();
    this.fragmentSrc = this.fragmentSrc.trim();
    if (this.vertexSrc.substring(0, 8) !== "#version") {
      name = name.replace(/\s+/g, "-");
      if (nameCache[name]) {
        nameCache[name]++;
        name += "-" + nameCache[name];
      } else {
        nameCache[name] = 1;
      }
      this.vertexSrc = "#define SHADER_NAME " + name + "\n" + this.vertexSrc;
      this.fragmentSrc = "#define SHADER_NAME " + name + "\n" + this.fragmentSrc;
      this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION.HIGH);
      this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision());
    }
    this.glPrograms = {};
    this.syncUniforms = null;
  }
  Object.defineProperty(Program2, "defaultVertexSrc", {
    get: function() {
      return defaultVertex$3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Program2, "defaultFragmentSrc", {
    get: function() {
      return defaultFragment$2;
    },
    enumerable: false,
    configurable: true
  });
  Program2.from = function(vertexSrc, fragmentSrc, name) {
    var key = vertexSrc + fragmentSrc;
    var program = ProgramCache[key];
    if (!program) {
      ProgramCache[key] = program = new Program2(vertexSrc, fragmentSrc, name);
    }
    return program;
  };
  return Program2;
}();
var Shader = function() {
  function Shader2(program, uniforms) {
    this.uniformBindCount = 0;
    this.program = program;
    if (uniforms) {
      if (uniforms instanceof UniformGroup) {
        this.uniformGroup = uniforms;
      } else {
        this.uniformGroup = new UniformGroup(uniforms);
      }
    } else {
      this.uniformGroup = new UniformGroup({});
    }
    this.disposeRunner = new Runner("disposeShader");
  }
  Shader2.prototype.checkUniformExists = function(name, group) {
    if (group.uniforms[name]) {
      return true;
    }
    for (var i in group.uniforms) {
      var uniform = group.uniforms[i];
      if (uniform.group) {
        if (this.checkUniformExists(name, uniform)) {
          return true;
        }
      }
    }
    return false;
  };
  Shader2.prototype.destroy = function() {
    this.uniformGroup = null;
    this.disposeRunner.emit(this);
    this.disposeRunner.destroy();
  };
  Object.defineProperty(Shader2.prototype, "uniforms", {
    get: function() {
      return this.uniformGroup.uniforms;
    },
    enumerable: false,
    configurable: true
  });
  Shader2.from = function(vertexSrc, fragmentSrc, uniforms) {
    var program = Program.from(vertexSrc, fragmentSrc);
    return new Shader2(program, uniforms);
  };
  return Shader2;
}();
var BLEND$1 = 0;
var OFFSET$1 = 1;
var CULLING$1 = 2;
var DEPTH_TEST$1 = 3;
var WINDING$1 = 4;
var DEPTH_MASK$1 = 5;
var State = function() {
  function State2() {
    this.data = 0;
    this.blendMode = BLEND_MODES.NORMAL;
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  Object.defineProperty(State2.prototype, "blend", {
    get: function() {
      return !!(this.data & 1 << BLEND$1);
    },
    set: function(value) {
      if (!!(this.data & 1 << BLEND$1) !== value) {
        this.data ^= 1 << BLEND$1;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "offsets", {
    get: function() {
      return !!(this.data & 1 << OFFSET$1);
    },
    set: function(value) {
      if (!!(this.data & 1 << OFFSET$1) !== value) {
        this.data ^= 1 << OFFSET$1;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "culling", {
    get: function() {
      return !!(this.data & 1 << CULLING$1);
    },
    set: function(value) {
      if (!!(this.data & 1 << CULLING$1) !== value) {
        this.data ^= 1 << CULLING$1;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "depthTest", {
    get: function() {
      return !!(this.data & 1 << DEPTH_TEST$1);
    },
    set: function(value) {
      if (!!(this.data & 1 << DEPTH_TEST$1) !== value) {
        this.data ^= 1 << DEPTH_TEST$1;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "depthMask", {
    get: function() {
      return !!(this.data & 1 << DEPTH_MASK$1);
    },
    set: function(value) {
      if (!!(this.data & 1 << DEPTH_MASK$1) !== value) {
        this.data ^= 1 << DEPTH_MASK$1;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "clockwiseFrontFace", {
    get: function() {
      return !!(this.data & 1 << WINDING$1);
    },
    set: function(value) {
      if (!!(this.data & 1 << WINDING$1) !== value) {
        this.data ^= 1 << WINDING$1;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "blendMode", {
    get: function() {
      return this._blendMode;
    },
    set: function(value) {
      this.blend = value !== BLEND_MODES.NONE;
      this._blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "polygonOffset", {
    get: function() {
      return this._polygonOffset;
    },
    set: function(value) {
      this.offsets = !!value;
      this._polygonOffset = value;
    },
    enumerable: false,
    configurable: true
  });
  State2.prototype.toString = function() {
    return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
  };
  State2.for2d = function() {
    var state = new State2();
    state.depthTest = false;
    state.blend = true;
    return state;
  };
  return State2;
}();
var defaultFragment$1 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
var defaultVertex$2 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
var Filter = function(_super) {
  __extends$i(Filter2, _super);
  function Filter2(vertexSrc, fragmentSrc, uniforms) {
    var _this = this;
    var program = Program.from(vertexSrc || Filter2.defaultVertexSrc, fragmentSrc || Filter2.defaultFragmentSrc);
    _this = _super.call(this, program, uniforms) || this;
    _this.padding = 0;
    _this.resolution = settings.FILTER_RESOLUTION;
    _this.multisample = settings.FILTER_MULTISAMPLE;
    _this.enabled = true;
    _this.autoFit = true;
    _this.state = new State();
    return _this;
  }
  Filter2.prototype.apply = function(filterManager, input, output, clearMode, _currentState) {
    filterManager.applyFilter(this, input, output, clearMode);
  };
  Object.defineProperty(Filter2.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(value) {
      this.state.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Filter2.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(value) {
      this._resolution = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Filter2, "defaultVertexSrc", {
    get: function() {
      return defaultVertex$2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Filter2, "defaultFragmentSrc", {
    get: function() {
      return defaultFragment$1;
    },
    enumerable: false,
    configurable: true
  });
  return Filter2;
}(Shader);
var vertex$4 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
var fragment$7 = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
var tempMat$1 = new Matrix();
var TextureMatrix = function() {
  function TextureMatrix2(texture, clampMargin) {
    this._texture = texture;
    this.mapCoord = new Matrix();
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
    this.isSimple = false;
  }
  Object.defineProperty(TextureMatrix2.prototype, "texture", {
    get: function() {
      return this._texture;
    },
    set: function(value) {
      this._texture = value;
      this._textureID = -1;
    },
    enumerable: false,
    configurable: true
  });
  TextureMatrix2.prototype.multiplyUvs = function(uvs, out) {
    if (out === void 0) {
      out = uvs;
    }
    var mat = this.mapCoord;
    for (var i = 0; i < uvs.length; i += 2) {
      var x2 = uvs[i];
      var y2 = uvs[i + 1];
      out[i] = x2 * mat.a + y2 * mat.c + mat.tx;
      out[i + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
    }
    return out;
  };
  TextureMatrix2.prototype.update = function(forceUpdate) {
    var tex = this._texture;
    if (!tex || !tex.valid) {
      return false;
    }
    if (!forceUpdate && this._textureID === tex._updateID) {
      return false;
    }
    this._textureID = tex._updateID;
    this._updateID++;
    var uvs = tex._uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    var orig = tex.orig;
    var trim3 = tex.trim;
    if (trim3) {
      tempMat$1.set(orig.width / trim3.width, 0, 0, orig.height / trim3.height, -trim3.x / trim3.width, -trim3.y / trim3.height);
      this.mapCoord.append(tempMat$1);
    }
    var texBase = tex.baseTexture;
    var frame = this.uClampFrame;
    var margin = this.clampMargin / texBase.resolution;
    var offset = this.clampOffset;
    frame[0] = (tex._frame.x + margin + offset) / texBase.width;
    frame[1] = (tex._frame.y + margin + offset) / texBase.height;
    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = offset / texBase.realWidth;
    this.uClampOffset[1] = offset / texBase.realHeight;
    this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
    return true;
  };
  return TextureMatrix2;
}();
var SpriteMaskFilter = function(_super) {
  __extends$i(SpriteMaskFilter2, _super);
  function SpriteMaskFilter2(vertexSrc, fragmentSrc, uniforms) {
    var _this = this;
    var sprite = null;
    if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
      sprite = vertexSrc;
      vertexSrc = void 0;
      fragmentSrc = void 0;
      uniforms = void 0;
    }
    _this = _super.call(this, vertexSrc || vertex$4, fragmentSrc || fragment$7, uniforms) || this;
    _this.maskSprite = sprite;
    _this.maskMatrix = new Matrix();
    return _this;
  }
  Object.defineProperty(SpriteMaskFilter2.prototype, "maskSprite", {
    get: function() {
      return this._maskSprite;
    },
    set: function(value) {
      this._maskSprite = value;
      if (this._maskSprite) {
        this._maskSprite.renderable = false;
      }
    },
    enumerable: false,
    configurable: true
  });
  SpriteMaskFilter2.prototype.apply = function(filterManager, input, output, clearMode) {
    var maskSprite = this._maskSprite;
    var tex = maskSprite._texture;
    if (!tex.valid) {
      return;
    }
    if (!tex.uvMatrix) {
      tex.uvMatrix = new TextureMatrix(tex, 0);
    }
    tex.uvMatrix.update();
    this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
    this.uniforms.mask = tex;
    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
    this.uniforms.alpha = maskSprite.worldAlpha;
    this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
    filterManager.applyFilter(this, input, output, clearMode);
  };
  return SpriteMaskFilter2;
}(Filter);
var MaskSystem = function() {
  function MaskSystem2(renderer2) {
    this.renderer = renderer2;
    this.enableScissor = true;
    this.alphaMaskPool = [];
    this.maskDataPool = [];
    this.maskStack = [];
    this.alphaMaskIndex = 0;
  }
  MaskSystem2.prototype.setMaskStack = function(maskStack) {
    this.maskStack = maskStack;
    this.renderer.scissor.setMaskStack(maskStack);
    this.renderer.stencil.setMaskStack(maskStack);
  };
  MaskSystem2.prototype.push = function(target, maskDataOrTarget) {
    var maskData = maskDataOrTarget;
    if (!maskData.isMaskData) {
      var d2 = this.maskDataPool.pop() || new MaskData();
      d2.pooled = true;
      d2.maskObject = maskDataOrTarget;
      maskData = d2;
    }
    var maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    maskData.copyCountersOrReset(maskAbove);
    maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;
    if (maskData.autoDetect) {
      this.detect(maskData);
    }
    maskData._target = target;
    if (maskData.type !== MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.push(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.push(maskData);
          break;
        case MASK_TYPES.SPRITE:
          maskData.copyCountersOrReset(null);
          this.pushSpriteMask(maskData);
          break;
        case MASK_TYPES.COLOR:
          this.pushColorMask(maskData);
          break;
      }
    }
    if (maskData.type === MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
  };
  MaskSystem2.prototype.pop = function(target) {
    var maskData = this.maskStack.pop();
    if (!maskData || maskData._target !== target) {
      return;
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.pop(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.pop(maskData.maskObject);
          break;
        case MASK_TYPES.SPRITE:
          this.popSpriteMask(maskData);
          break;
        case MASK_TYPES.COLOR:
          this.popColorMask(maskData);
          break;
      }
    }
    maskData.reset();
    if (maskData.pooled) {
      this.maskDataPool.push(maskData);
    }
    if (this.maskStack.length !== 0) {
      var maskCurrent = this.maskStack[this.maskStack.length - 1];
      if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters) {
        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
      }
    }
  };
  MaskSystem2.prototype.detect = function(maskData) {
    var maskObject = maskData.maskObject;
    if (!maskObject) {
      maskData.type = MASK_TYPES.COLOR;
    } else if (maskObject.isSprite) {
      maskData.type = MASK_TYPES.SPRITE;
    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
      maskData.type = MASK_TYPES.SCISSOR;
    } else {
      maskData.type = MASK_TYPES.STENCIL;
    }
  };
  MaskSystem2.prototype.pushSpriteMask = function(maskData) {
    var _a2, _b2;
    var maskObject = maskData.maskObject;
    var target = maskData._target;
    var alphaMaskFilter = maskData._filters;
    if (!alphaMaskFilter) {
      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];
      }
    }
    var renderer2 = this.renderer;
    var renderTextureSystem = renderer2.renderTexture;
    var resolution;
    var multisample;
    if (renderTextureSystem.current) {
      var renderTexture = renderTextureSystem.current;
      resolution = maskData.resolution || renderTexture.resolution;
      multisample = (_a2 = maskData.multisample) !== null && _a2 !== void 0 ? _a2 : renderTexture.multisample;
    } else {
      resolution = maskData.resolution || renderer2.resolution;
      multisample = (_b2 = maskData.multisample) !== null && _b2 !== void 0 ? _b2 : renderer2.multisample;
    }
    alphaMaskFilter[0].resolution = resolution;
    alphaMaskFilter[0].multisample = multisample;
    alphaMaskFilter[0].maskSprite = maskObject;
    var stashFilterArea = target.filterArea;
    target.filterArea = maskObject.getBounds(true);
    renderer2.filter.push(target, alphaMaskFilter);
    target.filterArea = stashFilterArea;
    if (!maskData._filters) {
      this.alphaMaskIndex++;
    }
  };
  MaskSystem2.prototype.popSpriteMask = function(maskData) {
    this.renderer.filter.pop();
    if (maskData._filters) {
      maskData._filters[0].maskSprite = null;
    } else {
      this.alphaMaskIndex--;
      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
    }
  };
  MaskSystem2.prototype.pushColorMask = function(maskData) {
    var currColorMask = maskData._colorMask;
    var nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  };
  MaskSystem2.prototype.popColorMask = function(maskData) {
    var currColorMask = maskData._colorMask;
    var nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  };
  MaskSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return MaskSystem2;
}();
var AbstractMaskSystem = function() {
  function AbstractMaskSystem2(renderer2) {
    this.renderer = renderer2;
    this.maskStack = [];
    this.glConst = 0;
  }
  AbstractMaskSystem2.prototype.getStackLength = function() {
    return this.maskStack.length;
  };
  AbstractMaskSystem2.prototype.setMaskStack = function(maskStack) {
    var gl = this.renderer.gl;
    var curStackLen = this.getStackLength();
    this.maskStack = maskStack;
    var newStackLen = this.getStackLength();
    if (newStackLen !== curStackLen) {
      if (newStackLen === 0) {
        gl.disable(this.glConst);
      } else {
        gl.enable(this.glConst);
        this._useCurrent();
      }
    }
  };
  AbstractMaskSystem2.prototype._useCurrent = function() {
  };
  AbstractMaskSystem2.prototype.destroy = function() {
    this.renderer = null;
    this.maskStack = null;
  };
  return AbstractMaskSystem2;
}();
var tempMatrix$1 = new Matrix();
var rectPool = [];
var ScissorSystem = function(_super) {
  __extends$i(ScissorSystem2, _super);
  function ScissorSystem2(renderer2) {
    var _this = _super.call(this, renderer2) || this;
    _this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
    return _this;
  }
  ScissorSystem2.prototype.getStackLength = function() {
    var maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._scissorCounter;
    }
    return 0;
  };
  ScissorSystem2.prototype.calcScissorRect = function(maskData) {
    var _a2;
    if (maskData._scissorRectLocal) {
      return;
    }
    var prevData = maskData._scissorRect;
    var maskObject = maskData.maskObject;
    var renderer2 = this.renderer;
    var renderTextureSystem = renderer2.renderTexture;
    var rect = maskObject.getBounds(true, (_a2 = rectPool.pop()) !== null && _a2 !== void 0 ? _a2 : new Rectangle());
    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer2.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer2.projection.transform);
    if (prevData) {
      rect.fit(prevData);
    }
    maskData._scissorRectLocal = rect;
  };
  ScissorSystem2.isMatrixRotated = function(matrix) {
    if (!matrix) {
      return false;
    }
    var a2 = matrix.a, b2 = matrix.b, c = matrix.c, d2 = matrix.d;
    return (Math.abs(b2) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d2) > 1e-4);
  };
  ScissorSystem2.prototype.testScissor = function(maskData) {
    var maskObject = maskData.maskObject;
    if (!maskObject.isFastRect || !maskObject.isFastRect()) {
      return false;
    }
    if (ScissorSystem2.isMatrixRotated(maskObject.worldTransform)) {
      return false;
    }
    if (ScissorSystem2.isMatrixRotated(this.renderer.projection.transform)) {
      return false;
    }
    this.calcScissorRect(maskData);
    var rect = maskData._scissorRectLocal;
    return rect.width > 0 && rect.height > 0;
  };
  ScissorSystem2.prototype.roundFrameToPixels = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (ScissorSystem2.isMatrixRotated(transform)) {
      return;
    }
    transform = transform ? tempMatrix$1.copyFrom(transform) : tempMatrix$1.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.renderer.filter.transformAABB(transform, frame);
    frame.fit(bindingDestinationFrame);
    frame.x = Math.round(frame.x * resolution);
    frame.y = Math.round(frame.y * resolution);
    frame.width = Math.round(frame.width * resolution);
    frame.height = Math.round(frame.height * resolution);
  };
  ScissorSystem2.prototype.push = function(maskData) {
    if (!maskData._scissorRectLocal) {
      this.calcScissorRect(maskData);
    }
    var gl = this.renderer.gl;
    if (!maskData._scissorRect) {
      gl.enable(gl.SCISSOR_TEST);
    }
    maskData._scissorCounter++;
    maskData._scissorRect = maskData._scissorRectLocal;
    this._useCurrent();
  };
  ScissorSystem2.prototype.pop = function(maskData) {
    var gl = this.renderer.gl;
    if (maskData) {
      rectPool.push(maskData._scissorRectLocal);
    }
    if (this.getStackLength() > 0) {
      this._useCurrent();
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  };
  ScissorSystem2.prototype._useCurrent = function() {
    var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
    var y2;
    if (this.renderer.renderTexture.current) {
      y2 = rect.y;
    } else {
      y2 = this.renderer.height - rect.height - rect.y;
    }
    this.renderer.gl.scissor(rect.x, y2, rect.width, rect.height);
  };
  return ScissorSystem2;
}(AbstractMaskSystem);
var StencilSystem = function(_super) {
  __extends$i(StencilSystem2, _super);
  function StencilSystem2(renderer2) {
    var _this = _super.call(this, renderer2) || this;
    _this.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
    return _this;
  }
  StencilSystem2.prototype.getStackLength = function() {
    var maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._stencilCounter;
    }
    return 0;
  };
  StencilSystem2.prototype.push = function(maskData) {
    var maskObject = maskData.maskObject;
    var gl = this.renderer.gl;
    var prevMaskCount = maskData._stencilCounter;
    if (prevMaskCount === 0) {
      this.renderer.framebuffer.forceStencil();
      gl.clearStencil(0);
      gl.clear(gl.STENCIL_BUFFER_BIT);
      gl.enable(gl.STENCIL_TEST);
    }
    maskData._stencilCounter++;
    var colorMask = maskData._colorMask;
    if (colorMask !== 0) {
      maskData._colorMask = 0;
      gl.colorMask(false, false, false, false);
    }
    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
    maskObject.renderable = true;
    maskObject.render(this.renderer);
    this.renderer.batch.flush();
    maskObject.renderable = false;
    if (colorMask !== 0) {
      maskData._colorMask = colorMask;
      gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
    }
    this._useCurrent();
  };
  StencilSystem2.prototype.pop = function(maskObject) {
    var gl = this.renderer.gl;
    if (this.getStackLength() === 0) {
      gl.disable(gl.STENCIL_TEST);
    } else {
      var maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      var colorMask = maskData ? maskData._colorMask : 15;
      if (colorMask !== 0) {
        maskData._colorMask = 0;
        gl.colorMask(false, false, false, false);
      }
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      if (colorMask !== 0) {
        maskData._colorMask = colorMask;
        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
      }
      this._useCurrent();
    }
  };
  StencilSystem2.prototype._useCurrent = function() {
    var gl = this.renderer.gl;
    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  };
  return StencilSystem2;
}(AbstractMaskSystem);
var ProjectionSystem = function() {
  function ProjectionSystem2(renderer2) {
    this.renderer = renderer2;
    this.destinationFrame = null;
    this.sourceFrame = null;
    this.defaultFrame = null;
    this.projectionMatrix = new Matrix();
    this.transform = null;
  }
  ProjectionSystem2.prototype.update = function(destinationFrame, sourceFrame, resolution, root2) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
    this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root2);
    if (this.transform) {
      this.projectionMatrix.append(this.transform);
    }
    var renderer2 = this.renderer;
    renderer2.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
    renderer2.globalUniforms.update();
    if (renderer2.shader.shader) {
      renderer2.shader.syncUniformGroup(renderer2.shader.shader.uniforms.globals);
    }
  };
  ProjectionSystem2.prototype.calculateProjection = function(_destinationFrame, sourceFrame, _resolution, root2) {
    var pm = this.projectionMatrix;
    var sign2 = !root2 ? 1 : -1;
    pm.identity();
    pm.a = 1 / sourceFrame.width * 2;
    pm.d = sign2 * (1 / sourceFrame.height * 2);
    pm.tx = -1 - sourceFrame.x * pm.a;
    pm.ty = -sign2 - sourceFrame.y * pm.d;
  };
  ProjectionSystem2.prototype.setTransform = function(_matrix) {
  };
  ProjectionSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return ProjectionSystem2;
}();
var tempRect = new Rectangle();
var tempRect2 = new Rectangle();
var RenderTextureSystem = function() {
  function RenderTextureSystem2(renderer2) {
    this.renderer = renderer2;
    this.clearColor = renderer2._backgroundColorRgba;
    this.defaultMaskStack = [];
    this.current = null;
    this.sourceFrame = new Rectangle();
    this.destinationFrame = new Rectangle();
    this.viewportFrame = new Rectangle();
  }
  RenderTextureSystem2.prototype.bind = function(renderTexture, sourceFrame, destinationFrame) {
    if (renderTexture === void 0) {
      renderTexture = null;
    }
    var renderer2 = this.renderer;
    this.current = renderTexture;
    var baseTexture;
    var framebuffer;
    var resolution;
    if (renderTexture) {
      baseTexture = renderTexture.baseTexture;
      resolution = baseTexture.resolution;
      if (!sourceFrame) {
        tempRect.width = renderTexture.frame.width;
        tempRect.height = renderTexture.frame.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        tempRect2.x = renderTexture.frame.x;
        tempRect2.y = renderTexture.frame.y;
        tempRect2.width = sourceFrame.width;
        tempRect2.height = sourceFrame.height;
        destinationFrame = tempRect2;
      }
      framebuffer = baseTexture.framebuffer;
    } else {
      resolution = renderer2.resolution;
      if (!sourceFrame) {
        tempRect.width = renderer2.screen.width;
        tempRect.height = renderer2.screen.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        destinationFrame = tempRect;
        destinationFrame.width = sourceFrame.width;
        destinationFrame.height = sourceFrame.height;
      }
    }
    var viewportFrame = this.viewportFrame;
    viewportFrame.x = destinationFrame.x * resolution;
    viewportFrame.y = destinationFrame.y * resolution;
    viewportFrame.width = destinationFrame.width * resolution;
    viewportFrame.height = destinationFrame.height * resolution;
    if (!renderTexture) {
      viewportFrame.y = renderer2.view.height - (viewportFrame.y + viewportFrame.height);
    }
    viewportFrame.ceil();
    this.renderer.framebuffer.bind(framebuffer, viewportFrame);
    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
    if (renderTexture) {
      this.renderer.mask.setMaskStack(baseTexture.maskStack);
    } else {
      this.renderer.mask.setMaskStack(this.defaultMaskStack);
    }
    this.sourceFrame.copyFrom(sourceFrame);
    this.destinationFrame.copyFrom(destinationFrame);
  };
  RenderTextureSystem2.prototype.clear = function(clearColor, mask) {
    if (this.current) {
      clearColor = clearColor || this.current.baseTexture.clearColor;
    } else {
      clearColor = clearColor || this.clearColor;
    }
    var destinationFrame = this.destinationFrame;
    var baseFrame = this.current ? this.current.baseTexture : this.renderer.screen;
    var clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
    if (clearMask) {
      var _a2 = this.viewportFrame, x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
      x2 = Math.round(x2);
      y2 = Math.round(y2);
      width = Math.round(width);
      height = Math.round(height);
      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
      this.renderer.gl.scissor(x2, y2, width, height);
    }
    this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);
    if (clearMask) {
      this.renderer.scissor.pop();
    }
  };
  RenderTextureSystem2.prototype.resize = function() {
    this.bind(null);
  };
  RenderTextureSystem2.prototype.reset = function() {
    this.bind(null);
  };
  RenderTextureSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return RenderTextureSystem2;
}();
function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
  _renderer.buffer.update(buffer);
}
var UBO_TO_SINGLE_SETTERS = {
  float: "\n        data[offset] = v;\n    ",
  vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",
  vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",
  vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",
  mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",
  mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",
  mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    "
};
var GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(uniformData) {
  var uboElements = uniformData.map(function(data) {
    return {
      data,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  });
  var size = 0;
  var chunkSize = 0;
  var offset = 0;
  for (var i = 0; i < uboElements.length; i++) {
    var uboElement = uboElements[i];
    size = GLSL_TO_STD40_SIZE[uboElement.data.type];
    if (uboElement.data.size > 1) {
      size = Math.max(size, 16) * uboElement.data.size;
    }
    uboElement.dataLen = size;
    if (chunkSize % size !== 0 && chunkSize < 16) {
      var lineUpValue = chunkSize % size % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size;
      chunkSize = size;
    } else {
      uboElement.offset = offset;
      chunkSize += size;
      offset += size;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
function getUBOData(uniforms, uniformData) {
  var usedUniformDatas = [];
  for (var i in uniforms) {
    if (uniformData[i]) {
      usedUniformDatas.push(uniformData[i]);
    }
  }
  usedUniformDatas.sort(function(a2, b2) {
    return a2.index - b2.index;
  });
  return usedUniformDatas;
}
function generateUniformBufferSync(group, uniformData) {
  if (!group.autoManage) {
    return { size: 0, syncFunc: uboUpdate };
  }
  var usedUniformDatas = getUBOData(group.uniforms, uniformData);
  var _a2 = createUBOElements(usedUniformDatas), uboElements = _a2.uboElements, size = _a2.size;
  var funcFragments = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "];
  for (var i = 0; i < uboElements.length; i++) {
    var uboElement = uboElements[i];
    var uniform = group.uniforms[uboElement.data.name];
    var name = uboElement.data.name;
    var parsed = false;
    for (var j2 = 0; j2 < uniformParsers.length; j2++) {
      var uniformParser = uniformParsers[j2];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push("offset = " + uboElement.offset / 4 + ";", uniformParsers[j2].codeUbo(uboElement.data.name, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        var size_1 = mapSize(uboElement.data.type);
        var rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        var elementSize = size_1 / rowSize;
        var remainder = (4 - elementSize % 4) % 4;
        funcFragments.push("\n                cv = ud." + name + ".value;\n                v = uv." + name + ";\n                offset = " + uboElement.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + uboElement.data.size * rowSize + "; i++)\n                {\n                    for(var j = 0; j < " + elementSize + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + remainder + ";\n                }\n\n                ");
      } else {
        var template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push("\n                cv = ud." + name + ".value;\n                v = uv." + name + ";\n                offset = " + uboElement.offset / 4 + ";\n                " + template + ";\n                ");
      }
    }
  }
  funcFragments.push("\n       renderer.buffer.update(buffer);\n    ");
  return {
    size,
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
  };
}
var GLProgram = function() {
  function GLProgram2(program, uniformData) {
    this.program = program;
    this.uniformData = uniformData;
    this.uniformGroups = {};
    this.uniformDirtyGroups = {};
    this.uniformBufferBindings = {};
  }
  GLProgram2.prototype.destroy = function() {
    this.uniformData = null;
    this.uniformGroups = null;
    this.uniformDirtyGroups = null;
    this.uniformBufferBindings = null;
    this.program = null;
  };
  return GLProgram2;
}();
function getAttributeData(program, gl) {
  var attributes = {};
  var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < totalAttributes; i++) {
    var attribData = gl.getActiveAttrib(program, i);
    if (attribData.name.indexOf("gl_") === 0) {
      continue;
    }
    var type2 = mapType(gl, attribData.type);
    var data = {
      type: type2,
      name: attribData.name,
      size: mapSize(type2),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}
function getUniformData(program, gl) {
  var uniforms = {};
  var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (var i = 0; i < totalUniforms; i++) {
    var uniformData = gl.getActiveUniform(program, i);
    var name = uniformData.name.replace(/\[.*?\]$/, "");
    var isArray2 = !!uniformData.name.match(/\[.*?\]$/);
    var type2 = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i,
      type: type2,
      size: uniformData.size,
      isArray: isArray2,
      value: defaultValue(type2, uniformData.size)
    };
  }
  return uniforms;
}
function generateProgram(gl, program) {
  var glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
  var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
  var webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData(webGLProgram, gl);
  if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    var keys3 = Object.keys(program.attributeData);
    keys3.sort(function(a2, b2) {
      return a2 > b2 ? 1 : -1;
    });
    for (var i = 0; i < keys3.length; i++) {
      program.attributeData[keys3[i]].location = i;
      gl.bindAttribLocation(webGLProgram, i, keys3[i]);
    }
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  var uniformData = {};
  for (var i in program.uniformData) {
    var data = program.uniformData[i];
    uniformData[i] = {
      location: gl.getUniformLocation(webGLProgram, i),
      value: defaultValue(data.type, data.size)
    };
  }
  var glProgram = new GLProgram(webGLProgram, uniformData);
  return glProgram;
}
var UID = 0;
var defaultSyncData = { textureCount: 0, uboCount: 0 };
var ShaderSystem = function() {
  function ShaderSystem2(renderer2) {
    this.destroyed = false;
    this.renderer = renderer2;
    this.systemCheck();
    this.gl = null;
    this.shader = null;
    this.program = null;
    this.cache = {};
    this._uboCache = {};
    this.id = UID++;
  }
  ShaderSystem2.prototype.systemCheck = function() {
    if (!unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }
  };
  ShaderSystem2.prototype.contextChange = function(gl) {
    this.gl = gl;
    this.reset();
  };
  ShaderSystem2.prototype.bind = function(shader, dontSync) {
    shader.disposeRunner.add(this);
    shader.uniforms.globals = this.renderer.globalUniforms;
    var program = shader.program;
    var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
    this.shader = shader;
    if (this.program !== program) {
      this.program = program;
      this.gl.useProgram(glProgram.program);
    }
    if (!dontSync) {
      defaultSyncData.textureCount = 0;
      defaultSyncData.uboCount = 0;
      this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
    }
    return glProgram;
  };
  ShaderSystem2.prototype.setUniforms = function(uniforms) {
    var shader = this.shader.program;
    var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
  };
  ShaderSystem2.prototype.syncUniformGroup = function(group, syncData) {
    var glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
      glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
      this.syncUniforms(group, glProgram, syncData);
    }
  };
  ShaderSystem2.prototype.syncUniforms = function(group, glProgram, syncData) {
    var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
    syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
  };
  ShaderSystem2.prototype.createSyncGroups = function(group) {
    var id = this.getSignature(group, this.shader.program.uniformData, "u");
    if (!this.cache[id]) {
      this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);
    }
    group.syncUniforms[this.shader.program.id] = this.cache[id];
    return group.syncUniforms[this.shader.program.id];
  };
  ShaderSystem2.prototype.syncUniformBufferGroup = function(group, name) {
    var glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
      group.dirtyId = 0;
      var syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
      group.buffer.update();
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
    }
    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
  };
  ShaderSystem2.prototype.createSyncBufferGroup = function(group, glProgram, name) {
    var gl = this.renderer.gl;
    this.renderer.buffer.bind(group.buffer);
    var uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
    gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
    this.shader.uniformBindCount++;
    var id = this.getSignature(group, this.shader.program.uniformData, "ubo");
    var uboData = this._uboCache[id];
    if (!uboData) {
      uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData);
    }
    if (group.autoManage) {
      var data = new Float32Array(uboData.size / 4);
      group.buffer.update(data);
    }
    glProgram.uniformGroups[group.id] = uboData.syncFunc;
    return glProgram.uniformGroups[group.id];
  };
  ShaderSystem2.prototype.getSignature = function(group, uniformData, preFix) {
    var uniforms = group.uniforms;
    var strings = [preFix + "-"];
    for (var i in uniforms) {
      strings.push(i);
      if (uniformData[i]) {
        strings.push(uniformData[i].type);
      }
    }
    return strings.join("-");
  };
  ShaderSystem2.prototype.getGlProgram = function() {
    if (this.shader) {
      return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
    }
    return null;
  };
  ShaderSystem2.prototype.generateProgram = function(shader) {
    var gl = this.gl;
    var program = shader.program;
    var glProgram = generateProgram(gl, program);
    program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
    return glProgram;
  };
  ShaderSystem2.prototype.reset = function() {
    this.program = null;
    this.shader = null;
  };
  ShaderSystem2.prototype.disposeShader = function(shader) {
    if (this.shader === shader) {
      this.shader = null;
    }
  };
  ShaderSystem2.prototype.destroy = function() {
    this.renderer = null;
    this.destroyed = true;
  };
  return ShaderSystem2;
}();
function mapWebGLBlendModesToPixi(gl, array) {
  if (array === void 0) {
    array = [];
  }
  array[BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
  array[BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.NONE] = [0, 0];
  array[BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array[BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array;
}
var BLEND = 0;
var OFFSET = 1;
var CULLING = 2;
var DEPTH_TEST = 3;
var WINDING = 4;
var DEPTH_MASK = 5;
var StateSystem = function() {
  function StateSystem2() {
    this.gl = null;
    this.stateId = 0;
    this.polygonOffset = 0;
    this.blendMode = BLEND_MODES.NONE;
    this._blendEq = false;
    this.map = [];
    this.map[BLEND] = this.setBlend;
    this.map[OFFSET] = this.setOffset;
    this.map[CULLING] = this.setCullFace;
    this.map[DEPTH_TEST] = this.setDepthTest;
    this.map[WINDING] = this.setFrontFace;
    this.map[DEPTH_MASK] = this.setDepthMask;
    this.checks = [];
    this.defaultState = new State();
    this.defaultState.blend = true;
  }
  StateSystem2.prototype.contextChange = function(gl) {
    this.gl = gl;
    this.blendModes = mapWebGLBlendModesToPixi(gl);
    this.set(this.defaultState);
    this.reset();
  };
  StateSystem2.prototype.set = function(state) {
    state = state || this.defaultState;
    if (this.stateId !== state.data) {
      var diff = this.stateId ^ state.data;
      var i = 0;
      while (diff) {
        if (diff & 1) {
          this.map[i].call(this, !!(state.data & 1 << i));
        }
        diff = diff >> 1;
        i++;
      }
      this.stateId = state.data;
    }
    for (var i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
  };
  StateSystem2.prototype.forceState = function(state) {
    state = state || this.defaultState;
    for (var i = 0; i < this.map.length; i++) {
      this.map[i].call(this, !!(state.data & 1 << i));
    }
    for (var i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
    this.stateId = state.data;
  };
  StateSystem2.prototype.setBlend = function(value) {
    this.updateCheck(StateSystem2.checkBlendMode, value);
    this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  };
  StateSystem2.prototype.setOffset = function(value) {
    this.updateCheck(StateSystem2.checkPolygonOffset, value);
    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  };
  StateSystem2.prototype.setDepthTest = function(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  };
  StateSystem2.prototype.setDepthMask = function(value) {
    this.gl.depthMask(value);
  };
  StateSystem2.prototype.setCullFace = function(value) {
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
  };
  StateSystem2.prototype.setFrontFace = function(value) {
    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
  };
  StateSystem2.prototype.setBlendMode = function(value) {
    if (value === this.blendMode) {
      return;
    }
    this.blendMode = value;
    var mode = this.blendModes[value];
    var gl = this.gl;
    if (mode.length === 2) {
      gl.blendFunc(mode[0], mode[1]);
    } else {
      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
    }
    if (mode.length === 6) {
      this._blendEq = true;
      gl.blendEquationSeparate(mode[4], mode[5]);
    } else if (this._blendEq) {
      this._blendEq = false;
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  };
  StateSystem2.prototype.setPolygonOffset = function(value, scale) {
    this.gl.polygonOffset(value, scale);
  };
  StateSystem2.prototype.reset = function() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.forceState(this.defaultState);
    this._blendEq = true;
    this.blendMode = -1;
    this.setBlendMode(0);
  };
  StateSystem2.prototype.updateCheck = function(func, value) {
    var index = this.checks.indexOf(func);
    if (value && index === -1) {
      this.checks.push(func);
    } else if (!value && index !== -1) {
      this.checks.splice(index, 1);
    }
  };
  StateSystem2.checkBlendMode = function(system, state) {
    system.setBlendMode(state.blendMode);
  };
  StateSystem2.checkPolygonOffset = function(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  };
  StateSystem2.prototype.destroy = function() {
    this.gl = null;
  };
  return StateSystem2;
}();
var TextureGCSystem = function() {
  function TextureGCSystem2(renderer2) {
    this.renderer = renderer2;
    this.count = 0;
    this.checkCount = 0;
    this.maxIdle = settings.GC_MAX_IDLE;
    this.checkCountMax = settings.GC_MAX_CHECK_COUNT;
    this.mode = settings.GC_MODE;
  }
  TextureGCSystem2.prototype.postrender = function() {
    if (!this.renderer.renderingToScreen) {
      return;
    }
    this.count++;
    if (this.mode === GC_MODES.MANUAL) {
      return;
    }
    this.checkCount++;
    if (this.checkCount > this.checkCountMax) {
      this.checkCount = 0;
      this.run();
    }
  };
  TextureGCSystem2.prototype.run = function() {
    var tm = this.renderer.texture;
    var managedTextures = tm.managedTextures;
    var wasRemoved = false;
    for (var i = 0; i < managedTextures.length; i++) {
      var texture = managedTextures[i];
      if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
        tm.destroyTexture(texture, true);
        managedTextures[i] = null;
        wasRemoved = true;
      }
    }
    if (wasRemoved) {
      var j2 = 0;
      for (var i = 0; i < managedTextures.length; i++) {
        if (managedTextures[i] !== null) {
          managedTextures[j2++] = managedTextures[i];
        }
      }
      managedTextures.length = j2;
    }
  };
  TextureGCSystem2.prototype.unload = function(displayObject) {
    var tm = this.renderer.texture;
    var texture = displayObject._texture;
    if (texture && !texture.framebuffer) {
      tm.destroyTexture(texture);
    }
    for (var i = displayObject.children.length - 1; i >= 0; i--) {
      this.unload(displayObject.children[i]);
    }
  };
  TextureGCSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return TextureGCSystem2;
}();
function mapTypeAndFormatToInternalFormat(gl) {
  var _a2, _b2, _c2, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
  var table;
  if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
    table = (_a2 = {}, _a2[TYPES.UNSIGNED_BYTE] = (_b2 = {}, _b2[FORMATS.RGBA] = gl.RGBA8, _b2[FORMATS.RGB] = gl.RGB8, _b2[FORMATS.RG] = gl.RG8, _b2[FORMATS.RED] = gl.R8, _b2[FORMATS.RGBA_INTEGER] = gl.RGBA8UI, _b2[FORMATS.RGB_INTEGER] = gl.RGB8UI, _b2[FORMATS.RG_INTEGER] = gl.RG8UI, _b2[FORMATS.RED_INTEGER] = gl.R8UI, _b2[FORMATS.ALPHA] = gl.ALPHA, _b2[FORMATS.LUMINANCE] = gl.LUMINANCE, _b2[FORMATS.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _b2), _a2[TYPES.BYTE] = (_c2 = {}, _c2[FORMATS.RGBA] = gl.RGBA8_SNORM, _c2[FORMATS.RGB] = gl.RGB8_SNORM, _c2[FORMATS.RG] = gl.RG8_SNORM, _c2[FORMATS.RED] = gl.R8_SNORM, _c2[FORMATS.RGBA_INTEGER] = gl.RGBA8I, _c2[FORMATS.RGB_INTEGER] = gl.RGB8I, _c2[FORMATS.RG_INTEGER] = gl.RG8I, _c2[FORMATS.RED_INTEGER] = gl.R8I, _c2), _a2[TYPES.UNSIGNED_SHORT] = (_d = {}, _d[FORMATS.RGBA_INTEGER] = gl.RGBA16UI, _d[FORMATS.RGB_INTEGER] = gl.RGB16UI, _d[FORMATS.RG_INTEGER] = gl.RG16UI, _d[FORMATS.RED_INTEGER] = gl.R16UI, _d[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT16, _d), _a2[TYPES.SHORT] = (_e = {}, _e[FORMATS.RGBA_INTEGER] = gl.RGBA16I, _e[FORMATS.RGB_INTEGER] = gl.RGB16I, _e[FORMATS.RG_INTEGER] = gl.RG16I, _e[FORMATS.RED_INTEGER] = gl.R16I, _e), _a2[TYPES.UNSIGNED_INT] = (_f = {}, _f[FORMATS.RGBA_INTEGER] = gl.RGBA32UI, _f[FORMATS.RGB_INTEGER] = gl.RGB32UI, _f[FORMATS.RG_INTEGER] = gl.RG32UI, _f[FORMATS.RED_INTEGER] = gl.R32UI, _f[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT24, _f), _a2[TYPES.INT] = (_g = {}, _g[FORMATS.RGBA_INTEGER] = gl.RGBA32I, _g[FORMATS.RGB_INTEGER] = gl.RGB32I, _g[FORMATS.RG_INTEGER] = gl.RG32I, _g[FORMATS.RED_INTEGER] = gl.R32I, _g), _a2[TYPES.FLOAT] = (_h = {}, _h[FORMATS.RGBA] = gl.RGBA32F, _h[FORMATS.RGB] = gl.RGB32F, _h[FORMATS.RG] = gl.RG32F, _h[FORMATS.RED] = gl.R32F, _h[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT32F, _h), _a2[TYPES.HALF_FLOAT] = (_j = {}, _j[FORMATS.RGBA] = gl.RGBA16F, _j[FORMATS.RGB] = gl.RGB16F, _j[FORMATS.RG] = gl.RG16F, _j[FORMATS.RED] = gl.R16F, _j), _a2[TYPES.UNSIGNED_SHORT_5_6_5] = (_k = {}, _k[FORMATS.RGB] = gl.RGB565, _k), _a2[TYPES.UNSIGNED_SHORT_4_4_4_4] = (_l = {}, _l[FORMATS.RGBA] = gl.RGBA4, _l), _a2[TYPES.UNSIGNED_SHORT_5_5_5_1] = (_m = {}, _m[FORMATS.RGBA] = gl.RGB5_A1, _m), _a2[TYPES.UNSIGNED_INT_2_10_10_10_REV] = (_o = {}, _o[FORMATS.RGBA] = gl.RGB10_A2, _o[FORMATS.RGBA_INTEGER] = gl.RGB10_A2UI, _o), _a2[TYPES.UNSIGNED_INT_10F_11F_11F_REV] = (_p = {}, _p[FORMATS.RGB] = gl.R11F_G11F_B10F, _p), _a2[TYPES.UNSIGNED_INT_5_9_9_9_REV] = (_q = {}, _q[FORMATS.RGB] = gl.RGB9_E5, _q), _a2[TYPES.UNSIGNED_INT_24_8] = (_r = {}, _r[FORMATS.DEPTH_STENCIL] = gl.DEPTH24_STENCIL8, _r), _a2[TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV] = (_s = {}, _s[FORMATS.DEPTH_STENCIL] = gl.DEPTH32F_STENCIL8, _s), _a2);
  } else {
    table = (_t = {}, _t[TYPES.UNSIGNED_BYTE] = (_u = {}, _u[FORMATS.RGBA] = gl.RGBA, _u[FORMATS.RGB] = gl.RGB, _u[FORMATS.ALPHA] = gl.ALPHA, _u[FORMATS.LUMINANCE] = gl.LUMINANCE, _u[FORMATS.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _u), _t[TYPES.UNSIGNED_SHORT_5_6_5] = (_v = {}, _v[FORMATS.RGB] = gl.RGB, _v), _t[TYPES.UNSIGNED_SHORT_4_4_4_4] = (_w = {}, _w[FORMATS.RGBA] = gl.RGBA, _w), _t[TYPES.UNSIGNED_SHORT_5_5_5_1] = (_x = {}, _x[FORMATS.RGBA] = gl.RGBA, _x), _t);
  }
  return table;
}
var GLTexture = function() {
  function GLTexture2(texture) {
    this.texture = texture;
    this.width = -1;
    this.height = -1;
    this.dirtyId = -1;
    this.dirtyStyleId = -1;
    this.mipmap = false;
    this.wrapMode = 33071;
    this.type = TYPES.UNSIGNED_BYTE;
    this.internalFormat = FORMATS.RGBA;
    this.samplerType = 0;
  }
  return GLTexture2;
}();
var TextureSystem = function() {
  function TextureSystem2(renderer2) {
    this.renderer = renderer2;
    this.boundTextures = [];
    this.currentLocation = -1;
    this.managedTextures = [];
    this._unknownBoundTextures = false;
    this.unknownTexture = new BaseTexture();
    this.hasIntegerTextures = false;
  }
  TextureSystem2.prototype.contextChange = function() {
    var gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.webGLVersion = this.renderer.context.webGLVersion;
    this.internalFormats = mapTypeAndFormatToInternalFormat(gl);
    var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = maxTextures;
    for (var i = 0; i < maxTextures; i++) {
      this.boundTextures[i] = null;
    }
    this.emptyTextures = {};
    var emptyTexture2D = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
    for (var i = 0; i < 6; i++) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    for (var i = 0; i < this.boundTextures.length; i++) {
      this.bind(null, i);
    }
  };
  TextureSystem2.prototype.bind = function(texture, location) {
    if (location === void 0) {
      location = 0;
    }
    var gl = this.gl;
    texture = texture === null || texture === void 0 ? void 0 : texture.castToBaseTexture();
    if (texture && texture.valid && !texture.parentTextureArray) {
      texture.touched = this.renderer.textureGC.count;
      var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
      if (this.boundTextures[location] !== texture) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        gl.bindTexture(texture.target, glTexture.texture);
      }
      if (glTexture.dirtyId !== texture.dirtyId) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        this.updateTexture(texture);
      } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {
        this.updateTextureStyle(texture);
      }
      this.boundTextures[location] = texture;
    } else {
      if (this.currentLocation !== location) {
        this.currentLocation = location;
        gl.activeTexture(gl.TEXTURE0 + location);
      }
      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
      this.boundTextures[location] = null;
    }
  };
  TextureSystem2.prototype.reset = function() {
    this._unknownBoundTextures = true;
    this.hasIntegerTextures = false;
    this.currentLocation = -1;
    for (var i = 0; i < this.boundTextures.length; i++) {
      this.boundTextures[i] = this.unknownTexture;
    }
  };
  TextureSystem2.prototype.unbind = function(texture) {
    var _a2 = this, gl = _a2.gl, boundTextures = _a2.boundTextures;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = false;
      for (var i = 0; i < boundTextures.length; i++) {
        if (boundTextures[i] === this.unknownTexture) {
          this.bind(null, i);
        }
      }
    }
    for (var i = 0; i < boundTextures.length; i++) {
      if (boundTextures[i] === texture) {
        if (this.currentLocation !== i) {
          gl.activeTexture(gl.TEXTURE0 + i);
          this.currentLocation = i;
        }
        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
        boundTextures[i] = null;
      }
    }
  };
  TextureSystem2.prototype.ensureSamplerType = function(maxTextures) {
    var _a2 = this, boundTextures = _a2.boundTextures, hasIntegerTextures = _a2.hasIntegerTextures, CONTEXT_UID = _a2.CONTEXT_UID;
    if (!hasIntegerTextures) {
      return;
    }
    for (var i = maxTextures - 1; i >= 0; --i) {
      var tex = boundTextures[i];
      if (tex) {
        var glTexture = tex._glTextures[CONTEXT_UID];
        if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
          this.renderer.texture.unbind(tex);
        }
      }
    }
  };
  TextureSystem2.prototype.initTexture = function(texture) {
    var glTexture = new GLTexture(this.gl.createTexture());
    glTexture.dirtyId = -1;
    texture._glTextures[this.CONTEXT_UID] = glTexture;
    this.managedTextures.push(texture);
    texture.on("dispose", this.destroyTexture, this);
    return glTexture;
  };
  TextureSystem2.prototype.initTextureType = function(texture, glTexture) {
    var _a2, _b2;
    glTexture.internalFormat = (_b2 = (_a2 = this.internalFormats[texture.type]) === null || _a2 === void 0 ? void 0 : _a2[texture.format]) !== null && _b2 !== void 0 ? _b2 : texture.format;
    if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT) {
      glTexture.type = this.gl.HALF_FLOAT;
    } else {
      glTexture.type = texture.type;
    }
  };
  TextureSystem2.prototype.updateTexture = function(texture) {
    var glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    var renderer2 = this.renderer;
    this.initTextureType(texture, glTexture);
    if (texture.resource && texture.resource.upload(renderer2, texture, glTexture)) {
      if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
        this.hasIntegerTextures = true;
      }
    } else {
      var width = texture.realWidth;
      var height = texture.realHeight;
      var gl = renderer2.gl;
      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
      }
    }
    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
      this.updateTextureStyle(texture);
    }
    glTexture.dirtyId = texture.dirtyId;
  };
  TextureSystem2.prototype.destroyTexture = function(texture, skipRemove) {
    var gl = this.gl;
    texture = texture.castToBaseTexture();
    if (texture._glTextures[this.CONTEXT_UID]) {
      this.unbind(texture);
      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
      texture.off("dispose", this.destroyTexture, this);
      delete texture._glTextures[this.CONTEXT_UID];
      if (!skipRemove) {
        var i = this.managedTextures.indexOf(texture);
        if (i !== -1) {
          removeItems(this.managedTextures, i, 1);
        }
      }
    }
  };
  TextureSystem2.prototype.updateTextureStyle = function(texture) {
    var glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
      glTexture.mipmap = false;
    } else {
      glTexture.mipmap = texture.mipmap >= 1;
    }
    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
      glTexture.wrapMode = WRAP_MODES.CLAMP;
    } else {
      glTexture.wrapMode = texture.wrapMode;
    }
    if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
      ;
    else {
      this.setStyle(texture, glTexture);
    }
    glTexture.dirtyStyleId = texture.dirtyStyleId;
  };
  TextureSystem2.prototype.setStyle = function(texture, glTexture) {
    var gl = this.gl;
    if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL) {
      gl.generateMipmap(texture.target);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
    if (glTexture.mipmap) {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
      var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {
        var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
      }
    } else {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
  };
  TextureSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return TextureSystem2;
}();
var tempMatrix = new Matrix();
var AbstractRenderer = function(_super) {
  __extends$i(AbstractRenderer2, _super);
  function AbstractRenderer2(type2, options) {
    if (type2 === void 0) {
      type2 = RENDERER_TYPE.UNKNOWN;
    }
    var _this = _super.call(this) || this;
    options = Object.assign({}, settings.RENDER_OPTIONS, options);
    _this.options = options;
    _this.type = type2;
    _this.screen = new Rectangle(0, 0, options.width, options.height);
    _this.view = options.view || settings.ADAPTER.createCanvas();
    _this.resolution = options.resolution || settings.RESOLUTION;
    _this.useContextAlpha = options.useContextAlpha;
    _this.autoDensity = !!options.autoDensity;
    _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
    _this.clearBeforeRender = options.clearBeforeRender;
    _this._backgroundColor = 0;
    _this._backgroundColorRgba = [0, 0, 0, 1];
    _this._backgroundColorString = "#000000";
    _this.backgroundColor = options.backgroundColor || _this._backgroundColor;
    _this.backgroundAlpha = options.backgroundAlpha;
    if (options.transparent !== void 0) {
      deprecation("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead.");
      _this.useContextAlpha = options.transparent;
      _this.backgroundAlpha = options.transparent ? 0 : 1;
    }
    _this._lastObjectRendered = null;
    _this.plugins = {};
    return _this;
  }
  AbstractRenderer2.prototype.initPlugins = function(staticMap) {
    for (var o2 in staticMap) {
      this.plugins[o2] = new staticMap[o2](this);
    }
  };
  Object.defineProperty(AbstractRenderer2.prototype, "width", {
    get: function() {
      return this.view.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractRenderer2.prototype, "height", {
    get: function() {
      return this.view.height;
    },
    enumerable: false,
    configurable: true
  });
  AbstractRenderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
    this.view.width = Math.round(desiredScreenWidth * this.resolution);
    this.view.height = Math.round(desiredScreenHeight * this.resolution);
    var screenWidth = this.view.width / this.resolution;
    var screenHeight = this.view.height / this.resolution;
    this.screen.width = screenWidth;
    this.screen.height = screenHeight;
    if (this.autoDensity) {
      this.view.style.width = screenWidth + "px";
      this.view.style.height = screenHeight + "px";
    }
    this.emit("resize", screenWidth, screenHeight);
  };
  AbstractRenderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {
    if (options === void 0) {
      options = {};
    }
    if (typeof options === "number") {
      deprecation("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options.");
      options = { scaleMode: options, resolution, region };
    }
    var manualRegion = options.region, textureOptions = __rest(options, ["region"]);
    region = manualRegion || displayObject.getLocalBounds(null, true);
    if (region.width === 0) {
      region.width = 1;
    }
    if (region.height === 0) {
      region.height = 1;
    }
    var renderTexture = RenderTexture.create(__assign({ width: region.width, height: region.height }, textureOptions));
    tempMatrix.tx = -region.x;
    tempMatrix.ty = -region.y;
    this.render(displayObject, {
      renderTexture,
      clear: false,
      transform: tempMatrix,
      skipUpdateTransform: !!displayObject.parent
    });
    return renderTexture;
  };
  AbstractRenderer2.prototype.destroy = function(removeView) {
    for (var o2 in this.plugins) {
      this.plugins[o2].destroy();
      this.plugins[o2] = null;
    }
    if (removeView && this.view.parentNode) {
      this.view.parentNode.removeChild(this.view);
    }
    var thisAny = this;
    thisAny.plugins = null;
    thisAny.type = RENDERER_TYPE.UNKNOWN;
    thisAny.view = null;
    thisAny.screen = null;
    thisAny._tempDisplayObjectParent = null;
    thisAny.options = null;
    this._backgroundColorRgba = null;
    this._backgroundColorString = null;
    this._lastObjectRendered = null;
  };
  Object.defineProperty(AbstractRenderer2.prototype, "backgroundColor", {
    get: function() {
      return this._backgroundColor;
    },
    set: function(value) {
      this._backgroundColor = value;
      this._backgroundColorString = hex2string(value);
      hex2rgb(value, this._backgroundColorRgba);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractRenderer2.prototype, "backgroundAlpha", {
    get: function() {
      return this._backgroundColorRgba[3];
    },
    set: function(value) {
      this._backgroundColorRgba[3] = value;
    },
    enumerable: false,
    configurable: true
  });
  return AbstractRenderer2;
}(EventEmitter$1);
var GLBuffer = function() {
  function GLBuffer2(buffer) {
    this.buffer = buffer || null;
    this.updateID = -1;
    this.byteLength = -1;
    this.refCount = 0;
  }
  return GLBuffer2;
}();
var BufferSystem = function() {
  function BufferSystem2(renderer2) {
    this.renderer = renderer2;
    this.managedBuffers = {};
    this.boundBufferBases = {};
  }
  BufferSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  BufferSystem2.prototype.contextChange = function() {
    this.disposeAll(true);
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  };
  BufferSystem2.prototype.bind = function(buffer) {
    var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
    var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBuffer(buffer.type, glBuffer.buffer);
  };
  BufferSystem2.prototype.bindBufferBase = function(buffer, index) {
    var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
    if (this.boundBufferBases[index] !== buffer) {
      var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      this.boundBufferBases[index] = buffer;
      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
    }
  };
  BufferSystem2.prototype.bindBufferRange = function(buffer, index, offset) {
    var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
    offset = offset || 0;
    var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
  };
  BufferSystem2.prototype.update = function(buffer) {
    var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
    var glBuffer = buffer._glBuffers[CONTEXT_UID];
    if (buffer._updateID === glBuffer.updateID) {
      return;
    }
    glBuffer.updateID = buffer._updateID;
    gl.bindBuffer(buffer.type, glBuffer.buffer);
    if (glBuffer.byteLength >= buffer.data.byteLength) {
      gl.bufferSubData(buffer.type, 0, buffer.data);
    } else {
      var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
      glBuffer.byteLength = buffer.data.byteLength;
      gl.bufferData(buffer.type, buffer.data, drawType);
    }
  };
  BufferSystem2.prototype.dispose = function(buffer, contextLost) {
    if (!this.managedBuffers[buffer.id]) {
      return;
    }
    delete this.managedBuffers[buffer.id];
    var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
    var gl = this.gl;
    buffer.disposeRunner.remove(this);
    if (!glBuffer) {
      return;
    }
    if (!contextLost) {
      gl.deleteBuffer(glBuffer.buffer);
    }
    delete buffer._glBuffers[this.CONTEXT_UID];
  };
  BufferSystem2.prototype.disposeAll = function(contextLost) {
    var all2 = Object.keys(this.managedBuffers);
    for (var i = 0; i < all2.length; i++) {
      this.dispose(this.managedBuffers[all2[i]], contextLost);
    }
  };
  BufferSystem2.prototype.createGLBuffer = function(buffer) {
    var _a2 = this, CONTEXT_UID = _a2.CONTEXT_UID, gl = _a2.gl;
    buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
    this.managedBuffers[buffer.id] = buffer;
    buffer.disposeRunner.add(this);
    return buffer._glBuffers[CONTEXT_UID];
  };
  return BufferSystem2;
}();
var Renderer = function(_super) {
  __extends$i(Renderer2, _super);
  function Renderer2(options) {
    var _this = _super.call(this, RENDERER_TYPE.WEBGL, options) || this;
    options = _this.options;
    _this.gl = null;
    _this.CONTEXT_UID = 0;
    _this.runners = {
      destroy: new Runner("destroy"),
      contextChange: new Runner("contextChange"),
      reset: new Runner("reset"),
      update: new Runner("update"),
      postrender: new Runner("postrender"),
      prerender: new Runner("prerender"),
      resize: new Runner("resize")
    };
    _this.runners.contextChange.add(_this);
    _this.globalUniforms = new UniformGroup({
      projectionMatrix: new Matrix()
    }, true);
    _this.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(BufferSystem, "buffer").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch");
    _this.initPlugins(Renderer2.__plugins);
    _this.multisample = void 0;
    if (options.context) {
      _this.context.initFromContext(options.context);
    } else {
      _this.context.initFromOptions({
        alpha: !!_this.useContextAlpha,
        antialias: options.antialias,
        premultipliedAlpha: _this.useContextAlpha && _this.useContextAlpha !== "notMultiplied",
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: _this.options.powerPreference
      });
    }
    _this.renderingToScreen = true;
    sayHello(_this.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1");
    _this.resize(_this.options.width, _this.options.height);
    return _this;
  }
  Renderer2.create = function(options) {
    if (isWebGLSupported()) {
      return new Renderer2(options);
    }
    throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
  };
  Renderer2.prototype.contextChange = function() {
    var gl = this.gl;
    var samples;
    if (this.context.webGLVersion === 1) {
      var framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    } else {
      var framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
    }
    if (samples >= MSAA_QUALITY.HIGH) {
      this.multisample = MSAA_QUALITY.HIGH;
    } else if (samples >= MSAA_QUALITY.MEDIUM) {
      this.multisample = MSAA_QUALITY.MEDIUM;
    } else if (samples >= MSAA_QUALITY.LOW) {
      this.multisample = MSAA_QUALITY.LOW;
    } else {
      this.multisample = MSAA_QUALITY.NONE;
    }
  };
  Renderer2.prototype.addSystem = function(ClassRef, name) {
    var system = new ClassRef(this);
    if (this[name]) {
      throw new Error('Whoops! The name "' + name + '" is already in use');
    }
    this[name] = system;
    for (var i in this.runners) {
      this.runners[i].add(system);
    }
    return this;
  };
  Renderer2.prototype.render = function(displayObject, options) {
    var renderTexture;
    var clear;
    var transform;
    var skipUpdateTransform;
    if (options) {
      if (options instanceof RenderTexture) {
        deprecation("6.0.0", "Renderer#render arguments changed, use options instead.");
        renderTexture = options;
        clear = arguments[2];
        transform = arguments[3];
        skipUpdateTransform = arguments[4];
      } else {
        renderTexture = options.renderTexture;
        clear = options.clear;
        transform = options.transform;
        skipUpdateTransform = options.skipUpdateTransform;
      }
    }
    this.renderingToScreen = !renderTexture;
    this.runners.prerender.emit();
    this.emit("prerender");
    this.projection.transform = transform;
    if (this.context.isLost) {
      return;
    }
    if (!renderTexture) {
      this._lastObjectRendered = displayObject;
    }
    if (!skipUpdateTransform) {
      var cacheParent = displayObject.enableTempParent();
      displayObject.updateTransform();
      displayObject.disableTempParent(cacheParent);
    }
    this.renderTexture.bind(renderTexture);
    this.batch.currentRenderer.start();
    if (clear !== void 0 ? clear : this.clearBeforeRender) {
      this.renderTexture.clear();
    }
    displayObject.render(this);
    this.batch.currentRenderer.flush();
    if (renderTexture) {
      renderTexture.baseTexture.update();
    }
    this.runners.postrender.emit();
    this.projection.transform = null;
    this.emit("postrender");
  };
  Renderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {
    if (options === void 0) {
      options = {};
    }
    var renderTexture = _super.prototype.generateTexture.call(this, displayObject, options, resolution, region);
    this.framebuffer.blit();
    return renderTexture;
  };
  Renderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
    _super.prototype.resize.call(this, desiredScreenWidth, desiredScreenHeight);
    this.runners.resize.emit(this.screen.height, this.screen.width);
  };
  Renderer2.prototype.reset = function() {
    this.runners.reset.emit();
    return this;
  };
  Renderer2.prototype.clear = function() {
    this.renderTexture.bind();
    this.renderTexture.clear();
  };
  Renderer2.prototype.destroy = function(removeView) {
    this.runners.destroy.emit();
    for (var r2 in this.runners) {
      this.runners[r2].destroy();
    }
    _super.prototype.destroy.call(this, removeView);
    this.gl = null;
  };
  Object.defineProperty(Renderer2.prototype, "extract", {
    get: function() {
      deprecation("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.");
      return this.plugins.extract;
    },
    enumerable: false,
    configurable: true
  });
  Renderer2.registerPlugin = function(pluginName, ctor) {
    deprecation("6.5.0", "Renderer.registerPlugin() has been deprecated, please use extensions.add() instead.");
    extensions.add({
      name: pluginName,
      type: ExtensionType.RendererPlugin,
      ref: ctor
    });
  };
  Renderer2.__plugins = {};
  return Renderer2;
}(AbstractRenderer);
extensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
function autoDetectRenderer(options) {
  return Renderer.create(options);
}
var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
var defaultVertex$1 = $defaultVertex;
var defaultFilterVertex = $defaultFilterVertex;
var BatchDrawCall = function() {
  function BatchDrawCall2() {
    this.texArray = null;
    this.blend = 0;
    this.type = DRAW_MODES.TRIANGLES;
    this.start = 0;
    this.size = 0;
    this.data = null;
  }
  return BatchDrawCall2;
}();
var BatchTextureArray = function() {
  function BatchTextureArray2() {
    this.elements = [];
    this.ids = [];
    this.count = 0;
  }
  BatchTextureArray2.prototype.clear = function() {
    for (var i = 0; i < this.count; i++) {
      this.elements[i] = null;
    }
    this.count = 0;
  };
  return BatchTextureArray2;
}();
var ViewableBuffer = function() {
  function ViewableBuffer2(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
  }
  Object.defineProperty(ViewableBuffer2.prototype, "int8View", {
    get: function() {
      if (!this._int8View) {
        this._int8View = new Int8Array(this.rawBinaryData);
      }
      return this._int8View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "uint8View", {
    get: function() {
      if (!this._uint8View) {
        this._uint8View = new Uint8Array(this.rawBinaryData);
      }
      return this._uint8View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "int16View", {
    get: function() {
      if (!this._int16View) {
        this._int16View = new Int16Array(this.rawBinaryData);
      }
      return this._int16View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "uint16View", {
    get: function() {
      if (!this._uint16View) {
        this._uint16View = new Uint16Array(this.rawBinaryData);
      }
      return this._uint16View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "int32View", {
    get: function() {
      if (!this._int32View) {
        this._int32View = new Int32Array(this.rawBinaryData);
      }
      return this._int32View;
    },
    enumerable: false,
    configurable: true
  });
  ViewableBuffer2.prototype.view = function(type2) {
    return this[type2 + "View"];
  };
  ViewableBuffer2.prototype.destroy = function() {
    this.rawBinaryData = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this._uint16View = null;
    this._int32View = null;
    this.uint32View = null;
    this.float32View = null;
  };
  ViewableBuffer2.sizeOf = function(type2) {
    switch (type2) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(type2 + " isn't a valid view type");
    }
  };
  return ViewableBuffer2;
}();
var AbstractBatchRenderer = function(_super) {
  __extends$i(AbstractBatchRenderer2, _super);
  function AbstractBatchRenderer2(renderer2) {
    var _this = _super.call(this, renderer2) || this;
    _this.shaderGenerator = null;
    _this.geometryClass = null;
    _this.vertexSize = null;
    _this.state = State.for2d();
    _this.size = settings.SPRITE_BATCH_SIZE * 4;
    _this._vertexCount = 0;
    _this._indexCount = 0;
    _this._bufferedElements = [];
    _this._bufferedTextures = [];
    _this._bufferSize = 0;
    _this._shader = null;
    _this._packedGeometries = [];
    _this._packedGeometryPoolSize = 2;
    _this._flushId = 0;
    _this._aBuffers = {};
    _this._iBuffers = {};
    _this.MAX_TEXTURES = 1;
    _this.renderer.on("prerender", _this.onPrerender, _this);
    renderer2.runners.contextChange.add(_this);
    _this._dcIndex = 0;
    _this._aIndex = 0;
    _this._iIndex = 0;
    _this._attributeBuffer = null;
    _this._indexBuffer = null;
    _this._tempBoundTextures = [];
    return _this;
  }
  AbstractBatchRenderer2.prototype.contextChange = function() {
    var gl = this.renderer.gl;
    if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
      this.MAX_TEXTURES = 1;
    } else {
      this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);
      this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
    }
    this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
    for (var i = 0; i < this._packedGeometryPoolSize; i++) {
      this._packedGeometries[i] = new this.geometryClass();
    }
    this.initFlushBuffers();
  };
  AbstractBatchRenderer2.prototype.initFlushBuffers = function() {
    var _drawCallPool = AbstractBatchRenderer2._drawCallPool, _textureArrayPool = AbstractBatchRenderer2._textureArrayPool;
    var MAX_SPRITES = this.size / 4;
    var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;
    while (_drawCallPool.length < MAX_SPRITES) {
      _drawCallPool.push(new BatchDrawCall());
    }
    while (_textureArrayPool.length < MAX_TA) {
      _textureArrayPool.push(new BatchTextureArray());
    }
    for (var i = 0; i < this.MAX_TEXTURES; i++) {
      this._tempBoundTextures[i] = null;
    }
  };
  AbstractBatchRenderer2.prototype.onPrerender = function() {
    this._flushId = 0;
  };
  AbstractBatchRenderer2.prototype.render = function(element) {
    if (!element._texture.valid) {
      return;
    }
    if (this._vertexCount + element.vertexData.length / 2 > this.size) {
      this.flush();
    }
    this._vertexCount += element.vertexData.length / 2;
    this._indexCount += element.indices.length;
    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
    this._bufferedElements[this._bufferSize++] = element;
  };
  AbstractBatchRenderer2.prototype.buildTexturesAndDrawCalls = function() {
    var _a2 = this, textures = _a2._bufferedTextures, MAX_TEXTURES = _a2.MAX_TEXTURES;
    var textureArrays = AbstractBatchRenderer2._textureArrayPool;
    var batch = this.renderer.batch;
    var boundTextures = this._tempBoundTextures;
    var touch = this.renderer.textureGC.count;
    var TICK = ++BaseTexture._globalBatch;
    var countTexArrays = 0;
    var texArray = textureArrays[0];
    var start = 0;
    batch.copyBoundTextures(boundTextures, MAX_TEXTURES);
    for (var i = 0; i < this._bufferSize; ++i) {
      var tex = textures[i];
      textures[i] = null;
      if (tex._batchEnabled === TICK) {
        continue;
      }
      if (texArray.count >= MAX_TEXTURES) {
        batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
        this.buildDrawCalls(texArray, start, i);
        start = i;
        texArray = textureArrays[++countTexArrays];
        ++TICK;
      }
      tex._batchEnabled = TICK;
      tex.touched = touch;
      texArray.elements[texArray.count++] = tex;
    }
    if (texArray.count > 0) {
      batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
      this.buildDrawCalls(texArray, start, this._bufferSize);
      ++countTexArrays;
      ++TICK;
    }
    for (var i = 0; i < boundTextures.length; i++) {
      boundTextures[i] = null;
    }
    BaseTexture._globalBatch = TICK;
  };
  AbstractBatchRenderer2.prototype.buildDrawCalls = function(texArray, start, finish) {
    var _a2 = this, elements = _a2._bufferedElements, _attributeBuffer = _a2._attributeBuffer, _indexBuffer = _a2._indexBuffer, vertexSize = _a2.vertexSize;
    var drawCalls = AbstractBatchRenderer2._drawCallPool;
    var dcIndex = this._dcIndex;
    var aIndex = this._aIndex;
    var iIndex = this._iIndex;
    var drawCall = drawCalls[dcIndex];
    drawCall.start = this._iIndex;
    drawCall.texArray = texArray;
    for (var i = start; i < finish; ++i) {
      var sprite = elements[i];
      var tex = sprite._texture.baseTexture;
      var spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
      elements[i] = null;
      if (start < i && drawCall.blend !== spriteBlendMode) {
        drawCall.size = iIndex - drawCall.start;
        start = i;
        drawCall = drawCalls[++dcIndex];
        drawCall.texArray = texArray;
        drawCall.start = iIndex;
      }
      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
      aIndex += sprite.vertexData.length / 2 * vertexSize;
      iIndex += sprite.indices.length;
      drawCall.blend = spriteBlendMode;
    }
    if (start < finish) {
      drawCall.size = iIndex - drawCall.start;
      ++dcIndex;
    }
    this._dcIndex = dcIndex;
    this._aIndex = aIndex;
    this._iIndex = iIndex;
  };
  AbstractBatchRenderer2.prototype.bindAndClearTexArray = function(texArray) {
    var textureSystem = this.renderer.texture;
    for (var j2 = 0; j2 < texArray.count; j2++) {
      textureSystem.bind(texArray.elements[j2], texArray.ids[j2]);
      texArray.elements[j2] = null;
    }
    texArray.count = 0;
  };
  AbstractBatchRenderer2.prototype.updateGeometry = function() {
    var _a2 = this, packedGeometries = _a2._packedGeometries, attributeBuffer = _a2._attributeBuffer, indexBuffer = _a2._indexBuffer;
    if (!settings.CAN_UPLOAD_SAME_BUFFER) {
      if (this._packedGeometryPoolSize <= this._flushId) {
        this._packedGeometryPoolSize++;
        packedGeometries[this._flushId] = new this.geometryClass();
      }
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.bind(packedGeometries[this._flushId]);
      this.renderer.geometry.updateBuffers();
      this._flushId++;
    } else {
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.updateBuffers();
    }
  };
  AbstractBatchRenderer2.prototype.drawBatches = function() {
    var dcCount = this._dcIndex;
    var _a2 = this.renderer, gl = _a2.gl, stateSystem = _a2.state;
    var drawCalls = AbstractBatchRenderer2._drawCallPool;
    var curTexArray = null;
    for (var i = 0; i < dcCount; i++) {
      var _b2 = drawCalls[i], texArray = _b2.texArray, type2 = _b2.type, size = _b2.size, start = _b2.start, blend = _b2.blend;
      if (curTexArray !== texArray) {
        curTexArray = texArray;
        this.bindAndClearTexArray(texArray);
      }
      this.state.blendMode = blend;
      stateSystem.set(this.state);
      gl.drawElements(type2, size, gl.UNSIGNED_SHORT, start * 2);
    }
  };
  AbstractBatchRenderer2.prototype.flush = function() {
    if (this._vertexCount === 0) {
      return;
    }
    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
    this._indexBuffer = this.getIndexBuffer(this._indexCount);
    this._aIndex = 0;
    this._iIndex = 0;
    this._dcIndex = 0;
    this.buildTexturesAndDrawCalls();
    this.updateGeometry();
    this.drawBatches();
    this._bufferSize = 0;
    this._vertexCount = 0;
    this._indexCount = 0;
  };
  AbstractBatchRenderer2.prototype.start = function() {
    this.renderer.state.set(this.state);
    this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES);
    this.renderer.shader.bind(this._shader);
    if (settings.CAN_UPLOAD_SAME_BUFFER) {
      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }
  };
  AbstractBatchRenderer2.prototype.stop = function() {
    this.flush();
  };
  AbstractBatchRenderer2.prototype.destroy = function() {
    for (var i = 0; i < this._packedGeometryPoolSize; i++) {
      if (this._packedGeometries[i]) {
        this._packedGeometries[i].destroy();
      }
    }
    this.renderer.off("prerender", this.onPrerender, this);
    this._aBuffers = null;
    this._iBuffers = null;
    this._packedGeometries = null;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    if (this._shader) {
      this._shader.destroy();
      this._shader = null;
    }
    _super.prototype.destroy.call(this);
  };
  AbstractBatchRenderer2.prototype.getAttributeBuffer = function(size) {
    var roundedP2 = nextPow2(Math.ceil(size / 8));
    var roundedSizeIndex = log2(roundedP2);
    var roundedSize = roundedP2 * 8;
    if (this._aBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    var buffer = this._aBuffers[roundedSize];
    if (!buffer) {
      this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
    }
    return buffer;
  };
  AbstractBatchRenderer2.prototype.getIndexBuffer = function(size) {
    var roundedP2 = nextPow2(Math.ceil(size / 12));
    var roundedSizeIndex = log2(roundedP2);
    var roundedSize = roundedP2 * 12;
    if (this._iBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    var buffer = this._iBuffers[roundedSizeIndex];
    if (!buffer) {
      this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
    }
    return buffer;
  };
  AbstractBatchRenderer2.prototype.packInterleavedGeometry = function(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
    var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
    var packedVertices = aIndex / this.vertexSize;
    var uvs = element.uvs;
    var indicies = element.indices;
    var vertexData = element.vertexData;
    var textureId = element._texture.baseTexture._batchLocation;
    var alpha = Math.min(element.worldAlpha, 1);
    var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);
    for (var i = 0; i < vertexData.length; i += 2) {
      float32View[aIndex++] = vertexData[i];
      float32View[aIndex++] = vertexData[i + 1];
      float32View[aIndex++] = uvs[i];
      float32View[aIndex++] = uvs[i + 1];
      uint32View[aIndex++] = argb;
      float32View[aIndex++] = textureId;
    }
    for (var i = 0; i < indicies.length; i++) {
      indexBuffer[iIndex++] = packedVertices + indicies[i];
    }
  };
  AbstractBatchRenderer2._drawCallPool = [];
  AbstractBatchRenderer2._textureArrayPool = [];
  return AbstractBatchRenderer2;
}(ObjectRenderer);
var BatchShaderGenerator = function() {
  function BatchShaderGenerator2(vertexSrc, fragTemplate2) {
    this.vertexSrc = vertexSrc;
    this.fragTemplate = fragTemplate2;
    this.programCache = {};
    this.defaultGroupCache = {};
    if (fragTemplate2.indexOf("%count%") < 0) {
      throw new Error('Fragment template must contain "%count%".');
    }
    if (fragTemplate2.indexOf("%forloop%") < 0) {
      throw new Error('Fragment template must contain "%forloop%".');
    }
  }
  BatchShaderGenerator2.prototype.generateShader = function(maxTextures) {
    if (!this.programCache[maxTextures]) {
      var sampleValues = new Int32Array(maxTextures);
      for (var i = 0; i < maxTextures; i++) {
        sampleValues[i] = i;
      }
      this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
      var fragmentSrc = this.fragTemplate;
      fragmentSrc = fragmentSrc.replace(/%count%/gi, "" + maxTextures);
      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
      this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
    }
    var uniforms = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new Matrix(),
      default: this.defaultGroupCache[maxTextures]
    };
    return new Shader(this.programCache[maxTextures], uniforms);
  };
  BatchShaderGenerator2.prototype.generateSampleSrc = function(maxTextures) {
    var src = "";
    src += "\n";
    src += "\n";
    for (var i = 0; i < maxTextures; i++) {
      if (i > 0) {
        src += "\nelse ";
      }
      if (i < maxTextures - 1) {
        src += "if(vTextureId < " + i + ".5)";
      }
      src += "\n{";
      src += "\n	color = texture2D(uSamplers[" + i + "], vTextureCoord);";
      src += "\n}";
    }
    src += "\n";
    src += "\n";
    return src;
  };
  return BatchShaderGenerator2;
}();
var BatchGeometry = function(_super) {
  __extends$i(BatchGeometry2, _super);
  function BatchGeometry2(_static) {
    if (_static === void 0) {
      _static = false;
    }
    var _this = _super.call(this) || this;
    _this._buffer = new Buffer(null, _static, false);
    _this._indexBuffer = new Buffer(null, _static, true);
    _this.addAttribute("aVertexPosition", _this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", _this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", _this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", _this._buffer, 1, true, TYPES.FLOAT).addIndex(_this._indexBuffer);
    return _this;
  }
  return BatchGeometry2;
}(Geometry);
var defaultVertex = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
var defaultFragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
var BatchPluginFactory = function() {
  function BatchPluginFactory2() {
  }
  BatchPluginFactory2.create = function(options) {
    var _a2 = Object.assign({
      vertex: defaultVertex,
      fragment: defaultFragment,
      geometryClass: BatchGeometry,
      vertexSize: 6
    }, options), vertex2 = _a2.vertex, fragment2 = _a2.fragment, vertexSize = _a2.vertexSize, geometryClass = _a2.geometryClass;
    return function(_super) {
      __extends$i(BatchPlugin, _super);
      function BatchPlugin(renderer2) {
        var _this = _super.call(this, renderer2) || this;
        _this.shaderGenerator = new BatchShaderGenerator(vertex2, fragment2);
        _this.geometryClass = geometryClass;
        _this.vertexSize = vertexSize;
        return _this;
      }
      return BatchPlugin;
    }(AbstractBatchRenderer);
  };
  Object.defineProperty(BatchPluginFactory2, "defaultVertexSrc", {
    get: function() {
      return defaultVertex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BatchPluginFactory2, "defaultFragmentTemplate", {
    get: function() {
      return defaultFragment;
    },
    enumerable: false,
    configurable: true
  });
  return BatchPluginFactory2;
}();
var BatchRenderer = BatchPluginFactory.create();
Object.assign(BatchRenderer, {
  extension: {
    name: "batch",
    type: ExtensionType.RendererPlugin
  }
});
/*!
 * @pixi/accessibility - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var accessibleTarget = {
  accessible: false,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  _accessibleActive: false,
  _accessibleDiv: null,
  accessibleType: "button",
  accessiblePointerEvents: "auto",
  accessibleChildren: true,
  renderId: -1
};
DisplayObject.mixin(accessibleTarget);
var KEY_CODE_TAB = 9;
var DIV_TOUCH_SIZE = 100;
var DIV_TOUCH_POS_X = 0;
var DIV_TOUCH_POS_Y = 0;
var DIV_TOUCH_ZINDEX = 2;
var DIV_HOOK_SIZE = 1;
var DIV_HOOK_POS_X = -1e3;
var DIV_HOOK_POS_Y = -1e3;
var DIV_HOOK_ZINDEX = 2;
var AccessibilityManager = function() {
  function AccessibilityManager2(renderer2) {
    this.debug = false;
    this._isActive = false;
    this._isMobileAccessibility = false;
    this.pool = [];
    this.renderId = 0;
    this.children = [];
    this.androidUpdateCount = 0;
    this.androidUpdateFrequency = 500;
    this._hookDiv = null;
    if (isMobile.tablet || isMobile.phone) {
      this.createTouchHook();
    }
    var div = document.createElement("div");
    div.style.width = DIV_TOUCH_SIZE + "px";
    div.style.height = DIV_TOUCH_SIZE + "px";
    div.style.position = "absolute";
    div.style.top = DIV_TOUCH_POS_X + "px";
    div.style.left = DIV_TOUCH_POS_Y + "px";
    div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
    this.div = div;
    this.renderer = renderer2;
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onMouseMove = this._onMouseMove.bind(this);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
  }
  Object.defineProperty(AccessibilityManager2.prototype, "isActive", {
    get: function() {
      return this._isActive;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AccessibilityManager2.prototype, "isMobileAccessibility", {
    get: function() {
      return this._isMobileAccessibility;
    },
    enumerable: false,
    configurable: true
  });
  AccessibilityManager2.prototype.createTouchHook = function() {
    var _this = this;
    var hookDiv = document.createElement("button");
    hookDiv.style.width = DIV_HOOK_SIZE + "px";
    hookDiv.style.height = DIV_HOOK_SIZE + "px";
    hookDiv.style.position = "absolute";
    hookDiv.style.top = DIV_HOOK_POS_X + "px";
    hookDiv.style.left = DIV_HOOK_POS_Y + "px";
    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
    hookDiv.style.backgroundColor = "#FF0000";
    hookDiv.title = "select to enable accessibility for this content";
    hookDiv.addEventListener("focus", function() {
      _this._isMobileAccessibility = true;
      _this.activate();
      _this.destroyTouchHook();
    });
    document.body.appendChild(hookDiv);
    this._hookDiv = hookDiv;
  };
  AccessibilityManager2.prototype.destroyTouchHook = function() {
    if (!this._hookDiv) {
      return;
    }
    document.body.removeChild(this._hookDiv);
    this._hookDiv = null;
  };
  AccessibilityManager2.prototype.activate = function() {
    var _a2;
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown, false);
    this.renderer.on("postrender", this.update, this);
    (_a2 = this.renderer.view.parentNode) === null || _a2 === void 0 ? void 0 : _a2.appendChild(this.div);
  };
  AccessibilityManager2.prototype.deactivate = function() {
    var _a2;
    if (!this._isActive || this._isMobileAccessibility) {
      return;
    }
    this._isActive = false;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
    this.renderer.off("postrender", this.update);
    (_a2 = this.div.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.div);
  };
  AccessibilityManager2.prototype.updateAccessibleObjects = function(displayObject) {
    if (!displayObject.visible || !displayObject.accessibleChildren) {
      return;
    }
    if (displayObject.accessible && displayObject.interactive) {
      if (!displayObject._accessibleActive) {
        this.addChild(displayObject);
      }
      displayObject.renderId = this.renderId;
    }
    var children = displayObject.children;
    if (children) {
      for (var i = 0; i < children.length; i++) {
        this.updateAccessibleObjects(children[i]);
      }
    }
  };
  AccessibilityManager2.prototype.update = function() {
    var now = performance.now();
    if (isMobile.android.device && now < this.androidUpdateCount) {
      return;
    }
    this.androidUpdateCount = now + this.androidUpdateFrequency;
    if (!this.renderer.renderingToScreen) {
      return;
    }
    if (this.renderer._lastObjectRendered) {
      this.updateAccessibleObjects(this.renderer._lastObjectRendered);
    }
    var _a2 = this.renderer.view.getBoundingClientRect(), left = _a2.left, top = _a2.top, width = _a2.width, height = _a2.height;
    var _b2 = this.renderer, viewWidth = _b2.width, viewHeight = _b2.height, resolution = _b2.resolution;
    var sx = width / viewWidth * resolution;
    var sy = height / viewHeight * resolution;
    var div = this.div;
    div.style.left = left + "px";
    div.style.top = top + "px";
    div.style.width = viewWidth + "px";
    div.style.height = viewHeight + "px";
    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];
      if (child.renderId !== this.renderId) {
        child._accessibleActive = false;
        removeItems(this.children, i, 1);
        this.div.removeChild(child._accessibleDiv);
        this.pool.push(child._accessibleDiv);
        child._accessibleDiv = null;
        i--;
      } else {
        div = child._accessibleDiv;
        var hitArea = child.hitArea;
        var wt = child.worldTransform;
        if (child.hitArea) {
          div.style.left = (wt.tx + hitArea.x * wt.a) * sx + "px";
          div.style.top = (wt.ty + hitArea.y * wt.d) * sy + "px";
          div.style.width = hitArea.width * wt.a * sx + "px";
          div.style.height = hitArea.height * wt.d * sy + "px";
        } else {
          hitArea = child.getBounds();
          this.capHitArea(hitArea);
          div.style.left = hitArea.x * sx + "px";
          div.style.top = hitArea.y * sy + "px";
          div.style.width = hitArea.width * sx + "px";
          div.style.height = hitArea.height * sy + "px";
          if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
            div.title = child.accessibleTitle;
          }
          if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
            div.setAttribute("aria-label", child.accessibleHint);
          }
        }
        if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
          div.title = child.accessibleTitle;
          div.tabIndex = child.tabIndex;
          if (this.debug) {
            this.updateDebugHTML(div);
          }
        }
      }
    }
    this.renderId++;
  };
  AccessibilityManager2.prototype.updateDebugHTML = function(div) {
    div.innerHTML = "type: " + div.type + "</br> title : " + div.title + "</br> tabIndex: " + div.tabIndex;
  };
  AccessibilityManager2.prototype.capHitArea = function(hitArea) {
    if (hitArea.x < 0) {
      hitArea.width += hitArea.x;
      hitArea.x = 0;
    }
    if (hitArea.y < 0) {
      hitArea.height += hitArea.y;
      hitArea.y = 0;
    }
    var _a2 = this.renderer, viewWidth = _a2.width, viewHeight = _a2.height;
    if (hitArea.x + hitArea.width > viewWidth) {
      hitArea.width = viewWidth - hitArea.x;
    }
    if (hitArea.y + hitArea.height > viewHeight) {
      hitArea.height = viewHeight - hitArea.y;
    }
  };
  AccessibilityManager2.prototype.addChild = function(displayObject) {
    var div = this.pool.pop();
    if (!div) {
      div = document.createElement("button");
      div.style.width = DIV_TOUCH_SIZE + "px";
      div.style.height = DIV_TOUCH_SIZE + "px";
      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
      div.style.position = "absolute";
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      div.style.borderStyle = "none";
      if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
        div.setAttribute("aria-live", "off");
      } else {
        div.setAttribute("aria-live", "polite");
      }
      if (navigator.userAgent.match(/rv:.*Gecko\//)) {
        div.setAttribute("aria-relevant", "additions");
      } else {
        div.setAttribute("aria-relevant", "text");
      }
      div.addEventListener("click", this._onClick.bind(this));
      div.addEventListener("focus", this._onFocus.bind(this));
      div.addEventListener("focusout", this._onFocusOut.bind(this));
    }
    div.style.pointerEvents = displayObject.accessiblePointerEvents;
    div.type = displayObject.accessibleType;
    if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
      div.title = displayObject.accessibleTitle;
    } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
      div.title = "displayObject " + displayObject.tabIndex;
    }
    if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
      div.setAttribute("aria-label", displayObject.accessibleHint);
    }
    if (this.debug) {
      this.updateDebugHTML(div);
    }
    displayObject._accessibleActive = true;
    displayObject._accessibleDiv = div;
    div.displayObject = displayObject;
    this.children.push(displayObject);
    this.div.appendChild(displayObject._accessibleDiv);
    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
  };
  AccessibilityManager2.prototype._onClick = function(e2) {
    var interactionManager = this.renderer.plugins.interaction;
    var displayObject = e2.target.displayObject;
    var eventData = interactionManager.eventData;
    interactionManager.dispatchEvent(displayObject, "click", eventData);
    interactionManager.dispatchEvent(displayObject, "pointertap", eventData);
    interactionManager.dispatchEvent(displayObject, "tap", eventData);
  };
  AccessibilityManager2.prototype._onFocus = function(e2) {
    if (!e2.target.getAttribute("aria-live")) {
      e2.target.setAttribute("aria-live", "assertive");
    }
    var interactionManager = this.renderer.plugins.interaction;
    var displayObject = e2.target.displayObject;
    var eventData = interactionManager.eventData;
    interactionManager.dispatchEvent(displayObject, "mouseover", eventData);
  };
  AccessibilityManager2.prototype._onFocusOut = function(e2) {
    if (!e2.target.getAttribute("aria-live")) {
      e2.target.setAttribute("aria-live", "polite");
    }
    var interactionManager = this.renderer.plugins.interaction;
    var displayObject = e2.target.displayObject;
    var eventData = interactionManager.eventData;
    interactionManager.dispatchEvent(displayObject, "mouseout", eventData);
  };
  AccessibilityManager2.prototype._onKeyDown = function(e2) {
    if (e2.keyCode !== KEY_CODE_TAB) {
      return;
    }
    this.activate();
  };
  AccessibilityManager2.prototype._onMouseMove = function(e2) {
    if (e2.movementX === 0 && e2.movementY === 0) {
      return;
    }
    this.deactivate();
  };
  AccessibilityManager2.prototype.destroy = function() {
    this.destroyTouchHook();
    this.div = null;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown);
    this.pool = null;
    this.children = null;
    this.renderer = null;
  };
  AccessibilityManager2.extension = {
    name: "accessibility",
    type: [
      ExtensionType.RendererPlugin,
      ExtensionType.CanvasRendererPlugin
    ]
  };
  return AccessibilityManager2;
}();
/*!
 * @pixi/interaction - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var InteractionData = function() {
  function InteractionData2() {
    this.pressure = 0;
    this.rotationAngle = 0;
    this.twist = 0;
    this.tangentialPressure = 0;
    this.global = new Point();
    this.target = null;
    this.originalEvent = null;
    this.identifier = null;
    this.isPrimary = false;
    this.button = 0;
    this.buttons = 0;
    this.width = 0;
    this.height = 0;
    this.tiltX = 0;
    this.tiltY = 0;
    this.pointerType = null;
    this.pressure = 0;
    this.rotationAngle = 0;
    this.twist = 0;
    this.tangentialPressure = 0;
  }
  Object.defineProperty(InteractionData2.prototype, "pointerId", {
    get: function() {
      return this.identifier;
    },
    enumerable: false,
    configurable: true
  });
  InteractionData2.prototype.getLocalPosition = function(displayObject, point, globalPos) {
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
  };
  InteractionData2.prototype.copyEvent = function(event) {
    if ("isPrimary" in event && event.isPrimary) {
      this.isPrimary = true;
    }
    this.button = "button" in event && event.button;
    var buttons = "buttons" in event && event.buttons;
    this.buttons = Number.isInteger(buttons) ? buttons : "which" in event && event.which;
    this.width = "width" in event && event.width;
    this.height = "height" in event && event.height;
    this.tiltX = "tiltX" in event && event.tiltX;
    this.tiltY = "tiltY" in event && event.tiltY;
    this.pointerType = "pointerType" in event && event.pointerType;
    this.pressure = "pressure" in event && event.pressure;
    this.rotationAngle = "rotationAngle" in event && event.rotationAngle;
    this.twist = "twist" in event && event.twist || 0;
    this.tangentialPressure = "tangentialPressure" in event && event.tangentialPressure || 0;
  };
  InteractionData2.prototype.reset = function() {
    this.isPrimary = false;
  };
  return InteractionData2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$h = function(d2, b2) {
  extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$h(d2, b2);
};
function __extends$h(d2, b2) {
  extendStatics$h(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var InteractionEvent = function() {
  function InteractionEvent2() {
    this.stopped = false;
    this.stopsPropagatingAt = null;
    this.stopPropagationHint = false;
    this.target = null;
    this.currentTarget = null;
    this.type = null;
    this.data = null;
  }
  InteractionEvent2.prototype.stopPropagation = function() {
    this.stopped = true;
    this.stopPropagationHint = true;
    this.stopsPropagatingAt = this.currentTarget;
  };
  InteractionEvent2.prototype.reset = function() {
    this.stopped = false;
    this.stopsPropagatingAt = null;
    this.stopPropagationHint = false;
    this.currentTarget = null;
    this.target = null;
  };
  return InteractionEvent2;
}();
var InteractionTrackingData = function() {
  function InteractionTrackingData2(pointerId) {
    this._pointerId = pointerId;
    this._flags = InteractionTrackingData2.FLAGS.NONE;
  }
  InteractionTrackingData2.prototype._doSet = function(flag, yn) {
    if (yn) {
      this._flags = this._flags | flag;
    } else {
      this._flags = this._flags & ~flag;
    }
  };
  Object.defineProperty(InteractionTrackingData2.prototype, "pointerId", {
    get: function() {
      return this._pointerId;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "flags", {
    get: function() {
      return this._flags;
    },
    set: function(flags) {
      this._flags = flags;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "none", {
    get: function() {
      return this._flags === InteractionTrackingData2.FLAGS.NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "over", {
    get: function() {
      return (this._flags & InteractionTrackingData2.FLAGS.OVER) !== 0;
    },
    set: function(yn) {
      this._doSet(InteractionTrackingData2.FLAGS.OVER, yn);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "rightDown", {
    get: function() {
      return (this._flags & InteractionTrackingData2.FLAGS.RIGHT_DOWN) !== 0;
    },
    set: function(yn) {
      this._doSet(InteractionTrackingData2.FLAGS.RIGHT_DOWN, yn);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "leftDown", {
    get: function() {
      return (this._flags & InteractionTrackingData2.FLAGS.LEFT_DOWN) !== 0;
    },
    set: function(yn) {
      this._doSet(InteractionTrackingData2.FLAGS.LEFT_DOWN, yn);
    },
    enumerable: false,
    configurable: true
  });
  InteractionTrackingData2.FLAGS = Object.freeze({
    NONE: 0,
    OVER: 1 << 0,
    LEFT_DOWN: 1 << 1,
    RIGHT_DOWN: 1 << 2
  });
  return InteractionTrackingData2;
}();
var TreeSearch = function() {
  function TreeSearch2() {
    this._tempPoint = new Point();
  }
  TreeSearch2.prototype.recursiveFindHit = function(interactionEvent, displayObject, func, hitTest, interactive) {
    var _a2;
    if (!displayObject || !displayObject.visible) {
      return false;
    }
    var point = interactionEvent.data.global;
    interactive = displayObject.interactive || interactive;
    var hit = false;
    var interactiveParent = interactive;
    var hitTestChildren = true;
    if (displayObject.hitArea) {
      if (hitTest) {
        displayObject.worldTransform.applyInverse(point, this._tempPoint);
        if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
          hitTest = false;
          hitTestChildren = false;
        } else {
          hit = true;
        }
      }
      interactiveParent = false;
    } else if (displayObject._mask) {
      if (hitTest) {
        var maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;
        if (maskObject && !((_a2 = maskObject.containsPoint) === null || _a2 === void 0 ? void 0 : _a2.call(maskObject, point))) {
          hitTest = false;
        }
      }
    }
    if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {
      var children = displayObject.children;
      for (var i = children.length - 1; i >= 0; i--) {
        var child = children[i];
        var childHit = this.recursiveFindHit(interactionEvent, child, func, hitTest, interactiveParent);
        if (childHit) {
          if (!child.parent) {
            continue;
          }
          interactiveParent = false;
          if (childHit) {
            if (interactionEvent.target) {
              hitTest = false;
            }
            hit = true;
          }
        }
      }
    }
    if (interactive) {
      if (hitTest && !interactionEvent.target) {
        if (!displayObject.hitArea && displayObject.containsPoint) {
          if (displayObject.containsPoint(point)) {
            hit = true;
          }
        }
      }
      if (displayObject.interactive) {
        if (hit && !interactionEvent.target) {
          interactionEvent.target = displayObject;
        }
        if (func) {
          func(interactionEvent, displayObject, !!hit);
        }
      }
    }
    return hit;
  };
  TreeSearch2.prototype.findHit = function(interactionEvent, displayObject, func, hitTest) {
    this.recursiveFindHit(interactionEvent, displayObject, func, hitTest, false);
  };
  return TreeSearch2;
}();
var interactiveTarget = {
  interactive: false,
  interactiveChildren: true,
  hitArea: null,
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(value) {
    if (value) {
      this.cursor = "pointer";
    } else if (this.cursor === "pointer") {
      this.cursor = null;
    }
  },
  cursor: null,
  get trackedPointers() {
    if (this._trackedPointers === void 0) {
      this._trackedPointers = {};
    }
    return this._trackedPointers;
  },
  _trackedPointers: void 0
};
DisplayObject.mixin(interactiveTarget);
var MOUSE_POINTER_ID = 1;
var hitTestEvent = {
  target: null,
  data: {
    global: null
  }
};
var InteractionManager = function(_super) {
  __extends$h(InteractionManager2, _super);
  function InteractionManager2(renderer2, options) {
    var _this = _super.call(this) || this;
    options = options || {};
    _this.renderer = renderer2;
    _this.autoPreventDefault = options.autoPreventDefault !== void 0 ? options.autoPreventDefault : true;
    _this.interactionFrequency = options.interactionFrequency || 10;
    _this.mouse = new InteractionData();
    _this.mouse.identifier = MOUSE_POINTER_ID;
    _this.mouse.global.set(-999999);
    _this.activeInteractionData = {};
    _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;
    _this.interactionDataPool = [];
    _this.eventData = new InteractionEvent();
    _this.interactionDOMElement = null;
    _this.moveWhenInside = false;
    _this.eventsAdded = false;
    _this.tickerAdded = false;
    _this.mouseOverRenderer = !("PointerEvent" in globalThis);
    _this.supportsTouchEvents = "ontouchstart" in globalThis;
    _this.supportsPointerEvents = !!globalThis.PointerEvent;
    _this.onPointerUp = _this.onPointerUp.bind(_this);
    _this.processPointerUp = _this.processPointerUp.bind(_this);
    _this.onPointerCancel = _this.onPointerCancel.bind(_this);
    _this.processPointerCancel = _this.processPointerCancel.bind(_this);
    _this.onPointerDown = _this.onPointerDown.bind(_this);
    _this.processPointerDown = _this.processPointerDown.bind(_this);
    _this.onPointerMove = _this.onPointerMove.bind(_this);
    _this.processPointerMove = _this.processPointerMove.bind(_this);
    _this.onPointerOut = _this.onPointerOut.bind(_this);
    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
    _this.onPointerOver = _this.onPointerOver.bind(_this);
    _this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    _this.currentCursorMode = null;
    _this.cursor = null;
    _this.resolution = 1;
    _this.delayedEvents = [];
    _this.search = new TreeSearch();
    _this._tempDisplayObject = new TemporaryDisplayObject();
    _this._eventListenerOptions = { capture: true, passive: false };
    _this._useSystemTicker = options.useSystemTicker !== void 0 ? options.useSystemTicker : true;
    _this.setTargetElement(_this.renderer.view, _this.renderer.resolution);
    return _this;
  }
  Object.defineProperty(InteractionManager2.prototype, "useSystemTicker", {
    get: function() {
      return this._useSystemTicker;
    },
    set: function(useSystemTicker) {
      this._useSystemTicker = useSystemTicker;
      if (useSystemTicker) {
        this.addTickerListener();
      } else {
        this.removeTickerListener();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionManager2.prototype, "lastObjectRendered", {
    get: function() {
      return this.renderer._lastObjectRendered || this._tempDisplayObject;
    },
    enumerable: false,
    configurable: true
  });
  InteractionManager2.prototype.hitTest = function(globalPoint, root2) {
    hitTestEvent.target = null;
    hitTestEvent.data.global = globalPoint;
    if (!root2) {
      root2 = this.lastObjectRendered;
    }
    this.processInteractive(hitTestEvent, root2, null, true);
    return hitTestEvent.target;
  };
  InteractionManager2.prototype.setTargetElement = function(element, resolution) {
    if (resolution === void 0) {
      resolution = 1;
    }
    this.removeTickerListener();
    this.removeEvents();
    this.interactionDOMElement = element;
    this.resolution = resolution;
    this.addEvents();
    this.addTickerListener();
  };
  InteractionManager2.prototype.addTickerListener = function() {
    if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker) {
      return;
    }
    Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
    this.tickerAdded = true;
  };
  InteractionManager2.prototype.removeTickerListener = function() {
    if (!this.tickerAdded) {
      return;
    }
    Ticker.system.remove(this.tickerUpdate, this);
    this.tickerAdded = false;
  };
  InteractionManager2.prototype.addEvents = function() {
    if (this.eventsAdded || !this.interactionDOMElement) {
      return;
    }
    var style = this.interactionDOMElement.style;
    if (globalThis.navigator.msPointerEnabled) {
      style.msContentZooming = "none";
      style.msTouchAction = "none";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "none";
    }
    if (this.supportsPointerEvents) {
      globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions);
      globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions);
      globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions);
    } else {
      globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions);
      globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions);
    }
    if (this.supportsTouchEvents) {
      this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions);
    }
    this.eventsAdded = true;
  };
  InteractionManager2.prototype.removeEvents = function() {
    if (!this.eventsAdded || !this.interactionDOMElement) {
      return;
    }
    var style = this.interactionDOMElement.style;
    if (globalThis.navigator.msPointerEnabled) {
      style.msContentZooming = "";
      style.msTouchAction = "";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "";
    }
    if (this.supportsPointerEvents) {
      globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions);
      globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions);
      globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions);
    } else {
      globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions);
      globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions);
    }
    if (this.supportsTouchEvents) {
      this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions);
    }
    this.interactionDOMElement = null;
    this.eventsAdded = false;
  };
  InteractionManager2.prototype.tickerUpdate = function(deltaTime) {
    this._deltaTime += deltaTime;
    if (this._deltaTime < this.interactionFrequency) {
      return;
    }
    this._deltaTime = 0;
    this.update();
  };
  InteractionManager2.prototype.update = function() {
    if (!this.interactionDOMElement) {
      return;
    }
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    this.cursor = null;
    for (var k2 in this.activeInteractionData) {
      if (this.activeInteractionData.hasOwnProperty(k2)) {
        var interactionData = this.activeInteractionData[k2];
        if (interactionData.originalEvent && interactionData.pointerType !== "touch") {
          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
          this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, true);
        }
      }
    }
    this.setCursorMode(this.cursor);
  };
  InteractionManager2.prototype.setCursorMode = function(mode) {
    mode = mode || "default";
    var applyStyles = true;
    if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas) {
      applyStyles = false;
    }
    if (this.currentCursorMode === mode) {
      return;
    }
    this.currentCursorMode = mode;
    var style = this.cursorStyles[mode];
    if (style) {
      switch (typeof style) {
        case "string":
          if (applyStyles) {
            this.interactionDOMElement.style.cursor = style;
          }
          break;
        case "function":
          style(mode);
          break;
        case "object":
          if (applyStyles) {
            Object.assign(this.interactionDOMElement.style, style);
          }
          break;
      }
    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
      this.interactionDOMElement.style.cursor = mode;
    }
  };
  InteractionManager2.prototype.dispatchEvent = function(displayObject, eventString, eventData) {
    if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt) {
      eventData.currentTarget = displayObject;
      eventData.type = eventString;
      displayObject.emit(eventString, eventData);
      if (displayObject[eventString]) {
        displayObject[eventString](eventData);
      }
    }
  };
  InteractionManager2.prototype.delayDispatchEvent = function(displayObject, eventString, eventData) {
    this.delayedEvents.push({ displayObject, eventString, eventData });
  };
  InteractionManager2.prototype.mapPositionToPoint = function(point, x2, y2) {
    var rect;
    if (!this.interactionDOMElement.parentElement) {
      rect = {
        x: 0,
        y: 0,
        width: this.interactionDOMElement.width,
        height: this.interactionDOMElement.height,
        left: 0,
        top: 0
      };
    } else {
      rect = this.interactionDOMElement.getBoundingClientRect();
    }
    var resolutionMultiplier = 1 / this.resolution;
    point.x = (x2 - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;
    point.y = (y2 - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;
  };
  InteractionManager2.prototype.processInteractive = function(interactionEvent, displayObject, func, hitTest) {
    var hit = this.search.findHit(interactionEvent, displayObject, func, hitTest);
    var delayedEvents = this.delayedEvents;
    if (!delayedEvents.length) {
      return hit;
    }
    interactionEvent.stopPropagationHint = false;
    var delayedLen = delayedEvents.length;
    this.delayedEvents = [];
    for (var i = 0; i < delayedLen; i++) {
      var _a2 = delayedEvents[i], displayObject_1 = _a2.displayObject, eventString = _a2.eventString, eventData = _a2.eventData;
      if (eventData.stopsPropagatingAt === displayObject_1) {
        eventData.stopPropagationHint = true;
      }
      this.dispatchEvent(displayObject_1, eventString, eventData);
    }
    return hit;
  };
  InteractionManager2.prototype.onPointerDown = function(originalEvent) {
    if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
      return;
    }
    var events2 = this.normalizeToPointerData(originalEvent);
    if (this.autoPreventDefault && events2[0].isNormalized) {
      var cancelable = originalEvent.cancelable || !("cancelable" in originalEvent);
      if (cancelable) {
        originalEvent.preventDefault();
      }
    }
    var eventLen = events2.length;
    for (var i = 0; i < eventLen; i++) {
      var event = events2[i];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerDown, true);
      this.emit("pointerdown", interactionEvent);
      if (event.pointerType === "touch") {
        this.emit("touchstart", interactionEvent);
      } else if (event.pointerType === "mouse" || event.pointerType === "pen") {
        var isRightButton = event.button === 2;
        this.emit(isRightButton ? "rightdown" : "mousedown", this.eventData);
      }
    }
  };
  InteractionManager2.prototype.processPointerDown = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    if (hit) {
      if (!displayObject.trackedPointers[id]) {
        displayObject.trackedPointers[id] = new InteractionTrackingData(id);
      }
      this.dispatchEvent(displayObject, "pointerdown", interactionEvent);
      if (data.pointerType === "touch") {
        this.dispatchEvent(displayObject, "touchstart", interactionEvent);
      } else if (data.pointerType === "mouse" || data.pointerType === "pen") {
        var isRightButton = data.button === 2;
        if (isRightButton) {
          displayObject.trackedPointers[id].rightDown = true;
        } else {
          displayObject.trackedPointers[id].leftDown = true;
        }
        this.dispatchEvent(displayObject, isRightButton ? "rightdown" : "mousedown", interactionEvent);
      }
    }
  };
  InteractionManager2.prototype.onPointerComplete = function(originalEvent, cancelled, func) {
    var events2 = this.normalizeToPointerData(originalEvent);
    var eventLen = events2.length;
    var target = originalEvent.target;
    if (originalEvent.composedPath && originalEvent.composedPath().length > 0) {
      target = originalEvent.composedPath()[0];
    }
    var eventAppend = target !== this.interactionDOMElement ? "outside" : "";
    for (var i = 0; i < eventLen; i++) {
      var event = events2[i];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.lastObjectRendered, func, cancelled || !eventAppend);
      this.emit(cancelled ? "pointercancel" : "pointerup" + eventAppend, interactionEvent);
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        var isRightButton = event.button === 2;
        this.emit(isRightButton ? "rightup" + eventAppend : "mouseup" + eventAppend, interactionEvent);
      } else if (event.pointerType === "touch") {
        this.emit(cancelled ? "touchcancel" : "touchend" + eventAppend, interactionEvent);
        this.releaseInteractionDataForPointerId(event.pointerId);
      }
    }
  };
  InteractionManager2.prototype.onPointerCancel = function(event) {
    if (this.supportsTouchEvents && event.pointerType === "touch") {
      return;
    }
    this.onPointerComplete(event, true, this.processPointerCancel);
  };
  InteractionManager2.prototype.processPointerCancel = function(interactionEvent, displayObject) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    if (displayObject.trackedPointers[id] !== void 0) {
      delete displayObject.trackedPointers[id];
      this.dispatchEvent(displayObject, "pointercancel", interactionEvent);
      if (data.pointerType === "touch") {
        this.dispatchEvent(displayObject, "touchcancel", interactionEvent);
      }
    }
  };
  InteractionManager2.prototype.onPointerUp = function(event) {
    if (this.supportsTouchEvents && event.pointerType === "touch") {
      return;
    }
    this.onPointerComplete(event, false, this.processPointerUp);
  };
  InteractionManager2.prototype.processPointerUp = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    var trackingData = displayObject.trackedPointers[id];
    var isTouch = data.pointerType === "touch";
    var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
    var isMouseTap = false;
    if (isMouse) {
      var isRightButton = data.button === 2;
      var flags = InteractionTrackingData.FLAGS;
      var test2 = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
      var isDown = trackingData !== void 0 && trackingData.flags & test2;
      if (hit) {
        this.dispatchEvent(displayObject, isRightButton ? "rightup" : "mouseup", interactionEvent);
        if (isDown) {
          this.dispatchEvent(displayObject, isRightButton ? "rightclick" : "click", interactionEvent);
          isMouseTap = true;
        }
      } else if (isDown) {
        this.dispatchEvent(displayObject, isRightButton ? "rightupoutside" : "mouseupoutside", interactionEvent);
      }
      if (trackingData) {
        if (isRightButton) {
          trackingData.rightDown = false;
        } else {
          trackingData.leftDown = false;
        }
      }
    }
    if (hit) {
      this.dispatchEvent(displayObject, "pointerup", interactionEvent);
      if (isTouch) {
        this.dispatchEvent(displayObject, "touchend", interactionEvent);
      }
      if (trackingData) {
        if (!isMouse || isMouseTap) {
          this.dispatchEvent(displayObject, "pointertap", interactionEvent);
        }
        if (isTouch) {
          this.dispatchEvent(displayObject, "tap", interactionEvent);
          trackingData.over = false;
        }
      }
    } else if (trackingData) {
      this.dispatchEvent(displayObject, "pointerupoutside", interactionEvent);
      if (isTouch) {
        this.dispatchEvent(displayObject, "touchendoutside", interactionEvent);
      }
    }
    if (trackingData && trackingData.none) {
      delete displayObject.trackedPointers[id];
    }
  };
  InteractionManager2.prototype.onPointerMove = function(originalEvent) {
    if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
      return;
    }
    var events2 = this.normalizeToPointerData(originalEvent);
    if (events2[0].pointerType === "mouse" || events2[0].pointerType === "pen") {
      this._didMove = true;
      this.cursor = null;
    }
    var eventLen = events2.length;
    for (var i = 0; i < eventLen; i++) {
      var event = events2[i];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerMove, true);
      this.emit("pointermove", interactionEvent);
      if (event.pointerType === "touch") {
        this.emit("touchmove", interactionEvent);
      }
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        this.emit("mousemove", interactionEvent);
      }
    }
    if (events2[0].pointerType === "mouse") {
      this.setCursorMode(this.cursor);
    }
  };
  InteractionManager2.prototype.processPointerMove = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var isTouch = data.pointerType === "touch";
    var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
    if (isMouse) {
      this.processPointerOverOut(interactionEvent, displayObject, hit);
    }
    if (!this.moveWhenInside || hit) {
      this.dispatchEvent(displayObject, "pointermove", interactionEvent);
      if (isTouch) {
        this.dispatchEvent(displayObject, "touchmove", interactionEvent);
      }
      if (isMouse) {
        this.dispatchEvent(displayObject, "mousemove", interactionEvent);
      }
    }
  };
  InteractionManager2.prototype.onPointerOut = function(originalEvent) {
    if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
      return;
    }
    var events2 = this.normalizeToPointerData(originalEvent);
    var event = events2[0];
    if (event.pointerType === "mouse") {
      this.mouseOverRenderer = false;
      this.setCursorMode(null);
    }
    var interactionData = this.getInteractionDataForPointerId(event);
    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
    interactionEvent.data.originalEvent = event;
    this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, false);
    this.emit("pointerout", interactionEvent);
    if (event.pointerType === "mouse" || event.pointerType === "pen") {
      this.emit("mouseout", interactionEvent);
    } else {
      this.releaseInteractionDataForPointerId(interactionData.identifier);
    }
  };
  InteractionManager2.prototype.processPointerOverOut = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
    var trackingData = displayObject.trackedPointers[id];
    if (hit && !trackingData) {
      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);
    }
    if (trackingData === void 0) {
      return;
    }
    if (hit && this.mouseOverRenderer) {
      if (!trackingData.over) {
        trackingData.over = true;
        this.delayDispatchEvent(displayObject, "pointerover", interactionEvent);
        if (isMouse) {
          this.delayDispatchEvent(displayObject, "mouseover", interactionEvent);
        }
      }
      if (isMouse && this.cursor === null) {
        this.cursor = displayObject.cursor;
      }
    } else if (trackingData.over) {
      trackingData.over = false;
      this.dispatchEvent(displayObject, "pointerout", this.eventData);
      if (isMouse) {
        this.dispatchEvent(displayObject, "mouseout", interactionEvent);
      }
      if (trackingData.none) {
        delete displayObject.trackedPointers[id];
      }
    }
  };
  InteractionManager2.prototype.onPointerOver = function(originalEvent) {
    if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
      return;
    }
    var events2 = this.normalizeToPointerData(originalEvent);
    var event = events2[0];
    var interactionData = this.getInteractionDataForPointerId(event);
    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
    interactionEvent.data.originalEvent = event;
    if (event.pointerType === "mouse") {
      this.mouseOverRenderer = true;
    }
    this.emit("pointerover", interactionEvent);
    if (event.pointerType === "mouse" || event.pointerType === "pen") {
      this.emit("mouseover", interactionEvent);
    }
  };
  InteractionManager2.prototype.getInteractionDataForPointerId = function(event) {
    var pointerId = event.pointerId;
    var interactionData;
    if (pointerId === MOUSE_POINTER_ID || event.pointerType === "mouse") {
      interactionData = this.mouse;
    } else if (this.activeInteractionData[pointerId]) {
      interactionData = this.activeInteractionData[pointerId];
    } else {
      interactionData = this.interactionDataPool.pop() || new InteractionData();
      interactionData.identifier = pointerId;
      this.activeInteractionData[pointerId] = interactionData;
    }
    interactionData.copyEvent(event);
    return interactionData;
  };
  InteractionManager2.prototype.releaseInteractionDataForPointerId = function(pointerId) {
    var interactionData = this.activeInteractionData[pointerId];
    if (interactionData) {
      delete this.activeInteractionData[pointerId];
      interactionData.reset();
      this.interactionDataPool.push(interactionData);
    }
  };
  InteractionManager2.prototype.configureInteractionEventForDOMEvent = function(interactionEvent, pointerEvent, interactionData) {
    interactionEvent.data = interactionData;
    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
    if (pointerEvent.pointerType === "touch") {
      pointerEvent.globalX = interactionData.global.x;
      pointerEvent.globalY = interactionData.global.y;
    }
    interactionData.originalEvent = pointerEvent;
    interactionEvent.reset();
    return interactionEvent;
  };
  InteractionManager2.prototype.normalizeToPointerData = function(event) {
    var normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent) {
      for (var i = 0, li = event.changedTouches.length; i < li; i++) {
        var touch = event.changedTouches[i];
        if (typeof touch.button === "undefined") {
          touch.button = event.touches.length ? 1 : 0;
        }
        if (typeof touch.buttons === "undefined") {
          touch.buttons = event.touches.length ? 1 : 0;
        }
        if (typeof touch.isPrimary === "undefined") {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (typeof touch.width === "undefined") {
          touch.width = touch.radiusX || 1;
        }
        if (typeof touch.height === "undefined") {
          touch.height = touch.radiusY || 1;
        }
        if (typeof touch.tiltX === "undefined") {
          touch.tiltX = 0;
        }
        if (typeof touch.tiltY === "undefined") {
          touch.tiltY = 0;
        }
        if (typeof touch.pointerType === "undefined") {
          touch.pointerType = "touch";
        }
        if (typeof touch.pointerId === "undefined") {
          touch.pointerId = touch.identifier || 0;
        }
        if (typeof touch.pressure === "undefined") {
          touch.pressure = touch.force || 0.5;
        }
        if (typeof touch.twist === "undefined") {
          touch.twist = 0;
        }
        if (typeof touch.tangentialPressure === "undefined") {
          touch.tangentialPressure = 0;
        }
        if (typeof touch.layerX === "undefined") {
          touch.layerX = touch.offsetX = touch.clientX;
        }
        if (typeof touch.layerY === "undefined") {
          touch.layerY = touch.offsetY = touch.clientY;
        }
        touch.isNormalized = true;
        normalizedEvents.push(touch);
      }
    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      var tempEvent = event;
      if (typeof tempEvent.isPrimary === "undefined") {
        tempEvent.isPrimary = true;
      }
      if (typeof tempEvent.width === "undefined") {
        tempEvent.width = 1;
      }
      if (typeof tempEvent.height === "undefined") {
        tempEvent.height = 1;
      }
      if (typeof tempEvent.tiltX === "undefined") {
        tempEvent.tiltX = 0;
      }
      if (typeof tempEvent.tiltY === "undefined") {
        tempEvent.tiltY = 0;
      }
      if (typeof tempEvent.pointerType === "undefined") {
        tempEvent.pointerType = "mouse";
      }
      if (typeof tempEvent.pointerId === "undefined") {
        tempEvent.pointerId = MOUSE_POINTER_ID;
      }
      if (typeof tempEvent.pressure === "undefined") {
        tempEvent.pressure = 0.5;
      }
      if (typeof tempEvent.twist === "undefined") {
        tempEvent.twist = 0;
      }
      if (typeof tempEvent.tangentialPressure === "undefined") {
        tempEvent.tangentialPressure = 0;
      }
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  };
  InteractionManager2.prototype.destroy = function() {
    this.removeEvents();
    this.removeTickerListener();
    this.removeAllListeners();
    this.renderer = null;
    this.mouse = null;
    this.eventData = null;
    this.interactionDOMElement = null;
    this.onPointerDown = null;
    this.processPointerDown = null;
    this.onPointerUp = null;
    this.processPointerUp = null;
    this.onPointerCancel = null;
    this.processPointerCancel = null;
    this.onPointerMove = null;
    this.processPointerMove = null;
    this.onPointerOut = null;
    this.processPointerOverOut = null;
    this.onPointerOver = null;
    this.search = null;
  };
  InteractionManager2.extension = {
    name: "interaction",
    type: [
      ExtensionType.RendererPlugin,
      ExtensionType.CanvasRendererPlugin
    ]
  };
  return InteractionManager2;
}(EventEmitter$1);
/*!
 * @pixi/extract - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var TEMP_RECT = new Rectangle();
var BYTES_PER_PIXEL = 4;
var Extract = function() {
  function Extract2(renderer2) {
    this.renderer = renderer2;
  }
  Extract2.prototype.image = function(target, format2, quality) {
    var image = new Image();
    image.src = this.base64(target, format2, quality);
    return image;
  };
  Extract2.prototype.base64 = function(target, format2, quality) {
    return this.canvas(target).toDataURL(format2, quality);
  };
  Extract2.prototype.canvas = function(target, frame) {
    var _a2 = this._rawPixels(target, frame), pixels = _a2.pixels, width = _a2.width, height = _a2.height, flipY = _a2.flipY;
    var canvasBuffer = new CanvasRenderTarget(width, height, 1);
    var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
    Extract2.arrayPostDivide(pixels, canvasData.data);
    canvasBuffer.context.putImageData(canvasData, 0, 0);
    if (flipY) {
      var target_1 = new CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);
      target_1.context.scale(1, -1);
      target_1.context.drawImage(canvasBuffer.canvas, 0, -height);
      canvasBuffer.destroy();
      canvasBuffer = target_1;
    }
    return canvasBuffer.canvas;
  };
  Extract2.prototype.pixels = function(target, frame) {
    var pixels = this._rawPixels(target, frame).pixels;
    Extract2.arrayPostDivide(pixels, pixels);
    return pixels;
  };
  Extract2.prototype._rawPixels = function(target, frame) {
    var renderer2 = this.renderer;
    var resolution;
    var flipY = false;
    var renderTexture;
    var generated = false;
    if (target) {
      if (target instanceof RenderTexture) {
        renderTexture = target;
      } else {
        var multisample = renderer2.context.webGLVersion >= 2 ? renderer2.multisample : MSAA_QUALITY.NONE;
        renderTexture = this.renderer.generateTexture(target, { multisample });
        if (multisample !== MSAA_QUALITY.NONE) {
          var resolvedTexture = RenderTexture.create({
            width: renderTexture.width,
            height: renderTexture.height
          });
          renderer2.framebuffer.bind(renderTexture.framebuffer);
          renderer2.framebuffer.blit(resolvedTexture.framebuffer);
          renderer2.framebuffer.bind(null);
          renderTexture.destroy(true);
          renderTexture = resolvedTexture;
        }
        generated = true;
      }
    }
    if (renderTexture) {
      resolution = renderTexture.baseTexture.resolution;
      frame = frame !== null && frame !== void 0 ? frame : renderTexture.frame;
      flipY = false;
      renderer2.renderTexture.bind(renderTexture);
    } else {
      resolution = renderer2.resolution;
      if (!frame) {
        frame = TEMP_RECT;
        frame.width = renderer2.width;
        frame.height = renderer2.height;
      }
      flipY = true;
      renderer2.renderTexture.bind(null);
    }
    var width = Math.round(frame.width * resolution);
    var height = Math.round(frame.height * resolution);
    var pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    var gl = renderer2.gl;
    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    if (generated) {
      renderTexture.destroy(true);
    }
    return { pixels, width, height, flipY };
  };
  Extract2.prototype.destroy = function() {
    this.renderer = null;
  };
  Extract2.arrayPostDivide = function(pixels, out) {
    for (var i = 0; i < pixels.length; i += 4) {
      var alpha = out[i + 3] = pixels[i + 3];
      if (alpha !== 0) {
        out[i] = Math.round(Math.min(pixels[i] * 255 / alpha, 255));
        out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255 / alpha, 255));
        out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255 / alpha, 255));
      } else {
        out[i] = pixels[i];
        out[i + 1] = pixels[i + 1];
        out[i + 2] = pixels[i + 2];
      }
    }
  };
  Extract2.extension = {
    name: "extract",
    type: ExtensionType.RendererPlugin
  };
  return Extract2;
}();
/*!
 * @pixi/loaders - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var SignalBinding = function() {
  function SignalBinding2(fn, once3, thisArg) {
    if (once3 === void 0) {
      once3 = false;
    }
    this._fn = fn;
    this._once = once3;
    this._thisArg = thisArg;
    this._next = this._prev = this._owner = null;
  }
  SignalBinding2.prototype.detach = function() {
    if (this._owner === null) {
      return false;
    }
    this._owner.detach(this);
    return true;
  };
  return SignalBinding2;
}();
function _addSignalBinding(self2, node) {
  if (!self2._head) {
    self2._head = node;
    self2._tail = node;
  } else {
    self2._tail._next = node;
    node._prev = self2._tail;
    self2._tail = node;
  }
  node._owner = self2;
  return node;
}
var Signal = function() {
  function Signal2() {
    this._head = this._tail = void 0;
  }
  Signal2.prototype.handlers = function(exists) {
    if (exists === void 0) {
      exists = false;
    }
    var node = this._head;
    if (exists) {
      return !!node;
    }
    var ee = [];
    while (node) {
      ee.push(node);
      node = node._next;
    }
    return ee;
  };
  Signal2.prototype.has = function(node) {
    if (!(node instanceof SignalBinding)) {
      throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
    }
    return node._owner === this;
  };
  Signal2.prototype.dispatch = function() {
    var arguments$1 = arguments;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments$1[_i];
    }
    var node = this._head;
    if (!node) {
      return false;
    }
    while (node) {
      if (node._once) {
        this.detach(node);
      }
      node._fn.apply(node._thisArg, args);
      node = node._next;
    }
    return true;
  };
  Signal2.prototype.add = function(fn, thisArg) {
    if (thisArg === void 0) {
      thisArg = null;
    }
    if (typeof fn !== "function") {
      throw new Error("MiniSignal#add(): First arg must be a Function.");
    }
    return _addSignalBinding(this, new SignalBinding(fn, false, thisArg));
  };
  Signal2.prototype.once = function(fn, thisArg) {
    if (thisArg === void 0) {
      thisArg = null;
    }
    if (typeof fn !== "function") {
      throw new Error("MiniSignal#once(): First arg must be a Function.");
    }
    return _addSignalBinding(this, new SignalBinding(fn, true, thisArg));
  };
  Signal2.prototype.detach = function(node) {
    if (!(node instanceof SignalBinding)) {
      throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
    }
    if (node._owner !== this) {
      return this;
    }
    if (node._prev) {
      node._prev._next = node._next;
    }
    if (node._next) {
      node._next._prev = node._prev;
    }
    if (node === this._head) {
      this._head = node._next;
      if (node._next === null) {
        this._tail = null;
      }
    } else if (node === this._tail) {
      this._tail = node._prev;
      this._tail._next = null;
    }
    node._owner = null;
    return this;
  };
  Signal2.prototype.detachAll = function() {
    var node = this._head;
    if (!node) {
      return this;
    }
    this._head = this._tail = null;
    while (node) {
      node._owner = null;
      node = node._next;
    }
    return this;
  };
  return Signal2;
}();
function parseUri(str, opts) {
  opts = opts || {};
  var o2 = {
    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
    q: {
      name: "queryKey",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  };
  var m2 = o2.parser[opts.strictMode ? "strict" : "loose"].exec(str);
  var uri2 = {};
  var i = 14;
  while (i--) {
    uri2[o2.key[i]] = m2[i] || "";
  }
  uri2[o2.q.name] = {};
  uri2[o2.key[12]].replace(o2.q.parser, function(_t0, t1, t2) {
    if (t1) {
      uri2[o2.q.name][t1] = t2;
    }
  });
  return uri2;
}
var useXdr;
var tempAnchor = null;
var STATUS_NONE = 0;
var STATUS_OK = 200;
var STATUS_EMPTY = 204;
var STATUS_IE_BUG_EMPTY = 1223;
var STATUS_TYPE_OK = 2;
function _noop$1() {
}
function setExtMap(map4, extname, val) {
  if (extname && extname.indexOf(".") === 0) {
    extname = extname.substring(1);
  }
  if (!extname) {
    return;
  }
  map4[extname] = val;
}
function reqType(xhr) {
  return xhr.toString().replace("object ", "");
}
var LoaderResource = function() {
  function LoaderResource2(name, url2, options) {
    this._dequeue = _noop$1;
    this._onLoadBinding = null;
    this._elementTimer = 0;
    this._boundComplete = null;
    this._boundOnError = null;
    this._boundOnProgress = null;
    this._boundOnTimeout = null;
    this._boundXhrOnError = null;
    this._boundXhrOnTimeout = null;
    this._boundXhrOnAbort = null;
    this._boundXhrOnLoad = null;
    if (typeof name !== "string" || typeof url2 !== "string") {
      throw new Error("Both name and url are required for constructing a resource.");
    }
    options = options || {};
    this._flags = 0;
    this._setFlag(LoaderResource2.STATUS_FLAGS.DATA_URL, url2.indexOf("data:") === 0);
    this.name = name;
    this.url = url2;
    this.extension = this._getExtension();
    this.data = null;
    this.crossOrigin = options.crossOrigin === true ? "anonymous" : options.crossOrigin;
    this.timeout = options.timeout || 0;
    this.loadType = options.loadType || this._determineLoadType();
    this.xhrType = options.xhrType;
    this.metadata = options.metadata || {};
    this.error = null;
    this.xhr = null;
    this.children = [];
    this.type = LoaderResource2.TYPE.UNKNOWN;
    this.progressChunk = 0;
    this._dequeue = _noop$1;
    this._onLoadBinding = null;
    this._elementTimer = 0;
    this._boundComplete = this.complete.bind(this);
    this._boundOnError = this._onError.bind(this);
    this._boundOnProgress = this._onProgress.bind(this);
    this._boundOnTimeout = this._onTimeout.bind(this);
    this._boundXhrOnError = this._xhrOnError.bind(this);
    this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);
    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
    this.onStart = new Signal();
    this.onProgress = new Signal();
    this.onComplete = new Signal();
    this.onAfterMiddleware = new Signal();
  }
  LoaderResource2.setExtensionLoadType = function(extname, loadType) {
    setExtMap(LoaderResource2._loadTypeMap, extname, loadType);
  };
  LoaderResource2.setExtensionXhrType = function(extname, xhrType) {
    setExtMap(LoaderResource2._xhrTypeMap, extname, xhrType);
  };
  Object.defineProperty(LoaderResource2.prototype, "isDataUrl", {
    get: function() {
      return this._hasFlag(LoaderResource2.STATUS_FLAGS.DATA_URL);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LoaderResource2.prototype, "isComplete", {
    get: function() {
      return this._hasFlag(LoaderResource2.STATUS_FLAGS.COMPLETE);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LoaderResource2.prototype, "isLoading", {
    get: function() {
      return this._hasFlag(LoaderResource2.STATUS_FLAGS.LOADING);
    },
    enumerable: false,
    configurable: true
  });
  LoaderResource2.prototype.complete = function() {
    this._clearEvents();
    this._finish();
  };
  LoaderResource2.prototype.abort = function(message) {
    if (this.error) {
      return;
    }
    this.error = new Error(message);
    this._clearEvents();
    if (this.xhr) {
      this.xhr.abort();
    } else if (this.xdr) {
      this.xdr.abort();
    } else if (this.data) {
      if (this.data.src) {
        this.data.src = LoaderResource2.EMPTY_GIF;
      } else {
        while (this.data.firstChild) {
          this.data.removeChild(this.data.firstChild);
        }
      }
    }
    this._finish();
  };
  LoaderResource2.prototype.load = function(cb) {
    var _this = this;
    if (this.isLoading) {
      return;
    }
    if (this.isComplete) {
      if (cb) {
        setTimeout(function() {
          return cb(_this);
        }, 1);
      }
      return;
    } else if (cb) {
      this.onComplete.once(cb);
    }
    this._setFlag(LoaderResource2.STATUS_FLAGS.LOADING, true);
    this.onStart.dispatch(this);
    if (this.crossOrigin === false || typeof this.crossOrigin !== "string") {
      this.crossOrigin = this._determineCrossOrigin(this.url);
    }
    switch (this.loadType) {
      case LoaderResource2.LOAD_TYPE.IMAGE:
        this.type = LoaderResource2.TYPE.IMAGE;
        this._loadElement("image");
        break;
      case LoaderResource2.LOAD_TYPE.AUDIO:
        this.type = LoaderResource2.TYPE.AUDIO;
        this._loadSourceElement("audio");
        break;
      case LoaderResource2.LOAD_TYPE.VIDEO:
        this.type = LoaderResource2.TYPE.VIDEO;
        this._loadSourceElement("video");
        break;
      case LoaderResource2.LOAD_TYPE.XHR:
      default:
        if (typeof useXdr === "undefined") {
          useXdr = !!(globalThis.XDomainRequest && !("withCredentials" in new XMLHttpRequest()));
        }
        if (useXdr && this.crossOrigin) {
          this._loadXdr();
        } else {
          this._loadXhr();
        }
        break;
    }
  };
  LoaderResource2.prototype._hasFlag = function(flag) {
    return (this._flags & flag) !== 0;
  };
  LoaderResource2.prototype._setFlag = function(flag, value) {
    this._flags = value ? this._flags | flag : this._flags & ~flag;
  };
  LoaderResource2.prototype._clearEvents = function() {
    clearTimeout(this._elementTimer);
    if (this.data && this.data.removeEventListener) {
      this.data.removeEventListener("error", this._boundOnError, false);
      this.data.removeEventListener("load", this._boundComplete, false);
      this.data.removeEventListener("progress", this._boundOnProgress, false);
      this.data.removeEventListener("canplaythrough", this._boundComplete, false);
    }
    if (this.xhr) {
      if (this.xhr.removeEventListener) {
        this.xhr.removeEventListener("error", this._boundXhrOnError, false);
        this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, false);
        this.xhr.removeEventListener("abort", this._boundXhrOnAbort, false);
        this.xhr.removeEventListener("progress", this._boundOnProgress, false);
        this.xhr.removeEventListener("load", this._boundXhrOnLoad, false);
      } else {
        this.xhr.onerror = null;
        this.xhr.ontimeout = null;
        this.xhr.onprogress = null;
        this.xhr.onload = null;
      }
    }
  };
  LoaderResource2.prototype._finish = function() {
    if (this.isComplete) {
      throw new Error("Complete called again for an already completed resource.");
    }
    this._setFlag(LoaderResource2.STATUS_FLAGS.COMPLETE, true);
    this._setFlag(LoaderResource2.STATUS_FLAGS.LOADING, false);
    this.onComplete.dispatch(this);
  };
  LoaderResource2.prototype._loadElement = function(type2) {
    if (this.metadata.loadElement) {
      this.data = this.metadata.loadElement;
    } else if (type2 === "image" && typeof globalThis.Image !== "undefined") {
      this.data = new Image();
    } else {
      this.data = document.createElement(type2);
    }
    if (this.crossOrigin) {
      this.data.crossOrigin = this.crossOrigin;
    }
    if (!this.metadata.skipSource) {
      this.data.src = this.url;
    }
    this.data.addEventListener("error", this._boundOnError, false);
    this.data.addEventListener("load", this._boundComplete, false);
    this.data.addEventListener("progress", this._boundOnProgress, false);
    if (this.timeout) {
      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
    }
  };
  LoaderResource2.prototype._loadSourceElement = function(type2) {
    if (this.metadata.loadElement) {
      this.data = this.metadata.loadElement;
    } else if (type2 === "audio" && typeof globalThis.Audio !== "undefined") {
      this.data = new Audio();
    } else {
      this.data = document.createElement(type2);
    }
    if (this.data === null) {
      this.abort("Unsupported element: " + type2);
      return;
    }
    if (this.crossOrigin) {
      this.data.crossOrigin = this.crossOrigin;
    }
    if (!this.metadata.skipSource) {
      if (navigator.isCocoonJS) {
        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
      } else if (Array.isArray(this.url)) {
        var mimeTypes = this.metadata.mimeType;
        for (var i = 0; i < this.url.length; ++i) {
          this.data.appendChild(this._createSource(type2, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));
        }
      } else {
        var mimeTypes = this.metadata.mimeType;
        this.data.appendChild(this._createSource(type2, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes));
      }
    }
    this.data.addEventListener("error", this._boundOnError, false);
    this.data.addEventListener("load", this._boundComplete, false);
    this.data.addEventListener("progress", this._boundOnProgress, false);
    this.data.addEventListener("canplaythrough", this._boundComplete, false);
    this.data.load();
    if (this.timeout) {
      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
    }
  };
  LoaderResource2.prototype._loadXhr = function() {
    if (typeof this.xhrType !== "string") {
      this.xhrType = this._determineXhrType();
    }
    var xhr = this.xhr = new XMLHttpRequest();
    if (this.crossOrigin === "use-credentials") {
      xhr.withCredentials = true;
    }
    xhr.open("GET", this.url, true);
    xhr.timeout = this.timeout;
    if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.JSON || this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT) {
      xhr.responseType = LoaderResource2.XHR_RESPONSE_TYPE.TEXT;
    } else {
      xhr.responseType = this.xhrType;
    }
    xhr.addEventListener("error", this._boundXhrOnError, false);
    xhr.addEventListener("timeout", this._boundXhrOnTimeout, false);
    xhr.addEventListener("abort", this._boundXhrOnAbort, false);
    xhr.addEventListener("progress", this._boundOnProgress, false);
    xhr.addEventListener("load", this._boundXhrOnLoad, false);
    xhr.send();
  };
  LoaderResource2.prototype._loadXdr = function() {
    if (typeof this.xhrType !== "string") {
      this.xhrType = this._determineXhrType();
    }
    var xdr = this.xhr = new globalThis.XDomainRequest();
    xdr.timeout = this.timeout || 5e3;
    xdr.onerror = this._boundXhrOnError;
    xdr.ontimeout = this._boundXhrOnTimeout;
    xdr.onprogress = this._boundOnProgress;
    xdr.onload = this._boundXhrOnLoad;
    xdr.open("GET", this.url, true);
    setTimeout(function() {
      return xdr.send();
    }, 1);
  };
  LoaderResource2.prototype._createSource = function(type2, url2, mime) {
    if (!mime) {
      mime = type2 + "/" + this._getExtension(url2);
    }
    var source = document.createElement("source");
    source.src = url2;
    source.type = mime;
    return source;
  };
  LoaderResource2.prototype._onError = function(event) {
    this.abort("Failed to load element using: " + event.target.nodeName);
  };
  LoaderResource2.prototype._onProgress = function(event) {
    if (event && event.lengthComputable) {
      this.onProgress.dispatch(this, event.loaded / event.total);
    }
  };
  LoaderResource2.prototype._onTimeout = function() {
    this.abort("Load timed out.");
  };
  LoaderResource2.prototype._xhrOnError = function() {
    var xhr = this.xhr;
    this.abort(reqType(xhr) + " Request failed. Status: " + xhr.status + ', text: "' + xhr.statusText + '"');
  };
  LoaderResource2.prototype._xhrOnTimeout = function() {
    var xhr = this.xhr;
    this.abort(reqType(xhr) + " Request timed out.");
  };
  LoaderResource2.prototype._xhrOnAbort = function() {
    var xhr = this.xhr;
    this.abort(reqType(xhr) + " Request was aborted by the user.");
  };
  LoaderResource2.prototype._xhrOnLoad = function() {
    var xhr = this.xhr;
    var text = "";
    var status = typeof xhr.status === "undefined" ? STATUS_OK : xhr.status;
    if (xhr.responseType === "" || xhr.responseType === "text" || typeof xhr.responseType === "undefined") {
      text = xhr.responseText;
    }
    if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === LoaderResource2.XHR_RESPONSE_TYPE.BUFFER)) {
      status = STATUS_OK;
    } else if (status === STATUS_IE_BUG_EMPTY) {
      status = STATUS_EMPTY;
    }
    var statusType = status / 100 | 0;
    if (statusType === STATUS_TYPE_OK) {
      if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.TEXT) {
        this.data = text;
        this.type = LoaderResource2.TYPE.TEXT;
      } else if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.JSON) {
        try {
          this.data = JSON.parse(text);
          this.type = LoaderResource2.TYPE.JSON;
        } catch (e2) {
          this.abort("Error trying to parse loaded json: " + e2);
          return;
        }
      } else if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT) {
        try {
          if (globalThis.DOMParser) {
            var domparser = new DOMParser();
            this.data = domparser.parseFromString(text, "text/xml");
          } else {
            var div = document.createElement("div");
            div.innerHTML = text;
            this.data = div;
          }
          this.type = LoaderResource2.TYPE.XML;
        } catch (e$1) {
          this.abort("Error trying to parse loaded xml: " + e$1);
          return;
        }
      } else {
        this.data = xhr.response || text;
      }
    } else {
      this.abort("[" + xhr.status + "] " + xhr.statusText + ": " + xhr.responseURL);
      return;
    }
    this.complete();
  };
  LoaderResource2.prototype._determineCrossOrigin = function(url2, loc) {
    if (url2.indexOf("data:") === 0) {
      return "";
    }
    if (globalThis.origin !== globalThis.location.origin) {
      return "anonymous";
    }
    loc = loc || globalThis.location;
    if (!tempAnchor) {
      tempAnchor = document.createElement("a");
    }
    tempAnchor.href = url2;
    var parsedUrl = parseUri(tempAnchor.href, { strictMode: true });
    var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
    var protocol = parsedUrl.protocol ? parsedUrl.protocol + ":" : "";
    if (parsedUrl.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  };
  LoaderResource2.prototype._determineXhrType = function() {
    return LoaderResource2._xhrTypeMap[this.extension] || LoaderResource2.XHR_RESPONSE_TYPE.TEXT;
  };
  LoaderResource2.prototype._determineLoadType = function() {
    return LoaderResource2._loadTypeMap[this.extension] || LoaderResource2.LOAD_TYPE.XHR;
  };
  LoaderResource2.prototype._getExtension = function(url2) {
    if (url2 === void 0) {
      url2 = this.url;
    }
    var ext = "";
    if (this.isDataUrl) {
      var slashIndex = url2.indexOf("/");
      ext = url2.substring(slashIndex + 1, url2.indexOf(";", slashIndex));
    } else {
      var queryStart = url2.indexOf("?");
      var hashStart = url2.indexOf("#");
      var index = Math.min(queryStart > -1 ? queryStart : url2.length, hashStart > -1 ? hashStart : url2.length);
      url2 = url2.substring(0, index);
      ext = url2.substring(url2.lastIndexOf(".") + 1);
    }
    return ext.toLowerCase();
  };
  LoaderResource2.prototype._getMimeFromXhrType = function(type2) {
    switch (type2) {
      case LoaderResource2.XHR_RESPONSE_TYPE.BUFFER:
        return "application/octet-binary";
      case LoaderResource2.XHR_RESPONSE_TYPE.BLOB:
        return "application/blob";
      case LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT:
        return "application/xml";
      case LoaderResource2.XHR_RESPONSE_TYPE.JSON:
        return "application/json";
      case LoaderResource2.XHR_RESPONSE_TYPE.DEFAULT:
      case LoaderResource2.XHR_RESPONSE_TYPE.TEXT:
      default:
        return "text/plain";
    }
  };
  return LoaderResource2;
}();
(function(LoaderResource2) {
  (function(STATUS_FLAGS) {
    STATUS_FLAGS[STATUS_FLAGS["NONE"] = 0] = "NONE";
    STATUS_FLAGS[STATUS_FLAGS["DATA_URL"] = 1] = "DATA_URL";
    STATUS_FLAGS[STATUS_FLAGS["COMPLETE"] = 2] = "COMPLETE";
    STATUS_FLAGS[STATUS_FLAGS["LOADING"] = 4] = "LOADING";
  })(LoaderResource2.STATUS_FLAGS || (LoaderResource2.STATUS_FLAGS = {}));
  (function(TYPE) {
    TYPE[TYPE["UNKNOWN"] = 0] = "UNKNOWN";
    TYPE[TYPE["JSON"] = 1] = "JSON";
    TYPE[TYPE["XML"] = 2] = "XML";
    TYPE[TYPE["IMAGE"] = 3] = "IMAGE";
    TYPE[TYPE["AUDIO"] = 4] = "AUDIO";
    TYPE[TYPE["VIDEO"] = 5] = "VIDEO";
    TYPE[TYPE["TEXT"] = 6] = "TEXT";
  })(LoaderResource2.TYPE || (LoaderResource2.TYPE = {}));
  (function(LOAD_TYPE) {
    LOAD_TYPE[LOAD_TYPE["XHR"] = 1] = "XHR";
    LOAD_TYPE[LOAD_TYPE["IMAGE"] = 2] = "IMAGE";
    LOAD_TYPE[LOAD_TYPE["AUDIO"] = 3] = "AUDIO";
    LOAD_TYPE[LOAD_TYPE["VIDEO"] = 4] = "VIDEO";
  })(LoaderResource2.LOAD_TYPE || (LoaderResource2.LOAD_TYPE = {}));
  (function(XHR_RESPONSE_TYPE) {
    XHR_RESPONSE_TYPE["DEFAULT"] = "text";
    XHR_RESPONSE_TYPE["BUFFER"] = "arraybuffer";
    XHR_RESPONSE_TYPE["BLOB"] = "blob";
    XHR_RESPONSE_TYPE["DOCUMENT"] = "document";
    XHR_RESPONSE_TYPE["JSON"] = "json";
    XHR_RESPONSE_TYPE["TEXT"] = "text";
  })(LoaderResource2.XHR_RESPONSE_TYPE || (LoaderResource2.XHR_RESPONSE_TYPE = {}));
  LoaderResource2._loadTypeMap = {
    gif: LoaderResource2.LOAD_TYPE.IMAGE,
    png: LoaderResource2.LOAD_TYPE.IMAGE,
    bmp: LoaderResource2.LOAD_TYPE.IMAGE,
    jpg: LoaderResource2.LOAD_TYPE.IMAGE,
    jpeg: LoaderResource2.LOAD_TYPE.IMAGE,
    tif: LoaderResource2.LOAD_TYPE.IMAGE,
    tiff: LoaderResource2.LOAD_TYPE.IMAGE,
    webp: LoaderResource2.LOAD_TYPE.IMAGE,
    tga: LoaderResource2.LOAD_TYPE.IMAGE,
    avif: LoaderResource2.LOAD_TYPE.IMAGE,
    svg: LoaderResource2.LOAD_TYPE.IMAGE,
    "svg+xml": LoaderResource2.LOAD_TYPE.IMAGE,
    mp3: LoaderResource2.LOAD_TYPE.AUDIO,
    ogg: LoaderResource2.LOAD_TYPE.AUDIO,
    wav: LoaderResource2.LOAD_TYPE.AUDIO,
    mp4: LoaderResource2.LOAD_TYPE.VIDEO,
    webm: LoaderResource2.LOAD_TYPE.VIDEO
  };
  LoaderResource2._xhrTypeMap = {
    xhtml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    html: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    tsx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    gif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    png: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    bmp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    jpg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    jpeg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tiff: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    webp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tga: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    avif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    json: LoaderResource2.XHR_RESPONSE_TYPE.JSON,
    text: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,
    txt: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,
    ttf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER,
    otf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER
  };
  LoaderResource2.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
})(LoaderResource || (LoaderResource = {}));
function _noop() {
}
function onlyOnce(fn) {
  return function onceWrapper2() {
    var arguments$1 = arguments;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments$1[_i];
    }
    if (fn === null) {
      throw new Error("Callback was already called.");
    }
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  };
}
var AsyncQueueItem = function() {
  function AsyncQueueItem2(data, callback) {
    this.data = data;
    this.callback = callback;
  }
  return AsyncQueueItem2;
}();
var AsyncQueue = function() {
  function AsyncQueue2(worker, concurrency) {
    var _this = this;
    if (concurrency === void 0) {
      concurrency = 1;
    }
    this.workers = 0;
    this.saturated = _noop;
    this.unsaturated = _noop;
    this.empty = _noop;
    this.drain = _noop;
    this.error = _noop;
    this.started = false;
    this.paused = false;
    this._tasks = [];
    this._insert = function(data, insertAtFront, callback) {
      if (callback && typeof callback !== "function") {
        throw new Error("task callback must be a function");
      }
      _this.started = true;
      if (data == null && _this.idle()) {
        setTimeout(function() {
          return _this.drain();
        }, 1);
        return;
      }
      var item = new AsyncQueueItem(data, typeof callback === "function" ? callback : _noop);
      if (insertAtFront) {
        _this._tasks.unshift(item);
      } else {
        _this._tasks.push(item);
      }
      setTimeout(_this.process, 1);
    };
    this.process = function() {
      while (!_this.paused && _this.workers < _this.concurrency && _this._tasks.length) {
        var task = _this._tasks.shift();
        if (_this._tasks.length === 0) {
          _this.empty();
        }
        _this.workers += 1;
        if (_this.workers === _this.concurrency) {
          _this.saturated();
        }
        _this._worker(task.data, onlyOnce(_this._next(task)));
      }
    };
    this._worker = worker;
    if (concurrency === 0) {
      throw new Error("Concurrency must not be zero");
    }
    this.concurrency = concurrency;
    this.buffer = concurrency / 4;
  }
  AsyncQueue2.prototype._next = function(task) {
    var _this = this;
    return function() {
      var arguments$1 = arguments;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments$1[_i];
      }
      _this.workers -= 1;
      task.callback.apply(task, args);
      if (args[0] != null) {
        _this.error(args[0], task.data);
      }
      if (_this.workers <= _this.concurrency - _this.buffer) {
        _this.unsaturated();
      }
      if (_this.idle()) {
        _this.drain();
      }
      _this.process();
    };
  };
  AsyncQueue2.prototype.push = function(data, callback) {
    this._insert(data, false, callback);
  };
  AsyncQueue2.prototype.kill = function() {
    this.workers = 0;
    this.drain = _noop;
    this.started = false;
    this._tasks = [];
  };
  AsyncQueue2.prototype.unshift = function(data, callback) {
    this._insert(data, true, callback);
  };
  AsyncQueue2.prototype.length = function() {
    return this._tasks.length;
  };
  AsyncQueue2.prototype.running = function() {
    return this.workers;
  };
  AsyncQueue2.prototype.idle = function() {
    return this._tasks.length + this.workers === 0;
  };
  AsyncQueue2.prototype.pause = function() {
    if (this.paused === true) {
      return;
    }
    this.paused = true;
  };
  AsyncQueue2.prototype.resume = function() {
    if (this.paused === false) {
      return;
    }
    this.paused = false;
    for (var w2 = 1; w2 <= this.concurrency; w2++) {
      this.process();
    }
  };
  AsyncQueue2.eachSeries = function(array, iterator, callback, deferNext) {
    var i = 0;
    var len = array.length;
    function next(err) {
      if (err || i === len) {
        if (callback) {
          callback(err);
        }
        return;
      }
      if (deferNext) {
        setTimeout(function() {
          iterator(array[i++], next);
        }, 1);
      } else {
        iterator(array[i++], next);
      }
    }
    next();
  };
  AsyncQueue2.queue = function(worker, concurrency) {
    return new AsyncQueue2(worker, concurrency);
  };
  return AsyncQueue2;
}();
var MAX_PROGRESS = 100;
var rgxExtractUrlHash = /(#[\w-]+)?$/;
var Loader = function() {
  function Loader2(baseUrl, concurrency) {
    var _this = this;
    if (baseUrl === void 0) {
      baseUrl = "";
    }
    if (concurrency === void 0) {
      concurrency = 10;
    }
    this.progress = 0;
    this.loading = false;
    this.defaultQueryString = "";
    this._beforeMiddleware = [];
    this._afterMiddleware = [];
    this._resourcesParsing = [];
    this._boundLoadResource = function(r2, d2) {
      return _this._loadResource(r2, d2);
    };
    this.resources = {};
    this.baseUrl = baseUrl;
    this._beforeMiddleware = [];
    this._afterMiddleware = [];
    this._resourcesParsing = [];
    this._boundLoadResource = function(r2, d2) {
      return _this._loadResource(r2, d2);
    };
    this._queue = AsyncQueue.queue(this._boundLoadResource, concurrency);
    this._queue.pause();
    this.resources = {};
    this.onProgress = new Signal();
    this.onError = new Signal();
    this.onLoad = new Signal();
    this.onStart = new Signal();
    this.onComplete = new Signal();
    for (var i = 0; i < Loader2._plugins.length; ++i) {
      var plugin = Loader2._plugins[i];
      var pre = plugin.pre, use = plugin.use;
      if (pre) {
        this.pre(pre);
      }
      if (use) {
        this.use(use);
      }
    }
    this._protected = false;
  }
  Loader2.prototype._add = function(name, url2, options, callback) {
    if (this.loading && (!options || !options.parentResource)) {
      throw new Error("Cannot add resources while the loader is running.");
    }
    if (this.resources[name]) {
      throw new Error('Resource named "' + name + '" already exists.');
    }
    url2 = this._prepareUrl(url2);
    this.resources[name] = new LoaderResource(name, url2, options);
    if (typeof callback === "function") {
      this.resources[name].onAfterMiddleware.once(callback);
    }
    if (this.loading) {
      var parent = options.parentResource;
      var incompleteChildren = [];
      for (var i = 0; i < parent.children.length; ++i) {
        if (!parent.children[i].isComplete) {
          incompleteChildren.push(parent.children[i]);
        }
      }
      var fullChunk = parent.progressChunk * (incompleteChildren.length + 1);
      var eachChunk = fullChunk / (incompleteChildren.length + 2);
      parent.children.push(this.resources[name]);
      parent.progressChunk = eachChunk;
      for (var i = 0; i < incompleteChildren.length; ++i) {
        incompleteChildren[i].progressChunk = eachChunk;
      }
      this.resources[name].progressChunk = eachChunk;
    }
    this._queue.push(this.resources[name]);
    return this;
  };
  Loader2.prototype.pre = function(fn) {
    this._beforeMiddleware.push(fn);
    return this;
  };
  Loader2.prototype.use = function(fn) {
    this._afterMiddleware.push(fn);
    return this;
  };
  Loader2.prototype.reset = function() {
    this.progress = 0;
    this.loading = false;
    this._queue.kill();
    this._queue.pause();
    for (var k2 in this.resources) {
      var res = this.resources[k2];
      if (res._onLoadBinding) {
        res._onLoadBinding.detach();
      }
      if (res.isLoading) {
        res.abort("loader reset");
      }
    }
    this.resources = {};
    return this;
  };
  Loader2.prototype.load = function(cb) {
    deprecation("6.5.0", "@pixi/loaders is being replaced with @pixi/assets in the next major release.");
    if (typeof cb === "function") {
      this.onComplete.once(cb);
    }
    if (this.loading) {
      return this;
    }
    if (this._queue.idle()) {
      this._onStart();
      this._onComplete();
    } else {
      var numTasks = this._queue._tasks.length;
      var chunk = MAX_PROGRESS / numTasks;
      for (var i = 0; i < this._queue._tasks.length; ++i) {
        this._queue._tasks[i].data.progressChunk = chunk;
      }
      this._onStart();
      this._queue.resume();
    }
    return this;
  };
  Object.defineProperty(Loader2.prototype, "concurrency", {
    get: function() {
      return this._queue.concurrency;
    },
    set: function(concurrency) {
      this._queue.concurrency = concurrency;
    },
    enumerable: false,
    configurable: true
  });
  Loader2.prototype._prepareUrl = function(url2) {
    var parsedUrl = parseUri(url2, { strictMode: true });
    var result;
    if (parsedUrl.protocol || !parsedUrl.path || url2.indexOf("//") === 0) {
      result = url2;
    } else if (this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && url2.charAt(0) !== "/") {
      result = this.baseUrl + "/" + url2;
    } else {
      result = this.baseUrl + url2;
    }
    if (this.defaultQueryString) {
      var hash = rgxExtractUrlHash.exec(result)[0];
      result = result.slice(0, result.length - hash.length);
      if (result.indexOf("?") !== -1) {
        result += "&" + this.defaultQueryString;
      } else {
        result += "?" + this.defaultQueryString;
      }
      result += hash;
    }
    return result;
  };
  Loader2.prototype._loadResource = function(resource, dequeue) {
    var _this = this;
    resource._dequeue = dequeue;
    AsyncQueue.eachSeries(this._beforeMiddleware, function(fn, next) {
      fn.call(_this, resource, function() {
        next(resource.isComplete ? {} : null);
      });
    }, function() {
      if (resource.isComplete) {
        _this._onLoad(resource);
      } else {
        resource._onLoadBinding = resource.onComplete.once(_this._onLoad, _this);
        resource.load();
      }
    }, true);
  };
  Loader2.prototype._onStart = function() {
    this.progress = 0;
    this.loading = true;
    this.onStart.dispatch(this);
  };
  Loader2.prototype._onComplete = function() {
    this.progress = MAX_PROGRESS;
    this.loading = false;
    this.onComplete.dispatch(this, this.resources);
  };
  Loader2.prototype._onLoad = function(resource) {
    var _this = this;
    resource._onLoadBinding = null;
    this._resourcesParsing.push(resource);
    resource._dequeue();
    AsyncQueue.eachSeries(this._afterMiddleware, function(fn, next) {
      fn.call(_this, resource, next);
    }, function() {
      resource.onAfterMiddleware.dispatch(resource);
      _this.progress = Math.min(MAX_PROGRESS, _this.progress + resource.progressChunk);
      _this.onProgress.dispatch(_this, resource);
      if (resource.error) {
        _this.onError.dispatch(resource.error, _this, resource);
      } else {
        _this.onLoad.dispatch(_this, resource);
      }
      _this._resourcesParsing.splice(_this._resourcesParsing.indexOf(resource), 1);
      if (_this._queue.idle() && _this._resourcesParsing.length === 0) {
        _this._onComplete();
      }
    }, true);
  };
  Loader2.prototype.destroy = function() {
    if (!this._protected) {
      this.reset();
    }
  };
  Object.defineProperty(Loader2, "shared", {
    get: function() {
      var shared = Loader2._shared;
      if (!shared) {
        shared = new Loader2();
        shared._protected = true;
        Loader2._shared = shared;
      }
      return shared;
    },
    enumerable: false,
    configurable: true
  });
  Loader2.registerPlugin = function(plugin) {
    deprecation("6.5.0", "Loader.registerPlugin() is deprecated, use extensions.add() instead.");
    extensions.add({
      type: ExtensionType.Loader,
      ref: plugin
    });
    return Loader2;
  };
  Loader2._plugins = [];
  return Loader2;
}();
extensions.handleByList(ExtensionType.Loader, Loader._plugins);
Loader.prototype.add = function add(name, url2, options, callback) {
  if (Array.isArray(name)) {
    for (var i = 0; i < name.length; ++i) {
      this.add(name[i]);
    }
    return this;
  }
  if (typeof name === "object") {
    options = name;
    callback = url2 || options.callback || options.onComplete;
    url2 = options.url;
    name = options.name || options.key || options.url;
  }
  if (typeof url2 !== "string") {
    callback = options;
    options = url2;
    url2 = name;
  }
  if (typeof url2 !== "string") {
    throw new Error("No url passed to add resource to loader.");
  }
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  return this._add(name, url2, options, callback);
};
var AppLoaderPlugin = function() {
  function AppLoaderPlugin2() {
  }
  AppLoaderPlugin2.init = function(options) {
    options = Object.assign({
      sharedLoader: false
    }, options);
    this.loader = options.sharedLoader ? Loader.shared : new Loader();
  };
  AppLoaderPlugin2.destroy = function() {
    if (this.loader) {
      this.loader.destroy();
      this.loader = null;
    }
  };
  AppLoaderPlugin2.extension = ExtensionType.Application;
  return AppLoaderPlugin2;
}();
var TextureLoader = function() {
  function TextureLoader2() {
  }
  TextureLoader2.add = function() {
    LoaderResource.setExtensionLoadType("svg", LoaderResource.LOAD_TYPE.XHR);
    LoaderResource.setExtensionXhrType("svg", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
  };
  TextureLoader2.use = function(resource, next) {
    if (resource.data && (resource.type === LoaderResource.TYPE.IMAGE || resource.extension === "svg")) {
      var data = resource.data, url2 = resource.url, name = resource.name, metadata = resource.metadata;
      Texture.fromLoader(data, url2, name, metadata).then(function(texture) {
        resource.texture = texture;
        next();
      }).catch(next);
    } else {
      next();
    }
  };
  TextureLoader2.extension = ExtensionType.Loader;
  return TextureLoader2;
}();
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBinary(input) {
  var output = "";
  var inx = 0;
  while (inx < input.length) {
    var bytebuffer = [0, 0, 0];
    var encodedCharIndexes = [0, 0, 0, 0];
    for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {
      if (inx < input.length) {
        bytebuffer[jnx] = input.charCodeAt(inx++) & 255;
      } else {
        bytebuffer[jnx] = 0;
      }
    }
    encodedCharIndexes[0] = bytebuffer[0] >> 2;
    encodedCharIndexes[1] = (bytebuffer[0] & 3) << 4 | bytebuffer[1] >> 4;
    encodedCharIndexes[2] = (bytebuffer[1] & 15) << 2 | bytebuffer[2] >> 6;
    encodedCharIndexes[3] = bytebuffer[2] & 63;
    var paddingBytes = inx - (input.length - 1);
    switch (paddingBytes) {
      case 2:
        encodedCharIndexes[3] = 64;
        encodedCharIndexes[2] = 64;
        break;
      case 1:
        encodedCharIndexes[3] = 64;
        break;
    }
    for (var jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {
      output += _keyStr.charAt(encodedCharIndexes[jnx]);
    }
  }
  return output;
}
function parsing(resource, next) {
  if (!resource.data) {
    next();
    return;
  }
  if (resource.xhr && resource.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {
    if (!self.Blob || typeof resource.data === "string") {
      var type2 = resource.xhr.getResponseHeader("content-type");
      if (type2 && type2.indexOf("image") === 0) {
        resource.data = new Image();
        resource.data.src = "data:" + type2 + ";base64," + encodeBinary(resource.xhr.responseText);
        resource.type = LoaderResource.TYPE.IMAGE;
        resource.data.onload = function() {
          resource.data.onload = null;
          next();
        };
        return;
      }
    } else if (resource.data.type.indexOf("image") === 0) {
      var Url_1 = globalThis.URL || globalThis.webkitURL;
      var src_1 = Url_1.createObjectURL(resource.data);
      resource.blob = resource.data;
      resource.data = new Image();
      resource.data.src = src_1;
      resource.type = LoaderResource.TYPE.IMAGE;
      resource.data.onload = function() {
        Url_1.revokeObjectURL(src_1);
        resource.data.onload = null;
        next();
      };
      return;
    }
  }
  next();
}
var ParsingLoader = function() {
  function ParsingLoader2() {
  }
  ParsingLoader2.extension = ExtensionType.Loader;
  ParsingLoader2.use = parsing;
  return ParsingLoader2;
}();
extensions.add(TextureLoader, ParsingLoader);
/*!
 * @pixi/compressed-textures - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/compressed-textures is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var _a$2;
var INTERNAL_FORMATS;
(function(INTERNAL_FORMATS2) {
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
})(INTERNAL_FORMATS || (INTERNAL_FORMATS = {}));
var INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a$2 = {}, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ASTC_4x4_KHR] = 1, _a$2);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$g = function(d2, b2) {
  extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$g(d2, b2);
};
function __extends$g(d2, b2) {
  extendStatics$g(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject2(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject2(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1) {
      throw t2[1];
    }
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) {
      throw new TypeError("Generator is already executing.");
    }
    while (_) {
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) {
          return t2;
        }
        if (y2 = 0, t2) {
          op = [op[0] & 2, t2.value];
        }
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2]) {
              _.ops.pop();
            }
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    }
    if (op[0] & 5) {
      throw op[1];
    }
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var BlobResource = function(_super) {
  __extends$g(BlobResource2, _super);
  function BlobResource2(source, options) {
    if (options === void 0) {
      options = { width: 1, height: 1, autoLoad: true };
    }
    var _this = this;
    var origin;
    var data;
    if (typeof source === "string") {
      origin = source;
      data = new Uint8Array();
    } else {
      origin = null;
      data = source;
    }
    _this = _super.call(this, data, options) || this;
    _this.origin = origin;
    _this.buffer = data ? new ViewableBuffer(data) : null;
    if (_this.origin && options.autoLoad !== false) {
      _this.load();
    }
    if (data && data.length) {
      _this.loaded = true;
      _this.onBlobLoaded(_this.buffer.rawBinaryData);
    }
    return _this;
  }
  BlobResource2.prototype.onBlobLoaded = function(_data) {
  };
  BlobResource2.prototype.load = function() {
    return __awaiter(this, void 0, Promise, function() {
      var response, blob, arrayBuffer;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, fetch(this.origin)];
          case 1:
            response = _a2.sent();
            return [4, response.blob()];
          case 2:
            blob = _a2.sent();
            return [4, blob.arrayBuffer()];
          case 3:
            arrayBuffer = _a2.sent();
            this.data = new Uint32Array(arrayBuffer);
            this.buffer = new ViewableBuffer(arrayBuffer);
            this.loaded = true;
            this.onBlobLoaded(arrayBuffer);
            this.update();
            return [2, this];
        }
      });
    });
  };
  return BlobResource2;
}(BufferResource);
var CompressedTextureResource = function(_super) {
  __extends$g(CompressedTextureResource2, _super);
  function CompressedTextureResource2(source, options) {
    var _this = _super.call(this, source, options) || this;
    _this.format = options.format;
    _this.levels = options.levels || 1;
    _this._width = options.width;
    _this._height = options.height;
    _this._extension = CompressedTextureResource2._formatToExtension(_this.format);
    if (options.levelBuffers || _this.buffer) {
      _this._levelBuffers = options.levelBuffers || CompressedTextureResource2._createLevelBuffers(
        source instanceof Uint8Array ? source : _this.buffer.uint8View,
        _this.format,
        _this.levels,
        4,
        4,
        _this.width,
        _this.height
      );
    }
    return _this;
  }
  CompressedTextureResource2.prototype.upload = function(renderer2, _texture, _glTexture) {
    var gl = renderer2.gl;
    var extension = renderer2.context.extensions[this._extension];
    if (!extension) {
      throw new Error(this._extension + " textures are not supported on the current machine");
    }
    if (!this._levelBuffers) {
      return false;
    }
    for (var i = 0, j2 = this.levels; i < j2; i++) {
      var _a2 = this._levelBuffers[i], levelID = _a2.levelID, levelWidth = _a2.levelWidth, levelHeight = _a2.levelHeight, levelBuffer = _a2.levelBuffer;
      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
    }
    return true;
  };
  CompressedTextureResource2.prototype.onBlobLoaded = function() {
    this._levelBuffers = CompressedTextureResource2._createLevelBuffers(
      this.buffer.uint8View,
      this.format,
      this.levels,
      4,
      4,
      this.width,
      this.height
    );
  };
  CompressedTextureResource2._formatToExtension = function(format2) {
    if (format2 >= 33776 && format2 <= 33779) {
      return "s3tc";
    } else if (format2 >= 37488 && format2 <= 37497) {
      return "etc";
    } else if (format2 >= 35840 && format2 <= 35843) {
      return "pvrtc";
    } else if (format2 >= 36196) {
      return "etc1";
    } else if (format2 >= 35986 && format2 <= 34798) {
      return "atc";
    }
    throw new Error("Invalid (compressed) texture format given!");
  };
  CompressedTextureResource2._createLevelBuffers = function(buffer, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
    var buffers = new Array(levels);
    var offset = buffer.byteOffset;
    var levelWidth = imageWidth;
    var levelHeight = imageHeight;
    var alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
    var alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
    var levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
    for (var i = 0; i < levels; i++) {
      buffers[i] = {
        levelID: i,
        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
        levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)
      };
      offset += levelSize;
      levelWidth = levelWidth >> 1 || 1;
      levelHeight = levelHeight >> 1 || 1;
      alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
      alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
      levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
    }
    return buffers;
  };
  return CompressedTextureResource2;
}(BlobResource);
var CompressedTextureLoader = function() {
  function CompressedTextureLoader2() {
  }
  CompressedTextureLoader2.use = function(resource, next) {
    var data = resource.data;
    var loader = this;
    if (resource.type === LoaderResource.TYPE.JSON && data && data.cacheID && data.textures) {
      var textures = data.textures;
      var textureURL = void 0;
      var fallbackURL = void 0;
      for (var i = 0, j2 = textures.length; i < j2; i++) {
        var texture = textures[i];
        var url_1 = texture.src;
        var format2 = texture.format;
        if (!format2) {
          fallbackURL = url_1;
        }
        if (CompressedTextureLoader2.textureFormats[format2]) {
          textureURL = url_1;
          break;
        }
      }
      textureURL = textureURL || fallbackURL;
      if (!textureURL) {
        next(new Error("Cannot load compressed-textures in " + resource.url + ", make sure you provide a fallback"));
        return;
      }
      if (textureURL === resource.url) {
        next(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
        return;
      }
      var loadOptions = {
        crossOrigin: resource.crossOrigin,
        metadata: resource.metadata.imageMetadata,
        parentResource: resource
      };
      var resourcePath = url.resolve(resource.url.replace(loader.baseUrl, ""), textureURL);
      var resourceName = data.cacheID;
      loader.add(resourceName, resourcePath, loadOptions, function(res) {
        if (res.error) {
          next(res.error);
          return;
        }
        var _a2 = res.texture, texture2 = _a2 === void 0 ? null : _a2, _b2 = res.textures, textures2 = _b2 === void 0 ? {} : _b2;
        Object.assign(resource, { texture: texture2, textures: textures2 });
        next();
      });
    } else {
      next();
    }
  };
  Object.defineProperty(CompressedTextureLoader2, "textureExtensions", {
    get: function() {
      if (!CompressedTextureLoader2._textureExtensions) {
        var canvas = settings.ADAPTER.createCanvas();
        var gl = canvas.getContext("webgl");
        if (!gl) {
          console.warn("WebGL not available for compressed textures. Silently failing.");
          return {};
        }
        var extensions2 = {
          s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          etc: gl.getExtension("WEBGL_compressed_texture_etc"),
          etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: gl.getExtension("WEBGL_compressed_texture_atc"),
          astc: gl.getExtension("WEBGL_compressed_texture_astc")
        };
        CompressedTextureLoader2._textureExtensions = extensions2;
      }
      return CompressedTextureLoader2._textureExtensions;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CompressedTextureLoader2, "textureFormats", {
    get: function() {
      if (!CompressedTextureLoader2._textureFormats) {
        var extensions2 = CompressedTextureLoader2.textureExtensions;
        CompressedTextureLoader2._textureFormats = {};
        for (var extensionName in extensions2) {
          var extension = extensions2[extensionName];
          if (!extension) {
            continue;
          }
          Object.assign(CompressedTextureLoader2._textureFormats, Object.getPrototypeOf(extension));
        }
      }
      return CompressedTextureLoader2._textureFormats;
    },
    enumerable: false,
    configurable: true
  });
  CompressedTextureLoader2.extension = ExtensionType.Loader;
  return CompressedTextureLoader2;
}();
function registerCompressedTextures(url2, resources, metadata) {
  var result = {
    textures: {},
    texture: null
  };
  if (!resources) {
    return result;
  }
  var textures = resources.map(function(resource) {
    return new Texture(new BaseTexture(resource, Object.assign({
      mipmap: MIPMAP_MODES.OFF,
      alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA
    }, metadata)));
  });
  textures.forEach(function(texture, i) {
    var baseTexture = texture.baseTexture;
    var cacheID = url2 + "-" + (i + 1);
    BaseTexture.addToCache(baseTexture, cacheID);
    Texture.addToCache(texture, cacheID);
    if (i === 0) {
      BaseTexture.addToCache(baseTexture, url2);
      Texture.addToCache(texture, url2);
      result.texture = texture;
    }
    result.textures[cacheID] = texture;
  });
  return result;
}
var _a$1, _b$1;
var DDS_MAGIC_SIZE = 4;
var DDS_HEADER_SIZE = 124;
var DDS_HEADER_PF_SIZE = 32;
var DDS_HEADER_DX10_SIZE = 20;
var DDS_MAGIC = 542327876;
var DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
};
var DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
};
var DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
};
var DXGI_FORMAT;
(function(DXGI_FORMAT2) {
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
})(DXGI_FORMAT || (DXGI_FORMAT = {}));
var D3D10_RESOURCE_DIMENSION;
(function(D3D10_RESOURCE_DIMENSION2) {
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
})(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));
var PF_FLAGS = 1;
var DDPF_ALPHA = 2;
var DDPF_FOURCC = 4;
var DDPF_RGB = 64;
var DDPF_YUV = 512;
var DDPF_LUMINANCE = 131072;
var FOURCC_DXT1 = 827611204;
var FOURCC_DXT3 = 861165636;
var FOURCC_DXT5 = 894720068;
var FOURCC_DX10 = 808540228;
var DDS_RESOURCE_MISC_TEXTURECUBE = 4;
var FOURCC_TO_FORMAT = (_a$1 = {}, _a$1[FOURCC_DXT1] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1[FOURCC_DXT3] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1[FOURCC_DXT5] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1);
var DXGI_TO_FORMAT = (_b$1 = {}, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b$1);
function parseDDS(arrayBuffer) {
  var data = new Uint32Array(arrayBuffer);
  var magicWord = data[0];
  if (magicWord !== DDS_MAGIC) {
    throw new Error("Invalid DDS file magic word");
  }
  var header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  var height = header[DDS_FIELDS.HEIGHT];
  var width = header[DDS_FIELDS.WIDTH];
  var mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
  var pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  var formatFlags = pixelFormat[PF_FLAGS];
  if (formatFlags & DDPF_FOURCC) {
    var fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
    if (fourCC !== FOURCC_DX10) {
      var internalFormat_1 = FOURCC_TO_FORMAT[fourCC];
      var dataOffset_1 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
      var texData = new Uint8Array(arrayBuffer, dataOffset_1);
      var resource = new CompressedTextureResource(texData, {
        format: internalFormat_1,
        width,
        height,
        levels: mipmapCount
      });
      return [resource];
    }
    var dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
    var dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    var dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
    var resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
    var miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
    var arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
    var internalFormat_2 = DXGI_TO_FORMAT[dxgiFormat];
    if (internalFormat_2 === void 0) {
      throw new Error("DDSParser cannot parse texture data with DXGI format " + dxgiFormat);
    }
    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
      throw new Error("DDSParser does not support cubemap textures");
    }
    if (resourceDimension === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) {
      throw new Error("DDSParser does not supported 3D texture data");
    }
    var imageBuffers = new Array();
    var dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (arraySize === 1) {
      imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
    } else {
      var pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat_2];
      var imageSize = 0;
      var levelWidth = width;
      var levelHeight = height;
      for (var i = 0; i < mipmapCount; i++) {
        var alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
        var alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
        var levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
        imageSize += levelSize;
        levelWidth = levelWidth >>> 1;
        levelHeight = levelHeight >>> 1;
      }
      var imageOffset = dataOffset;
      for (var i = 0; i < arraySize; i++) {
        imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
        imageOffset += imageSize;
      }
    }
    return imageBuffers.map(function(buffer) {
      return new CompressedTextureResource(buffer, {
        format: internalFormat_2,
        width,
        height,
        levels: mipmapCount
      });
    });
  }
  if (formatFlags & DDPF_RGB) {
    throw new Error("DDSParser does not support uncompressed texture data.");
  }
  if (formatFlags & DDPF_YUV) {
    throw new Error("DDSParser does not supported YUV uncompressed texture data.");
  }
  if (formatFlags & DDPF_LUMINANCE) {
    throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
  }
  if (formatFlags & DDPF_ALPHA) {
    throw new Error("DDSParser does not support single-channel (alpha) texture data!");
  }
  throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
var _a$3, _b, _c;
var FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
var ENDIANNESS = 67305985;
var KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
};
var FILE_HEADER_SIZE = 64;
var TYPES_TO_BYTES_PER_COMPONENT = (_a$3 = {}, _a$3[TYPES.UNSIGNED_BYTE] = 1, _a$3[TYPES.UNSIGNED_SHORT] = 2, _a$3[TYPES.INT] = 4, _a$3[TYPES.UNSIGNED_INT] = 4, _a$3[TYPES.FLOAT] = 4, _a$3[TYPES.HALF_FLOAT] = 8, _a$3);
var FORMATS_TO_COMPONENTS = (_b = {}, _b[FORMATS.RGBA] = 4, _b[FORMATS.RGB] = 3, _b[FORMATS.RG] = 2, _b[FORMATS.RED] = 1, _b[FORMATS.LUMINANCE] = 1, _b[FORMATS.LUMINANCE_ALPHA] = 2, _b[FORMATS.ALPHA] = 1, _b);
var TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[TYPES.UNSIGNED_SHORT_4_4_4_4] = 2, _c[TYPES.UNSIGNED_SHORT_5_5_5_1] = 2, _c[TYPES.UNSIGNED_SHORT_5_6_5] = 2, _c);
function parseKTX(url2, arrayBuffer, loadKeyValueData) {
  if (loadKeyValueData === void 0) {
    loadKeyValueData = false;
  }
  var dataView = new DataView(arrayBuffer);
  if (!validate(url2, dataView)) {
    return null;
  }
  var littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
  var glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
  var glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
  var glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
  var pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
  var pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
  var pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
  var numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
  var numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
  var numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
  var bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
  if (pixelHeight === 0 || pixelDepth !== 1) {
    throw new Error("Only 2D textures are supported");
  }
  if (numberOfFaces !== 1) {
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  }
  if (numberOfArrayElements !== 1) {
    throw new Error("WebGL does not support array textures");
  }
  var blockWidth = 4;
  var blockHeight = 4;
  var alignedWidth = pixelWidth + 3 & ~3;
  var alignedHeight = pixelHeight + 3 & ~3;
  var imageBuffers = new Array(numberOfArrayElements);
  var imagePixels = pixelWidth * pixelHeight;
  if (glType === 0) {
    imagePixels = alignedWidth * alignedHeight;
  }
  var imagePixelByteSize;
  if (glType !== 0) {
    if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
      imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
    } else {
      imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
    }
  } else {
    imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
  }
  if (imagePixelByteSize === void 0) {
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  }
  var kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
  var imageByteSize = imagePixels * imagePixelByteSize;
  var mipByteSize = imageByteSize;
  var mipWidth = pixelWidth;
  var mipHeight = pixelHeight;
  var alignedMipWidth = alignedWidth;
  var alignedMipHeight = alignedHeight;
  var imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
  for (var mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
    var imageSize = dataView.getUint32(imageOffset, littleEndian);
    var elementOffset = imageOffset + 4;
    for (var arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
      var mips = imageBuffers[arrayElement];
      if (!mips) {
        mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
      }
      mips[mipmapLevel] = {
        levelID: mipmapLevel,
        levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
        levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
        levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
      };
      elementOffset += mipByteSize;
    }
    imageOffset += imageSize + 4;
    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
    mipWidth = mipWidth >> 1 || 1;
    mipHeight = mipHeight >> 1 || 1;
    alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
    alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
  }
  if (glType !== 0) {
    return {
      uncompressed: imageBuffers.map(function(levelBuffers) {
        var buffer = levelBuffers[0].levelBuffer;
        var convertToInt = false;
        if (glType === TYPES.FLOAT) {
          buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === TYPES.UNSIGNED_INT) {
          convertToInt = true;
          buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === TYPES.INT) {
          convertToInt = true;
          buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        }
        return {
          resource: new BufferResource(buffer, {
            width: levelBuffers[0].levelWidth,
            height: levelBuffers[0].levelHeight
          }),
          type: glType,
          format: convertToInt ? convertFormatToInteger(glFormat) : glFormat
        };
      }),
      kvData
    };
  }
  return {
    compressed: imageBuffers.map(function(levelBuffers) {
      return new CompressedTextureResource(null, {
        format: glInternalFormat,
        width: pixelWidth,
        height: pixelHeight,
        levels: numberOfMipmapLevels,
        levelBuffers
      });
    }),
    kvData
  };
}
function validate(url2, dataView) {
  for (var i = 0; i < FILE_IDENTIFIER.length; i++) {
    if (dataView.getUint8(i) !== FILE_IDENTIFIER[i]) {
      console.error(url2 + " is not a valid *.ktx file!");
      return false;
    }
  }
  return true;
}
function convertFormatToInteger(format2) {
  switch (format2) {
    case FORMATS.RGBA:
      return FORMATS.RGBA_INTEGER;
    case FORMATS.RGB:
      return FORMATS.RGB_INTEGER;
    case FORMATS.RG:
      return FORMATS.RG_INTEGER;
    case FORMATS.RED:
      return FORMATS.RED_INTEGER;
    default:
      return format2;
  }
}
function parseKvData(dataView, bytesOfKeyValueData, littleEndian) {
  var kvData = /* @__PURE__ */ new Map();
  var bytesIntoKeyValueData = 0;
  while (bytesIntoKeyValueData < bytesOfKeyValueData) {
    var keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian);
    var keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4;
    var valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
    if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    var keyNulByte = 0;
    for (; keyNulByte < keyAndValueByteSize; keyNulByte++) {
      if (dataView.getUint8(keyAndValueByteOffset + keyNulByte) === 0) {
        break;
      }
    }
    if (keyNulByte === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    var key = new TextDecoder().decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));
    var value = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);
    kvData.set(key, value);
    bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
  }
  return kvData;
}
LoaderResource.setExtensionXhrType("dds", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var DDSLoader = function() {
  function DDSLoader2() {
  }
  DDSLoader2.use = function(resource, next) {
    if (resource.extension === "dds" && resource.data) {
      try {
        Object.assign(resource, registerCompressedTextures(resource.name || resource.url, parseDDS(resource.data), resource.metadata));
      } catch (err) {
        next(err);
        return;
      }
    }
    next();
  };
  DDSLoader2.extension = ExtensionType.Loader;
  return DDSLoader2;
}();
LoaderResource.setExtensionXhrType("ktx", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var KTXLoader = function() {
  function KTXLoader2() {
  }
  KTXLoader2.use = function(resource, next) {
    if (resource.extension === "ktx" && resource.data) {
      try {
        var url_1 = resource.name || resource.url;
        var _a2 = parseKTX(url_1, resource.data, this.loadKeyValueData), compressed = _a2.compressed, uncompressed = _a2.uncompressed, kvData_1 = _a2.kvData;
        if (compressed) {
          var result = registerCompressedTextures(url_1, compressed, resource.metadata);
          if (kvData_1 && result.textures) {
            for (var textureId in result.textures) {
              result.textures[textureId].baseTexture.ktxKeyValueData = kvData_1;
            }
          }
          Object.assign(resource, result);
        } else if (uncompressed) {
          var textures_1 = {};
          uncompressed.forEach(function(image, i) {
            var texture = new Texture(new BaseTexture(image.resource, {
              mipmap: MIPMAP_MODES.OFF,
              alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
              type: image.type,
              format: image.format
            }));
            var cacheID = url_1 + "-" + (i + 1);
            if (kvData_1) {
              texture.baseTexture.ktxKeyValueData = kvData_1;
            }
            BaseTexture.addToCache(texture.baseTexture, cacheID);
            Texture.addToCache(texture, cacheID);
            if (i === 0) {
              textures_1[url_1] = texture;
              BaseTexture.addToCache(texture.baseTexture, url_1);
              Texture.addToCache(texture, url_1);
            }
            textures_1[cacheID] = texture;
          });
          Object.assign(resource, { textures: textures_1 });
        }
      } catch (err) {
        next(err);
        return;
      }
    }
    next();
  };
  KTXLoader2.extension = ExtensionType.Loader;
  KTXLoader2.loadKeyValueData = false;
  return KTXLoader2;
}();
/*!
 * @pixi/particle-container - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$f = function(d2, b2) {
  extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$f(d2, b2);
};
function __extends$f(d2, b2) {
  extendStatics$f(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
(function(_super) {
  __extends$f(ParticleContainer, _super);
  function ParticleContainer(maxSize, properties, batchSize, autoResize) {
    if (maxSize === void 0) {
      maxSize = 1500;
    }
    if (batchSize === void 0) {
      batchSize = 16384;
    }
    if (autoResize === void 0) {
      autoResize = false;
    }
    var _this = _super.call(this) || this;
    var maxBatchSize = 16384;
    if (batchSize > maxBatchSize) {
      batchSize = maxBatchSize;
    }
    _this._properties = [false, true, false, false, false];
    _this._maxSize = maxSize;
    _this._batchSize = batchSize;
    _this._buffers = null;
    _this._bufferUpdateIDs = [];
    _this._updateID = 0;
    _this.interactiveChildren = false;
    _this.blendMode = BLEND_MODES.NORMAL;
    _this.autoResize = autoResize;
    _this.roundPixels = true;
    _this.baseTexture = null;
    _this.setProperties(properties);
    _this._tint = 0;
    _this.tintRgb = new Float32Array(4);
    _this.tint = 16777215;
    return _this;
  }
  ParticleContainer.prototype.setProperties = function(properties) {
    if (properties) {
      this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
      this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
      this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
      this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
      this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
    }
  };
  ParticleContainer.prototype.updateTransform = function() {
    this.displayObjectUpdateTransform();
  };
  Object.defineProperty(ParticleContainer.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      this._tint = value;
      hex2rgb(value, this.tintRgb);
    },
    enumerable: false,
    configurable: true
  });
  ParticleContainer.prototype.render = function(renderer2) {
    var _this = this;
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
      return;
    }
    if (!this.baseTexture) {
      this.baseTexture = this.children[0]._texture.baseTexture;
      if (!this.baseTexture.valid) {
        this.baseTexture.once("update", function() {
          return _this.onChildrenChange(0);
        });
      }
    }
    renderer2.batch.setObjectRenderer(renderer2.plugins.particle);
    renderer2.plugins.particle.render(this);
  };
  ParticleContainer.prototype.onChildrenChange = function(smallestChildIndex) {
    var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
    while (this._bufferUpdateIDs.length < bufferIndex) {
      this._bufferUpdateIDs.push(0);
    }
    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
  };
  ParticleContainer.prototype.dispose = function() {
    if (this._buffers) {
      for (var i = 0; i < this._buffers.length; ++i) {
        this._buffers[i].destroy();
      }
      this._buffers = null;
    }
  };
  ParticleContainer.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    this.dispose();
    this._properties = null;
    this._buffers = null;
    this._bufferUpdateIDs = null;
  };
  return ParticleContainer;
})(Container);
var ParticleBuffer = function() {
  function ParticleBuffer2(properties, dynamicPropertyFlags, size) {
    this.geometry = new Geometry();
    this.indexBuffer = null;
    this.size = size;
    this.dynamicProperties = [];
    this.staticProperties = [];
    for (var i = 0; i < properties.length; ++i) {
      var property = properties[i];
      property = {
        attributeName: property.attributeName,
        size: property.size,
        uploadFunction: property.uploadFunction,
        type: property.type || TYPES.FLOAT,
        offset: property.offset
      };
      if (dynamicPropertyFlags[i]) {
        this.dynamicProperties.push(property);
      } else {
        this.staticProperties.push(property);
      }
    }
    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this._updateID = 0;
    this.initBuffers();
  }
  ParticleBuffer2.prototype.initBuffers = function() {
    var geometry = this.geometry;
    var dynamicOffset = 0;
    this.indexBuffer = new Buffer(createIndicesForQuads(this.size), true, true);
    geometry.addIndex(this.indexBuffer);
    this.dynamicStride = 0;
    for (var i = 0; i < this.dynamicProperties.length; ++i) {
      var property = this.dynamicProperties[i];
      property.offset = dynamicOffset;
      dynamicOffset += property.size;
      this.dynamicStride += property.size;
    }
    var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(dynBuffer);
    this.dynamicDataUint32 = new Uint32Array(dynBuffer);
    this.dynamicBuffer = new Buffer(this.dynamicData, false, false);
    var staticOffset = 0;
    this.staticStride = 0;
    for (var i = 0; i < this.staticProperties.length; ++i) {
      var property = this.staticProperties[i];
      property.offset = staticOffset;
      staticOffset += property.size;
      this.staticStride += property.size;
    }
    var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(statBuffer);
    this.staticDataUint32 = new Uint32Array(statBuffer);
    this.staticBuffer = new Buffer(this.staticData, true, false);
    for (var i = 0; i < this.dynamicProperties.length; ++i) {
      var property = this.dynamicProperties[i];
      geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
    }
    for (var i = 0; i < this.staticProperties.length; ++i) {
      var property = this.staticProperties[i];
      geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
    }
  };
  ParticleBuffer2.prototype.uploadDynamic = function(children, startIndex, amount) {
    for (var i = 0; i < this.dynamicProperties.length; i++) {
      var property = this.dynamicProperties[i];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
    }
    this.dynamicBuffer._updateID++;
  };
  ParticleBuffer2.prototype.uploadStatic = function(children, startIndex, amount) {
    for (var i = 0; i < this.staticProperties.length; i++) {
      var property = this.staticProperties[i];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
    }
    this.staticBuffer._updateID++;
  };
  ParticleBuffer2.prototype.destroy = function() {
    this.indexBuffer = null;
    this.dynamicProperties = null;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this.staticProperties = null;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.geometry.destroy();
  };
  return ParticleBuffer2;
}();
var fragment$6 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";
var vertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";
var ParticleRenderer = function(_super) {
  __extends$f(ParticleRenderer2, _super);
  function ParticleRenderer2(renderer2) {
    var _this = _super.call(this, renderer2) || this;
    _this.shader = null;
    _this.properties = null;
    _this.tempMatrix = new Matrix();
    _this.properties = [
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: _this.uploadVertices,
        offset: 0
      },
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: _this.uploadPosition,
        offset: 0
      },
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: _this.uploadRotation,
        offset: 0
      },
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: _this.uploadUvs,
        offset: 0
      },
      {
        attributeName: "aColor",
        size: 1,
        type: TYPES.UNSIGNED_BYTE,
        uploadFunction: _this.uploadTint,
        offset: 0
      }
    ];
    _this.shader = Shader.from(vertex$3, fragment$6, {});
    _this.state = State.for2d();
    return _this;
  }
  ParticleRenderer2.prototype.render = function(container) {
    var children = container.children;
    var maxSize = container._maxSize;
    var batchSize = container._batchSize;
    var renderer2 = this.renderer;
    var totalChildren = children.length;
    if (totalChildren === 0) {
      return;
    } else if (totalChildren > maxSize && !container.autoResize) {
      totalChildren = maxSize;
    }
    var buffers = container._buffers;
    if (!buffers) {
      buffers = container._buffers = this.generateBuffers(container);
    }
    var baseTexture = children[0]._texture.baseTexture;
    var premultiplied = baseTexture.alphaMode > 0;
    this.state.blendMode = correctBlendMode(container.blendMode, premultiplied);
    renderer2.state.set(this.state);
    var gl = renderer2.gl;
    var m2 = container.worldTransform.copyTo(this.tempMatrix);
    m2.prepend(renderer2.globalUniforms.uniforms.projectionMatrix);
    this.shader.uniforms.translationMatrix = m2.toArray(true);
    this.shader.uniforms.uColor = premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, premultiplied);
    this.shader.uniforms.uSampler = baseTexture;
    this.renderer.shader.bind(this.shader);
    var updateStatic = false;
    for (var i = 0, j2 = 0; i < totalChildren; i += batchSize, j2 += 1) {
      var amount = totalChildren - i;
      if (amount > batchSize) {
        amount = batchSize;
      }
      if (j2 >= buffers.length) {
        buffers.push(this._generateOneMoreBuffer(container));
      }
      var buffer = buffers[j2];
      buffer.uploadDynamic(children, i, amount);
      var bid = container._bufferUpdateIDs[j2] || 0;
      updateStatic = updateStatic || buffer._updateID < bid;
      if (updateStatic) {
        buffer._updateID = container._updateID;
        buffer.uploadStatic(children, i, amount);
      }
      renderer2.geometry.bind(buffer.geometry);
      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
    }
  };
  ParticleRenderer2.prototype.generateBuffers = function(container) {
    var buffers = [];
    var size = container._maxSize;
    var batchSize = container._batchSize;
    var dynamicPropertyFlags = container._properties;
    for (var i = 0; i < size; i += batchSize) {
      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
    }
    return buffers;
  };
  ParticleRenderer2.prototype._generateOneMoreBuffer = function(container) {
    var batchSize = container._batchSize;
    var dynamicPropertyFlags = container._properties;
    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
  };
  ParticleRenderer2.prototype.uploadVertices = function(children, startIndex, amount, array, stride, offset) {
    var w0 = 0;
    var w1 = 0;
    var h0 = 0;
    var h1 = 0;
    for (var i = 0; i < amount; ++i) {
      var sprite = children[startIndex + i];
      var texture = sprite._texture;
      var sx = sprite.scale.x;
      var sy = sprite.scale.y;
      var trim3 = texture.trim;
      var orig = texture.orig;
      if (trim3) {
        w1 = trim3.x - sprite.anchor.x * orig.width;
        w0 = w1 + trim3.width;
        h1 = trim3.y - sprite.anchor.y * orig.height;
        h0 = h1 + trim3.height;
      } else {
        w0 = orig.width * (1 - sprite.anchor.x);
        w1 = orig.width * -sprite.anchor.x;
        h0 = orig.height * (1 - sprite.anchor.y);
        h1 = orig.height * -sprite.anchor.y;
      }
      array[offset] = w1 * sx;
      array[offset + 1] = h1 * sy;
      array[offset + stride] = w0 * sx;
      array[offset + stride + 1] = h1 * sy;
      array[offset + stride * 2] = w0 * sx;
      array[offset + stride * 2 + 1] = h0 * sy;
      array[offset + stride * 3] = w1 * sx;
      array[offset + stride * 3 + 1] = h0 * sy;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.uploadPosition = function(children, startIndex, amount, array, stride, offset) {
    for (var i = 0; i < amount; i++) {
      var spritePosition = children[startIndex + i].position;
      array[offset] = spritePosition.x;
      array[offset + 1] = spritePosition.y;
      array[offset + stride] = spritePosition.x;
      array[offset + stride + 1] = spritePosition.y;
      array[offset + stride * 2] = spritePosition.x;
      array[offset + stride * 2 + 1] = spritePosition.y;
      array[offset + stride * 3] = spritePosition.x;
      array[offset + stride * 3 + 1] = spritePosition.y;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.uploadRotation = function(children, startIndex, amount, array, stride, offset) {
    for (var i = 0; i < amount; i++) {
      var spriteRotation = children[startIndex + i].rotation;
      array[offset] = spriteRotation;
      array[offset + stride] = spriteRotation;
      array[offset + stride * 2] = spriteRotation;
      array[offset + stride * 3] = spriteRotation;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.uploadUvs = function(children, startIndex, amount, array, stride, offset) {
    for (var i = 0; i < amount; ++i) {
      var textureUvs = children[startIndex + i]._texture._uvs;
      if (textureUvs) {
        array[offset] = textureUvs.x0;
        array[offset + 1] = textureUvs.y0;
        array[offset + stride] = textureUvs.x1;
        array[offset + stride + 1] = textureUvs.y1;
        array[offset + stride * 2] = textureUvs.x2;
        array[offset + stride * 2 + 1] = textureUvs.y2;
        array[offset + stride * 3] = textureUvs.x3;
        array[offset + stride * 3 + 1] = textureUvs.y3;
        offset += stride * 4;
      } else {
        array[offset] = 0;
        array[offset + 1] = 0;
        array[offset + stride] = 0;
        array[offset + stride + 1] = 0;
        array[offset + stride * 2] = 0;
        array[offset + stride * 2 + 1] = 0;
        array[offset + stride * 3] = 0;
        array[offset + stride * 3 + 1] = 0;
        offset += stride * 4;
      }
    }
  };
  ParticleRenderer2.prototype.uploadTint = function(children, startIndex, amount, array, stride, offset) {
    for (var i = 0; i < amount; ++i) {
      var sprite = children[startIndex + i];
      var premultiplied = sprite._texture.baseTexture.alphaMode > 0;
      var alpha = sprite.alpha;
      var argb = alpha < 1 && premultiplied ? premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);
      array[offset] = argb;
      array[offset + stride] = argb;
      array[offset + stride * 2] = argb;
      array[offset + stride * 3] = argb;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    if (this.shader) {
      this.shader.destroy();
      this.shader = null;
    }
    this.tempMatrix = null;
  };
  ParticleRenderer2.extension = {
    name: "particle",
    type: ExtensionType.RendererPlugin
  };
  return ParticleRenderer2;
}(ObjectRenderer);
/*!
 * @pixi/graphics - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var LINE_JOIN;
(function(LINE_JOIN2) {
  LINE_JOIN2["MITER"] = "miter";
  LINE_JOIN2["BEVEL"] = "bevel";
  LINE_JOIN2["ROUND"] = "round";
})(LINE_JOIN || (LINE_JOIN = {}));
var LINE_CAP;
(function(LINE_CAP2) {
  LINE_CAP2["BUTT"] = "butt";
  LINE_CAP2["ROUND"] = "round";
  LINE_CAP2["SQUARE"] = "square";
})(LINE_CAP || (LINE_CAP = {}));
var GRAPHICS_CURVES = {
  adaptive: true,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount: function(length, defaultSegments) {
    if (defaultSegments === void 0) {
      defaultSegments = 20;
    }
    if (!this.adaptive || !length || isNaN(length)) {
      return defaultSegments;
    }
    var result = Math.ceil(length / this.maxLength);
    if (result < this.minSegments) {
      result = this.minSegments;
    } else if (result > this.maxSegments) {
      result = this.maxSegments;
    }
    return result;
  }
};
var FillStyle = function() {
  function FillStyle2() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
    this.reset();
  }
  FillStyle2.prototype.clone = function() {
    var obj = new FillStyle2();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    return obj;
  };
  FillStyle2.prototype.reset = function() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
  };
  FillStyle2.prototype.destroy = function() {
    this.texture = null;
    this.matrix = null;
  };
  return FillStyle2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$e = function(d2, b2) {
  extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$e(d2, b2);
};
function __extends$e(d2, b2) {
  extendStatics$e(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function fixOrientation(points, hole) {
  var _a2, _b2;
  if (hole === void 0) {
    hole = false;
  }
  var m2 = points.length;
  if (m2 < 6) {
    return;
  }
  var area2 = 0;
  for (var i = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i < m2; i += 2) {
    var x2 = points[i];
    var y2 = points[i + 1];
    area2 += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (!hole && area2 > 0 || hole && area2 <= 0) {
    var n2 = m2 / 2;
    for (var i = n2 + n2 % 2; i < m2; i += 2) {
      var i1 = m2 - i - 2;
      var i2 = m2 - i - 1;
      var i3 = i;
      var i4 = i + 1;
      _a2 = [points[i3], points[i1]], points[i1] = _a2[0], points[i3] = _a2[1];
      _b2 = [points[i4], points[i2]], points[i2] = _b2[0], points[i4] = _b2[1];
    }
  }
}
var buildPoly = {
  build: function(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var holes = graphicsData.holes;
    var verts = graphicsGeometry.points;
    var indices3 = graphicsGeometry.indices;
    if (points.length >= 6) {
      fixOrientation(points, false);
      var holeArray = [];
      for (var i = 0; i < holes.length; i++) {
        var hole = holes[i];
        fixOrientation(hole.points, true);
        holeArray.push(points.length / 2);
        points = points.concat(hole.points);
      }
      var triangles = earcut$1(points, holeArray, 2);
      if (!triangles) {
        return;
      }
      var vertPos = verts.length / 2;
      for (var i = 0; i < triangles.length; i += 3) {
        indices3.push(triangles[i] + vertPos);
        indices3.push(triangles[i + 1] + vertPos);
        indices3.push(triangles[i + 2] + vertPos);
      }
      for (var i = 0; i < points.length; i++) {
        verts.push(points[i]);
      }
    }
  }
};
var buildCircle = {
  build: function(graphicsData) {
    var points = graphicsData.points;
    var x2;
    var y2;
    var dx;
    var dy;
    var rx;
    var ry;
    if (graphicsData.type === SHAPES.CIRC) {
      var circle = graphicsData.shape;
      x2 = circle.x;
      y2 = circle.y;
      rx = ry = circle.radius;
      dx = dy = 0;
    } else if (graphicsData.type === SHAPES.ELIP) {
      var ellipse = graphicsData.shape;
      x2 = ellipse.x;
      y2 = ellipse.y;
      rx = ellipse.width;
      ry = ellipse.height;
      dx = dy = 0;
    } else {
      var roundedRect = graphicsData.shape;
      var halfWidth = roundedRect.width / 2;
      var halfHeight = roundedRect.height / 2;
      x2 = roundedRect.x + halfWidth;
      y2 = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
      points.length = 0;
      return;
    }
    var n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
    var m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    points.length = m2;
    if (m2 === 0) {
      return;
    }
    if (n2 === 0) {
      points.length = 8;
      points[0] = points[6] = x2 + dx;
      points[1] = points[3] = y2 + dy;
      points[2] = points[4] = x2 - dx;
      points[5] = points[7] = y2 - dy;
      return;
    }
    var j1 = 0;
    var j2 = n2 * 4 + (dx ? 2 : 0) + 2;
    var j3 = j2;
    var j4 = m2;
    {
      var x0 = dx + rx;
      var y0 = dy;
      var x1 = x2 + x0;
      var x22 = x2 - x0;
      var y1 = y2 + y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x22;
      if (dy) {
        var y22 = y2 - y0;
        points[j3++] = x22;
        points[j3++] = y22;
        points[--j4] = y22;
        points[--j4] = x1;
      }
    }
    for (var i = 1; i < n2; i++) {
      var a2 = Math.PI / 2 * (i / n2);
      var x0 = dx + Math.cos(a2) * rx;
      var y0 = dy + Math.sin(a2) * ry;
      var x1 = x2 + x0;
      var x22 = x2 - x0;
      var y1 = y2 + y0;
      var y22 = y2 - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x22;
      points[j3++] = x22;
      points[j3++] = y22;
      points[--j4] = y22;
      points[--j4] = x1;
    }
    {
      var x0 = dx;
      var y0 = dy + ry;
      var x1 = x2 + x0;
      var x22 = x2 - x0;
      var y1 = y2 + y0;
      var y22 = y2 - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j4] = y22;
      points[--j4] = x1;
      if (dx) {
        points[j1++] = x22;
        points[j1++] = y1;
        points[--j4] = y22;
        points[--j4] = x22;
      }
    }
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var indices3 = graphicsGeometry.indices;
    if (points.length === 0) {
      return;
    }
    var vertPos = verts.length / 2;
    var center = vertPos;
    var x2;
    var y2;
    if (graphicsData.type !== SHAPES.RREC) {
      var circle = graphicsData.shape;
      x2 = circle.x;
      y2 = circle.y;
    } else {
      var roundedRect = graphicsData.shape;
      x2 = roundedRect.x + roundedRect.width / 2;
      y2 = roundedRect.y + roundedRect.height / 2;
    }
    var matrix = graphicsData.matrix;
    verts.push(graphicsData.matrix ? matrix.a * x2 + matrix.c * y2 + matrix.tx : x2, graphicsData.matrix ? matrix.b * x2 + matrix.d * y2 + matrix.ty : y2);
    vertPos++;
    verts.push(points[0], points[1]);
    for (var i = 2; i < points.length; i += 2) {
      verts.push(points[i], points[i + 1]);
      indices3.push(vertPos++, center, vertPos);
    }
    indices3.push(center + 1, center, vertPos);
  }
};
var buildRectangle = {
  build: function(graphicsData) {
    var rectData = graphicsData.shape;
    var x2 = rectData.x;
    var y2 = rectData.y;
    var width = rectData.width;
    var height = rectData.height;
    var points = graphicsData.points;
    points.length = 0;
    points.push(x2, y2, x2 + width, y2, x2 + width, y2 + height, x2, y2 + height);
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var vertPos = verts.length / 2;
    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
  }
};
function getPt(n1, n2, perc) {
  var diff = n2 - n1;
  return n1 + diff * perc;
}
function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {
  if (out === void 0) {
    out = [];
  }
  var n2 = 20;
  var points = out;
  var xa = 0;
  var ya = 0;
  var xb = 0;
  var yb = 0;
  var x2 = 0;
  var y2 = 0;
  for (var i = 0, j2 = 0; i <= n2; ++i) {
    j2 = i / n2;
    xa = getPt(fromX, cpX, j2);
    ya = getPt(fromY, cpY, j2);
    xb = getPt(cpX, toX, j2);
    yb = getPt(cpY, toY, j2);
    x2 = getPt(xa, xb, j2);
    y2 = getPt(ya, yb, j2);
    if (i === 0 && points[points.length - 2] === x2 && points[points.length - 1] === y2) {
      continue;
    }
    points.push(x2, y2);
  }
  return points;
}
var buildRoundedRectangle = {
  build: function(graphicsData) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.build(graphicsData);
      return;
    }
    var rrectData = graphicsData.shape;
    var points = graphicsData.points;
    var x2 = rrectData.x;
    var y2 = rrectData.y;
    var width = rrectData.width;
    var height = rrectData.height;
    var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));
    points.length = 0;
    if (!radius) {
      points.push(x2, y2, x2 + width, y2, x2 + width, y2 + height, x2, y2 + height);
    } else {
      quadraticBezierCurve(x2, y2 + radius, x2, y2, x2 + radius, y2, points);
      quadraticBezierCurve(x2 + width - radius, y2, x2 + width, y2, x2 + width, y2 + radius, points);
      quadraticBezierCurve(x2 + width, y2 + height - radius, x2 + width, y2 + height, x2 + width - radius, y2 + height, points);
      quadraticBezierCurve(x2 + radius, y2 + height, x2, y2 + height, x2, y2 + height - radius, points);
    }
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.triangulate(graphicsData, graphicsGeometry);
      return;
    }
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var indices3 = graphicsGeometry.indices;
    var vecPos = verts.length / 2;
    var triangles = earcut$1(points, null, 2);
    for (var i = 0, j2 = triangles.length; i < j2; i += 3) {
      indices3.push(triangles[i] + vecPos);
      indices3.push(triangles[i + 1] + vecPos);
      indices3.push(triangles[i + 2] + vecPos);
    }
    for (var i = 0, j2 = points.length; i < j2; i++) {
      verts.push(points[i], points[++i]);
    }
  }
};
function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  var ix = x2 - nx * innerWeight;
  var iy = y2 - ny * innerWeight;
  var ox = x2 + nx * outerWeight;
  var oy = y2 + ny * outerWeight;
  var exx;
  var eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  var eix = ix + exx;
  var eiy = iy + eyy;
  var eox = ox + exx;
  var eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  var cx2p0x = sx - cx;
  var cy2p0y = sy - cy;
  var angle0 = Math.atan2(cx2p0x, cy2p0y);
  var angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  var startAngle = angle0;
  var angleDiff = angle1 - angle0;
  var absAngleDiff = Math.abs(angleDiff);
  var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  var angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  var shape = graphicsData.shape;
  var points = graphicsData.points || shape.points.slice();
  var eps = graphicsGeometry.closePointEps;
  if (points.length === 0) {
    return;
  }
  var style = graphicsData.lineStyle;
  var firstPoint = new Point(points[0], points[1]);
  var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    var midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    var midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  var verts = graphicsGeometry.points;
  var length = points.length / 2;
  var indexCount = points.length;
  var indexStart = verts.length / 2;
  var width = style.width / 2;
  var widthSquared = width * width;
  var miterLimitSquared = style.miterLimit * style.miterLimit;
  var x0 = points[0];
  var y0 = points[1];
  var x1 = points[2];
  var y1 = points[3];
  var x2 = 0;
  var y2 = 0;
  var perpx = -(y0 - y1);
  var perpy = x0 - x1;
  var perp1x = 0;
  var perp1y = 0;
  var dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  var ratio = style.alignment;
  var innerWeight = (1 - ratio) * 2;
  var outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);
  verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);
  for (var i = 1; i < length - 1; ++i) {
    x0 = points[(i - 1) * 2];
    y0 = points[(i - 1) * 2 + 1];
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];
    x2 = points[(i + 1) * 2];
    y2 = points[(i + 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    var dx0 = x1 - x0;
    var dy0 = y0 - y1;
    var dx1 = x1 - x2;
    var dy1 = y2 - y1;
    var dot = dx0 * dx1 + dy0 * dy1;
    var cross = dy0 * dx1 - dy1 * dx0;
    var clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (dot >= 0) {
        if (style.join === LINE_JOIN.ROUND) {
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);
        verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
      }
      continue;
    }
    var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
    var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    var px = (dx0 * c2 - dx1 * c1) / cross;
    var py = (dy1 * c1 - dy0 * c2) / cross;
    var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    var imx = x1 + (px - x1) * innerWeight;
    var imy = y1 + (py - y1) * innerWeight;
    var omx = x1 - (px - x1) * outerWeight;
    var omy = y1 - (py - y1) * outerWeight;
    var smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    var insideWeight = clockwise ? innerWeight : outerWeight;
    var smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    var insideMiterOk = pdist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === LINE_JOIN.ROUND) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(omx, omy);
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (style.join === LINE_JOIN.ROUND) {
        if (clockwise) {
          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
        } else {
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
        }
      } else if (style.join === LINE_JOIN.MITER && pdist / widthSquared <= miterLimitSquared) {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpx = -(y0 - y1);
  perpy = x0 - x1;
  dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
  verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
    }
  }
  var indices3 = graphicsGeometry.indices;
  var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;
  for (var i = indexStart; i < indexCount + indexStart - 2; ++i) {
    x0 = verts[i * 2];
    y0 = verts[i * 2 + 1];
    x1 = verts[(i + 1) * 2];
    y1 = verts[(i + 1) * 2 + 1];
    x2 = verts[(i + 2) * 2];
    y2 = verts[(i + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices3.push(i, i + 1, i + 2);
  }
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  var i = 0;
  var shape = graphicsData.shape;
  var points = graphicsData.points || shape.points;
  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  if (points.length === 0) {
    return;
  }
  var verts = graphicsGeometry.points;
  var indices3 = graphicsGeometry.indices;
  var length = points.length / 2;
  var startIndex = verts.length / 2;
  var currentIndex = startIndex;
  verts.push(points[0], points[1]);
  for (i = 1; i < length; i++) {
    verts.push(points[i * 2], points[i * 2 + 1]);
    indices3.push(currentIndex, currentIndex + 1);
    currentIndex++;
  }
  if (closedShape) {
    indices3.push(currentIndex, startIndex);
  }
}
function buildLine(graphicsData, graphicsGeometry) {
  if (graphicsData.lineStyle.native) {
    buildNativeLine(graphicsData, graphicsGeometry);
  } else {
    buildNonNativeLine(graphicsData, graphicsGeometry);
  }
}
var ArcUtils = function() {
  function ArcUtils2() {
  }
  ArcUtils2.curveTo = function(x1, y1, x2, y2, radius, points) {
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    var a1 = fromY - y1;
    var b1 = fromX - x1;
    var a2 = y2 - y1;
    var b2 = x2 - x1;
    var mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return null;
    }
    var dd = a1 * a1 + b1 * b1;
    var cc = a2 * a2 + b2 * b2;
    var tt = a1 * a2 + b1 * b2;
    var k1 = radius * Math.sqrt(dd) / mm;
    var k2 = radius * Math.sqrt(cc) / mm;
    var j1 = k1 * tt / dd;
    var j2 = k2 * tt / cc;
    var cx = k1 * b2 + k2 * b1;
    var cy = k1 * a2 + k2 * a1;
    var px = b1 * (k2 + j1);
    var py = a1 * (k2 + j1);
    var qx = b2 * (k1 + j2);
    var qy = a2 * (k1 + j2);
    var startAngle = Math.atan2(py - cy, px - cx);
    var endAngle = Math.atan2(qy - cy, qx - cx);
    return {
      cx: cx + x1,
      cy: cy + y1,
      radius,
      startAngle,
      endAngle,
      anticlockwise: b1 * a2 > b2 * a1
    };
  };
  ArcUtils2.arc = function(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
    var sweep = endAngle - startAngle;
    var n2 = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
    var theta = sweep / (n2 * 2);
    var theta2 = theta * 2;
    var cTheta = Math.cos(theta);
    var sTheta = Math.sin(theta);
    var segMinus = n2 - 1;
    var remainder = segMinus % 1 / segMinus;
    for (var i = 0; i <= segMinus; ++i) {
      var real = i + remainder * i;
      var angle = theta + startAngle + theta2 * real;
      var c = Math.cos(angle);
      var s2 = -Math.sin(angle);
      points.push((cTheta * c + sTheta * s2) * radius + cx, (cTheta * -s2 + sTheta * c) * radius + cy);
    }
  };
  return ArcUtils2;
}();
var BezierUtils = function() {
  function BezierUtils2() {
  }
  BezierUtils2.curveLength = function(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    var n2 = 10;
    var result = 0;
    var t2 = 0;
    var t22 = 0;
    var t3 = 0;
    var nt = 0;
    var nt2 = 0;
    var nt3 = 0;
    var x2 = 0;
    var y2 = 0;
    var dx = 0;
    var dy = 0;
    var prevX = fromX;
    var prevY = fromY;
    for (var i = 1; i <= n2; ++i) {
      t2 = i / n2;
      t22 = t2 * t2;
      t3 = t22 * t2;
      nt = 1 - t2;
      nt2 = nt * nt;
      nt3 = nt2 * nt;
      x2 = nt3 * fromX + 3 * nt2 * t2 * cpX + 3 * nt * t22 * cpX2 + t3 * toX;
      y2 = nt3 * fromY + 3 * nt2 * t2 * cpY + 3 * nt * t22 * cpY2 + t3 * toY;
      dx = prevX - x2;
      dy = prevY - y2;
      prevX = x2;
      prevY = y2;
      result += Math.sqrt(dx * dx + dy * dy);
    }
    return result;
  };
  BezierUtils2.curveTo = function(cpX, cpY, cpX2, cpY2, toX, toY, points) {
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    points.length -= 2;
    var n2 = GRAPHICS_CURVES._segmentsCount(BezierUtils2.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
    var dt = 0;
    var dt2 = 0;
    var dt3 = 0;
    var t2 = 0;
    var t3 = 0;
    points.push(fromX, fromY);
    for (var i = 1, j2 = 0; i <= n2; ++i) {
      j2 = i / n2;
      dt = 1 - j2;
      dt2 = dt * dt;
      dt3 = dt2 * dt;
      t2 = j2 * j2;
      t3 = t2 * j2;
      points.push(dt3 * fromX + 3 * dt2 * j2 * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j2 * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }
  };
  return BezierUtils2;
}();
var QuadraticUtils = function() {
  function QuadraticUtils2() {
  }
  QuadraticUtils2.curveLength = function(fromX, fromY, cpX, cpY, toX, toY) {
    var ax = fromX - 2 * cpX + toX;
    var ay = fromY - 2 * cpY + toY;
    var bx = 2 * cpX - 2 * fromX;
    var by = 2 * cpY - 2 * fromY;
    var a2 = 4 * (ax * ax + ay * ay);
    var b2 = 4 * (ax * bx + ay * by);
    var c = bx * bx + by * by;
    var s2 = 2 * Math.sqrt(a2 + b2 + c);
    var a22 = Math.sqrt(a2);
    var a32 = 2 * a2 * a22;
    var c2 = 2 * Math.sqrt(c);
    var ba = b2 / a22;
    return (a32 * s2 + a22 * b2 * (s2 - c2) + (4 * c * a2 - b2 * b2) * Math.log((2 * a22 + ba + s2) / (ba + c2))) / (4 * a32);
  };
  QuadraticUtils2.curveTo = function(cpX, cpY, toX, toY, points) {
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    var n2 = GRAPHICS_CURVES._segmentsCount(QuadraticUtils2.curveLength(fromX, fromY, cpX, cpY, toX, toY));
    var xa = 0;
    var ya = 0;
    for (var i = 1; i <= n2; ++i) {
      var j2 = i / n2;
      xa = fromX + (cpX - fromX) * j2;
      ya = fromY + (cpY - fromY) * j2;
      points.push(xa + (cpX + (toX - cpX) * j2 - xa) * j2, ya + (cpY + (toY - cpY) * j2 - ya) * j2);
    }
  };
  return QuadraticUtils2;
}();
var BatchPart = function() {
  function BatchPart2() {
    this.reset();
  }
  BatchPart2.prototype.begin = function(style, startIndex, attribStart) {
    this.reset();
    this.style = style;
    this.start = startIndex;
    this.attribStart = attribStart;
  };
  BatchPart2.prototype.end = function(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart;
    this.size = endIndex - this.start;
  };
  BatchPart2.prototype.reset = function() {
    this.style = null;
    this.size = 0;
    this.start = 0;
    this.attribStart = 0;
    this.attribSize = 0;
  };
  return BatchPart2;
}();
var _a;
var FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a);
var BATCH_POOL = [];
var DRAW_CALL_POOL = [];
var GraphicsData = function() {
  function GraphicsData2(shape, fillStyle, lineStyle, matrix) {
    if (fillStyle === void 0) {
      fillStyle = null;
    }
    if (lineStyle === void 0) {
      lineStyle = null;
    }
    if (matrix === void 0) {
      matrix = null;
    }
    this.points = [];
    this.holes = [];
    this.shape = shape;
    this.lineStyle = lineStyle;
    this.fillStyle = fillStyle;
    this.matrix = matrix;
    this.type = shape.type;
  }
  GraphicsData2.prototype.clone = function() {
    return new GraphicsData2(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  };
  GraphicsData2.prototype.destroy = function() {
    this.shape = null;
    this.holes.length = 0;
    this.holes = null;
    this.points.length = 0;
    this.points = null;
    this.lineStyle = null;
    this.fillStyle = null;
  };
  return GraphicsData2;
}();
var tmpPoint = new Point();
var GraphicsGeometry = function(_super) {
  __extends$e(GraphicsGeometry2, _super);
  function GraphicsGeometry2() {
    var _this = _super.call(this) || this;
    _this.closePointEps = 1e-4;
    _this.boundsPadding = 0;
    _this.uvsFloat32 = null;
    _this.indicesUint16 = null;
    _this.batchable = false;
    _this.points = [];
    _this.colors = [];
    _this.uvs = [];
    _this.indices = [];
    _this.textureIds = [];
    _this.graphicsData = [];
    _this.drawCalls = [];
    _this.batchDirty = -1;
    _this.batches = [];
    _this.dirty = 0;
    _this.cacheDirty = -1;
    _this.clearDirty = 0;
    _this.shapeIndex = 0;
    _this._bounds = new Bounds();
    _this.boundsDirty = -1;
    return _this;
  }
  Object.defineProperty(GraphicsGeometry2.prototype, "bounds", {
    get: function() {
      this.updateBatches();
      if (this.boundsDirty !== this.dirty) {
        this.boundsDirty = this.dirty;
        this.calculateBounds();
      }
      return this._bounds;
    },
    enumerable: false,
    configurable: true
  });
  GraphicsGeometry2.prototype.invalidate = function() {
    this.boundsDirty = -1;
    this.dirty++;
    this.batchDirty++;
    this.shapeIndex = 0;
    this.points.length = 0;
    this.colors.length = 0;
    this.uvs.length = 0;
    this.indices.length = 0;
    this.textureIds.length = 0;
    for (var i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    for (var i = 0; i < this.batches.length; i++) {
      var batchPart = this.batches[i];
      batchPart.reset();
      BATCH_POOL.push(batchPart);
    }
    this.batches.length = 0;
  };
  GraphicsGeometry2.prototype.clear = function() {
    if (this.graphicsData.length > 0) {
      this.invalidate();
      this.clearDirty++;
      this.graphicsData.length = 0;
    }
    return this;
  };
  GraphicsGeometry2.prototype.drawShape = function(shape, fillStyle, lineStyle, matrix) {
    if (fillStyle === void 0) {
      fillStyle = null;
    }
    if (lineStyle === void 0) {
      lineStyle = null;
    }
    if (matrix === void 0) {
      matrix = null;
    }
    var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
    this.graphicsData.push(data);
    this.dirty++;
    return this;
  };
  GraphicsGeometry2.prototype.drawHole = function(shape, matrix) {
    if (matrix === void 0) {
      matrix = null;
    }
    if (!this.graphicsData.length) {
      return null;
    }
    var data = new GraphicsData(shape, null, null, matrix);
    var lastShape = this.graphicsData[this.graphicsData.length - 1];
    data.lineStyle = lastShape.lineStyle;
    lastShape.holes.push(data);
    this.dirty++;
    return this;
  };
  GraphicsGeometry2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    for (var i = 0; i < this.graphicsData.length; ++i) {
      this.graphicsData[i].destroy();
    }
    this.points.length = 0;
    this.points = null;
    this.colors.length = 0;
    this.colors = null;
    this.uvs.length = 0;
    this.uvs = null;
    this.indices.length = 0;
    this.indices = null;
    this.indexBuffer.destroy();
    this.indexBuffer = null;
    this.graphicsData.length = 0;
    this.graphicsData = null;
    this.drawCalls.length = 0;
    this.drawCalls = null;
    this.batches.length = 0;
    this.batches = null;
    this._bounds = null;
  };
  GraphicsGeometry2.prototype.containsPoint = function(point) {
    var graphicsData = this.graphicsData;
    for (var i = 0; i < graphicsData.length; ++i) {
      var data = graphicsData[i];
      if (!data.fillStyle.visible) {
        continue;
      }
      if (data.shape) {
        if (data.matrix) {
          data.matrix.applyInverse(point, tmpPoint);
        } else {
          tmpPoint.copyFrom(point);
        }
        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
          var hitHole = false;
          if (data.holes) {
            for (var i_1 = 0; i_1 < data.holes.length; i_1++) {
              var hole = data.holes[i_1];
              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                hitHole = true;
                break;
              }
            }
          }
          if (!hitHole) {
            return true;
          }
        }
      }
    }
    return false;
  };
  GraphicsGeometry2.prototype.updateBatches = function() {
    if (!this.graphicsData.length) {
      this.batchable = true;
      return;
    }
    if (!this.validateBatching()) {
      return;
    }
    this.cacheDirty = this.dirty;
    var uvs = this.uvs;
    var graphicsData = this.graphicsData;
    var batchPart = null;
    var currentStyle = null;
    if (this.batches.length > 0) {
      batchPart = this.batches[this.batches.length - 1];
      currentStyle = batchPart.style;
    }
    for (var i = this.shapeIndex; i < graphicsData.length; i++) {
      this.shapeIndex++;
      var data = graphicsData[i];
      var fillStyle = data.fillStyle;
      var lineStyle = data.lineStyle;
      var command = FILL_COMMANDS[data.type];
      command.build(data);
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      if (fillStyle.visible || lineStyle.visible) {
        this.processHoles(data.holes);
      }
      for (var j2 = 0; j2 < 2; j2++) {
        var style = j2 === 0 ? fillStyle : lineStyle;
        if (!style.visible) {
          continue;
        }
        var nextTexture = style.texture.baseTexture;
        var index_1 = this.indices.length;
        var attribIndex = this.points.length / 2;
        nextTexture.wrapMode = WRAP_MODES.REPEAT;
        if (j2 === 0) {
          this.processFill(data);
        } else {
          this.processLine(data);
        }
        var size = this.points.length / 2 - attribIndex;
        if (size === 0) {
          continue;
        }
        if (batchPart && !this._compareStyles(currentStyle, style)) {
          batchPart.end(index_1, attribIndex);
          batchPart = null;
        }
        if (!batchPart) {
          batchPart = BATCH_POOL.pop() || new BatchPart();
          batchPart.begin(style, index_1, attribIndex);
          this.batches.push(batchPart);
          currentStyle = style;
        }
        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
      }
    }
    var index = this.indices.length;
    var attrib = this.points.length / 2;
    if (batchPart) {
      batchPart.end(index, attrib);
    }
    if (this.batches.length === 0) {
      this.batchable = true;
      return;
    }
    var need32 = attrib > 65535;
    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {
      this.indicesUint16.set(this.indices);
    } else {
      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
    }
    this.batchable = this.isBatchable();
    if (this.batchable) {
      this.packBatches();
    } else {
      this.buildDrawCalls();
    }
  };
  GraphicsGeometry2.prototype._compareStyles = function(styleA, styleB) {
    if (!styleA || !styleB) {
      return false;
    }
    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
      return false;
    }
    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
      return false;
    }
    if (!!styleA.native !== !!styleB.native) {
      return false;
    }
    return true;
  };
  GraphicsGeometry2.prototype.validateBatching = function() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
      return false;
    }
    for (var i = 0, l2 = this.graphicsData.length; i < l2; i++) {
      var data = this.graphicsData[i];
      var fill = data.fillStyle;
      var line = data.lineStyle;
      if (fill && !fill.texture.baseTexture.valid) {
        return false;
      }
      if (line && !line.texture.baseTexture.valid) {
        return false;
      }
    }
    return true;
  };
  GraphicsGeometry2.prototype.packBatches = function() {
    this.batchDirty++;
    this.uvsFloat32 = new Float32Array(this.uvs);
    var batches = this.batches;
    for (var i = 0, l2 = batches.length; i < l2; i++) {
      var batch = batches[i];
      for (var j2 = 0; j2 < batch.size; j2++) {
        var index = batch.start + j2;
        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;
      }
    }
  };
  GraphicsGeometry2.prototype.isBatchable = function() {
    if (this.points.length > 65535 * 2) {
      return false;
    }
    var batches = this.batches;
    for (var i = 0; i < batches.length; i++) {
      if (batches[i].style.native) {
        return false;
      }
    }
    return this.points.length < GraphicsGeometry2.BATCHABLE_SIZE * 2;
  };
  GraphicsGeometry2.prototype.buildDrawCalls = function() {
    var TICK = ++BaseTexture._globalBatch;
    for (var i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    var colors = this.colors;
    var textureIds = this.textureIds;
    var currentGroup = DRAW_CALL_POOL.pop();
    if (!currentGroup) {
      currentGroup = new BatchDrawCall();
      currentGroup.texArray = new BatchTextureArray();
    }
    currentGroup.texArray.count = 0;
    currentGroup.start = 0;
    currentGroup.size = 0;
    currentGroup.type = DRAW_MODES.TRIANGLES;
    var textureCount = 0;
    var currentTexture = null;
    var textureId = 0;
    var native = false;
    var drawMode = DRAW_MODES.TRIANGLES;
    var index = 0;
    this.drawCalls.push(currentGroup);
    for (var i = 0; i < this.batches.length; i++) {
      var data = this.batches[i];
      var MAX_TEXTURES = 8;
      var style = data.style;
      var nextTexture = style.texture.baseTexture;
      if (native !== !!style.native) {
        native = !!style.native;
        drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;
        currentTexture = null;
        textureCount = MAX_TEXTURES;
        TICK++;
      }
      if (currentTexture !== nextTexture) {
        currentTexture = nextTexture;
        if (nextTexture._batchEnabled !== TICK) {
          if (textureCount === MAX_TEXTURES) {
            TICK++;
            textureCount = 0;
            if (currentGroup.size > 0) {
              currentGroup = DRAW_CALL_POOL.pop();
              if (!currentGroup) {
                currentGroup = new BatchDrawCall();
                currentGroup.texArray = new BatchTextureArray();
              }
              this.drawCalls.push(currentGroup);
            }
            currentGroup.start = index;
            currentGroup.size = 0;
            currentGroup.texArray.count = 0;
            currentGroup.type = drawMode;
          }
          nextTexture.touched = 1;
          nextTexture._batchEnabled = TICK;
          nextTexture._batchLocation = textureCount;
          nextTexture.wrapMode = WRAP_MODES.REPEAT;
          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
          textureCount++;
        }
      }
      currentGroup.size += data.size;
      index += data.size;
      textureId = nextTexture._batchLocation;
      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
    }
    BaseTexture._globalBatch = TICK;
    this.packAttributes();
  };
  GraphicsGeometry2.prototype.packAttributes = function() {
    var verts = this.points;
    var uvs = this.uvs;
    var colors = this.colors;
    var textureIds = this.textureIds;
    var glPoints = new ArrayBuffer(verts.length * 3 * 4);
    var f32 = new Float32Array(glPoints);
    var u32 = new Uint32Array(glPoints);
    var p2 = 0;
    for (var i = 0; i < verts.length / 2; i++) {
      f32[p2++] = verts[i * 2];
      f32[p2++] = verts[i * 2 + 1];
      f32[p2++] = uvs[i * 2];
      f32[p2++] = uvs[i * 2 + 1];
      u32[p2++] = colors[i];
      f32[p2++] = textureIds[i];
    }
    this._buffer.update(glPoints);
    this._indexBuffer.update(this.indicesUint16);
  };
  GraphicsGeometry2.prototype.processFill = function(data) {
    if (data.holes.length) {
      buildPoly.triangulate(data, this);
    } else {
      var command = FILL_COMMANDS[data.type];
      command.triangulate(data, this);
    }
  };
  GraphicsGeometry2.prototype.processLine = function(data) {
    buildLine(data, this);
    for (var i = 0; i < data.holes.length; i++) {
      buildLine(data.holes[i], this);
    }
  };
  GraphicsGeometry2.prototype.processHoles = function(holes) {
    for (var i = 0; i < holes.length; i++) {
      var hole = holes[i];
      var command = FILL_COMMANDS[hole.type];
      command.build(hole);
      if (hole.matrix) {
        this.transformPoints(hole.points, hole.matrix);
      }
    }
  };
  GraphicsGeometry2.prototype.calculateBounds = function() {
    var bounds = this._bounds;
    bounds.clear();
    bounds.addVertexData(this.points, 0, this.points.length);
    bounds.pad(this.boundsPadding, this.boundsPadding);
  };
  GraphicsGeometry2.prototype.transformPoints = function(points, matrix) {
    for (var i = 0; i < points.length / 2; i++) {
      var x2 = points[i * 2];
      var y2 = points[i * 2 + 1];
      points[i * 2] = matrix.a * x2 + matrix.c * y2 + matrix.tx;
      points[i * 2 + 1] = matrix.b * x2 + matrix.d * y2 + matrix.ty;
    }
  };
  GraphicsGeometry2.prototype.addColors = function(colors, color, alpha, size, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var rgb = (color >> 16) + (color & 65280) + ((color & 255) << 16);
    var rgba = premultiplyTint(rgb, alpha);
    colors.length = Math.max(colors.length, offset + size);
    for (var i = 0; i < size; i++) {
      colors[offset + i] = rgba;
    }
  };
  GraphicsGeometry2.prototype.addTextureIds = function(textureIds, id, size, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    textureIds.length = Math.max(textureIds.length, offset + size);
    for (var i = 0; i < size; i++) {
      textureIds[offset + i] = id;
    }
  };
  GraphicsGeometry2.prototype.addUvs = function(verts, uvs, texture, start, size, matrix) {
    if (matrix === void 0) {
      matrix = null;
    }
    var index = 0;
    var uvsStart = uvs.length;
    var frame = texture.frame;
    while (index < size) {
      var x2 = verts[(start + index) * 2];
      var y2 = verts[(start + index) * 2 + 1];
      if (matrix) {
        var nx = matrix.a * x2 + matrix.c * y2 + matrix.tx;
        y2 = matrix.b * x2 + matrix.d * y2 + matrix.ty;
        x2 = nx;
      }
      index++;
      uvs.push(x2 / frame.width, y2 / frame.height);
    }
    var baseTexture = texture.baseTexture;
    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
      this.adjustUvs(uvs, texture, uvsStart, size);
    }
  };
  GraphicsGeometry2.prototype.adjustUvs = function(uvs, texture, start, size) {
    var baseTexture = texture.baseTexture;
    var eps = 1e-6;
    var finish = start + size * 2;
    var frame = texture.frame;
    var scaleX = frame.width / baseTexture.width;
    var scaleY = frame.height / baseTexture.height;
    var offsetX = frame.x / frame.width;
    var offsetY = frame.y / frame.height;
    var minX = Math.floor(uvs[start] + eps);
    var minY = Math.floor(uvs[start + 1] + eps);
    for (var i = start + 2; i < finish; i += 2) {
      minX = Math.min(minX, Math.floor(uvs[i] + eps));
      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
    }
    offsetX -= minX;
    offsetY -= minY;
    for (var i = start; i < finish; i += 2) {
      uvs[i] = (uvs[i] + offsetX) * scaleX;
      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;
    }
  };
  GraphicsGeometry2.BATCHABLE_SIZE = 100;
  return GraphicsGeometry2;
}(BatchGeometry);
var LineStyle = function(_super) {
  __extends$e(LineStyle2, _super);
  function LineStyle2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.width = 0;
    _this.alignment = 0.5;
    _this.native = false;
    _this.cap = LINE_CAP.BUTT;
    _this.join = LINE_JOIN.MITER;
    _this.miterLimit = 10;
    return _this;
  }
  LineStyle2.prototype.clone = function() {
    var obj = new LineStyle2();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    obj.width = this.width;
    obj.alignment = this.alignment;
    obj.native = this.native;
    obj.cap = this.cap;
    obj.join = this.join;
    obj.miterLimit = this.miterLimit;
    return obj;
  };
  LineStyle2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.color = 0;
    this.alignment = 0.5;
    this.width = 0;
    this.native = false;
  };
  return LineStyle2;
}(FillStyle);
var temp = new Float32Array(3);
var DEFAULT_SHADERS = {};
var Graphics = function(_super) {
  __extends$e(Graphics2, _super);
  function Graphics2(geometry) {
    if (geometry === void 0) {
      geometry = null;
    }
    var _this = _super.call(this) || this;
    _this.shader = null;
    _this.pluginName = "batch";
    _this.currentPath = null;
    _this.batches = [];
    _this.batchTint = -1;
    _this.batchDirty = -1;
    _this.vertexData = null;
    _this._fillStyle = new FillStyle();
    _this._lineStyle = new LineStyle();
    _this._matrix = null;
    _this._holeMode = false;
    _this.state = State.for2d();
    _this._geometry = geometry || new GraphicsGeometry();
    _this._geometry.refCount++;
    _this._transformID = -1;
    _this.tint = 16777215;
    _this.blendMode = BLEND_MODES.NORMAL;
    return _this;
  }
  Object.defineProperty(Graphics2.prototype, "geometry", {
    get: function() {
      return this._geometry;
    },
    enumerable: false,
    configurable: true
  });
  Graphics2.prototype.clone = function() {
    this.finishPoly();
    return new Graphics2(this._geometry);
  };
  Object.defineProperty(Graphics2.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(value) {
      this.state.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Graphics2.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      this._tint = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Graphics2.prototype, "fill", {
    get: function() {
      return this._fillStyle;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Graphics2.prototype, "line", {
    get: function() {
      return this._lineStyle;
    },
    enumerable: false,
    configurable: true
  });
  Graphics2.prototype.lineStyle = function(options, color, alpha, alignment, native) {
    if (options === void 0) {
      options = null;
    }
    if (color === void 0) {
      color = 0;
    }
    if (alpha === void 0) {
      alpha = 1;
    }
    if (alignment === void 0) {
      alignment = 0.5;
    }
    if (native === void 0) {
      native = false;
    }
    if (typeof options === "number") {
      options = { width: options, color, alpha, alignment, native };
    }
    return this.lineTextureStyle(options);
  };
  Graphics2.prototype.lineTextureStyle = function(options) {
    options = Object.assign({
      width: 0,
      texture: Texture.WHITE,
      color: options && options.texture ? 16777215 : 0,
      alpha: 1,
      matrix: null,
      alignment: 0.5,
      native: false,
      cap: LINE_CAP.BUTT,
      join: LINE_JOIN.MITER,
      miterLimit: 10
    }, options);
    if (this.currentPath) {
      this.startPoly();
    }
    var visible = options.width > 0 && options.alpha > 0;
    if (!visible) {
      this._lineStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._lineStyle, { visible }, options);
    }
    return this;
  };
  Graphics2.prototype.startPoly = function() {
    if (this.currentPath) {
      var points = this.currentPath.points;
      var len = this.currentPath.points.length;
      if (len > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = new Polygon();
        this.currentPath.closeStroke = false;
        this.currentPath.points.push(points[len - 2], points[len - 1]);
      }
    } else {
      this.currentPath = new Polygon();
      this.currentPath.closeStroke = false;
    }
  };
  Graphics2.prototype.finishPoly = function() {
    if (this.currentPath) {
      if (this.currentPath.points.length > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = null;
      } else {
        this.currentPath.points.length = 0;
      }
    }
  };
  Graphics2.prototype.moveTo = function(x2, y2) {
    this.startPoly();
    this.currentPath.points[0] = x2;
    this.currentPath.points[1] = y2;
    return this;
  };
  Graphics2.prototype.lineTo = function(x2, y2) {
    if (!this.currentPath) {
      this.moveTo(0, 0);
    }
    var points = this.currentPath.points;
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    if (fromX !== x2 || fromY !== y2) {
      points.push(x2, y2);
    }
    return this;
  };
  Graphics2.prototype._initCurve = function(x2, y2) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    if (this.currentPath) {
      if (this.currentPath.points.length === 0) {
        this.currentPath.points = [x2, y2];
      }
    } else {
      this.moveTo(x2, y2);
    }
  };
  Graphics2.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
    this._initCurve();
    var points = this.currentPath.points;
    if (points.length === 0) {
      this.moveTo(0, 0);
    }
    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
    return this;
  };
  Graphics2.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
    this._initCurve();
    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
    return this;
  };
  Graphics2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
    this._initCurve(x1, y1);
    var points = this.currentPath.points;
    var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
    if (result) {
      var cx = result.cx, cy = result.cy, radius_1 = result.radius, startAngle = result.startAngle, endAngle = result.endAngle, anticlockwise = result.anticlockwise;
      this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);
    }
    return this;
  };
  Graphics2.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
    if (anticlockwise === void 0) {
      anticlockwise = false;
    }
    if (startAngle === endAngle) {
      return this;
    }
    if (!anticlockwise && endAngle <= startAngle) {
      endAngle += PI_2;
    } else if (anticlockwise && startAngle <= endAngle) {
      startAngle += PI_2;
    }
    var sweep = endAngle - startAngle;
    if (sweep === 0) {
      return this;
    }
    var startX = cx + Math.cos(startAngle) * radius;
    var startY = cy + Math.sin(startAngle) * radius;
    var eps = this._geometry.closePointEps;
    var points = this.currentPath ? this.currentPath.points : null;
    if (points) {
      var xDiff = Math.abs(points[points.length - 2] - startX);
      var yDiff = Math.abs(points[points.length - 1] - startY);
      if (xDiff < eps && yDiff < eps)
        ;
      else {
        points.push(startX, startY);
      }
    } else {
      this.moveTo(startX, startY);
      points = this.currentPath.points;
    }
    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
    return this;
  };
  Graphics2.prototype.beginFill = function(color, alpha) {
    if (color === void 0) {
      color = 0;
    }
    if (alpha === void 0) {
      alpha = 1;
    }
    return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });
  };
  Graphics2.prototype.beginTextureFill = function(options) {
    options = Object.assign({
      texture: Texture.WHITE,
      color: 16777215,
      alpha: 1,
      matrix: null
    }, options);
    if (this.currentPath) {
      this.startPoly();
    }
    var visible = options.alpha > 0;
    if (!visible) {
      this._fillStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._fillStyle, { visible }, options);
    }
    return this;
  };
  Graphics2.prototype.endFill = function() {
    this.finishPoly();
    this._fillStyle.reset();
    return this;
  };
  Graphics2.prototype.drawRect = function(x2, y2, width, height) {
    return this.drawShape(new Rectangle(x2, y2, width, height));
  };
  Graphics2.prototype.drawRoundedRect = function(x2, y2, width, height, radius) {
    return this.drawShape(new RoundedRectangle(x2, y2, width, height, radius));
  };
  Graphics2.prototype.drawCircle = function(x2, y2, radius) {
    return this.drawShape(new Circle(x2, y2, radius));
  };
  Graphics2.prototype.drawEllipse = function(x2, y2, width, height) {
    return this.drawShape(new Ellipse(x2, y2, width, height));
  };
  Graphics2.prototype.drawPolygon = function() {
    var arguments$1 = arguments;
    var path = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      path[_i] = arguments$1[_i];
    }
    var points;
    var closeStroke = true;
    var poly = path[0];
    if (poly.points) {
      closeStroke = poly.closeStroke;
      points = poly.points;
    } else if (Array.isArray(path[0])) {
      points = path[0];
    } else {
      points = path;
    }
    var shape = new Polygon(points);
    shape.closeStroke = closeStroke;
    this.drawShape(shape);
    return this;
  };
  Graphics2.prototype.drawShape = function(shape) {
    if (!this._holeMode) {
      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
    } else {
      this._geometry.drawHole(shape, this._matrix);
    }
    return this;
  };
  Graphics2.prototype.clear = function() {
    this._geometry.clear();
    this._lineStyle.reset();
    this._fillStyle.reset();
    this._boundsID++;
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    return this;
  };
  Graphics2.prototype.isFastRect = function() {
    var data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  };
  Graphics2.prototype._render = function(renderer2) {
    this.finishPoly();
    var geometry = this._geometry;
    geometry.updateBatches();
    if (geometry.batchable) {
      if (this.batchDirty !== geometry.batchDirty) {
        this._populateBatches();
      }
      this._renderBatched(renderer2);
    } else {
      renderer2.batch.flush();
      this._renderDirect(renderer2);
    }
  };
  Graphics2.prototype._populateBatches = function() {
    var geometry = this._geometry;
    var blendMode = this.blendMode;
    var len = geometry.batches.length;
    this.batchTint = -1;
    this._transformID = -1;
    this.batchDirty = geometry.batchDirty;
    this.batches.length = len;
    this.vertexData = new Float32Array(geometry.points);
    for (var i = 0; i < len; i++) {
      var gI = geometry.batches[i];
      var color = gI.style.color;
      var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      var indices3 = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
      var batch = {
        vertexData,
        blendMode,
        indices: indices3,
        uvs,
        _batchRGB: hex2rgb(color),
        _tintRGB: color,
        _texture: gI.style.texture,
        alpha: gI.style.alpha,
        worldAlpha: 1
      };
      this.batches[i] = batch;
    }
  };
  Graphics2.prototype._renderBatched = function(renderer2) {
    if (!this.batches.length) {
      return;
    }
    renderer2.batch.setObjectRenderer(renderer2.plugins[this.pluginName]);
    this.calculateVertices();
    this.calculateTints();
    for (var i = 0, l2 = this.batches.length; i < l2; i++) {
      var batch = this.batches[i];
      batch.worldAlpha = this.worldAlpha * batch.alpha;
      renderer2.plugins[this.pluginName].render(batch);
    }
  };
  Graphics2.prototype._renderDirect = function(renderer2) {
    var shader = this._resolveDirectShader(renderer2);
    var geometry = this._geometry;
    var tint = this.tint;
    var worldAlpha = this.worldAlpha;
    var uniforms = shader.uniforms;
    var drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform;
    uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;
    uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;
    uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;
    uniforms.tint[3] = worldAlpha;
    renderer2.shader.bind(shader);
    renderer2.geometry.bind(geometry, shader);
    renderer2.state.set(this.state);
    for (var i = 0, l2 = drawCalls.length; i < l2; i++) {
      this._renderDrawCallDirect(renderer2, geometry.drawCalls[i]);
    }
  };
  Graphics2.prototype._renderDrawCallDirect = function(renderer2, drawCall) {
    var texArray = drawCall.texArray, type2 = drawCall.type, size = drawCall.size, start = drawCall.start;
    var groupTextureCount = texArray.count;
    for (var j2 = 0; j2 < groupTextureCount; j2++) {
      renderer2.texture.bind(texArray.elements[j2], j2);
    }
    renderer2.geometry.draw(type2, size, start);
  };
  Graphics2.prototype._resolveDirectShader = function(renderer2) {
    var shader = this.shader;
    var pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS[pluginName]) {
        var MAX_TEXTURES = renderer2.plugins[pluginName].MAX_TEXTURES;
        var sampleValues = new Int32Array(MAX_TEXTURES);
        for (var i = 0; i < MAX_TEXTURES; i++) {
          sampleValues[i] = i;
        }
        var uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix(),
          default: UniformGroup.from({ uSamplers: sampleValues }, true)
        };
        var program = renderer2.plugins[pluginName]._shader.program;
        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
      }
      shader = DEFAULT_SHADERS[pluginName];
    }
    return shader;
  };
  Graphics2.prototype._calculateBounds = function() {
    this.finishPoly();
    var geometry = this._geometry;
    if (!geometry.graphicsData.length) {
      return;
    }
    var _a2 = geometry.bounds, minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY = _a2.maxY;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  };
  Graphics2.prototype.containsPoint = function(point) {
    this.worldTransform.applyInverse(point, Graphics2._TEMP_POINT);
    return this._geometry.containsPoint(Graphics2._TEMP_POINT);
  };
  Graphics2.prototype.calculateTints = function() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this.tint;
      var tintRGB = hex2rgb(this.tint, temp);
      for (var i = 0; i < this.batches.length; i++) {
        var batch = this.batches[i];
        var batchTint = batch._batchRGB;
        var r2 = tintRGB[0] * batchTint[0] * 255;
        var g2 = tintRGB[1] * batchTint[1] * 255;
        var b2 = tintRGB[2] * batchTint[2] * 255;
        var color = (r2 << 16) + (g2 << 8) + (b2 | 0);
        batch._tintRGB = (color >> 16) + (color & 65280) + ((color & 255) << 16);
      }
    }
  };
  Graphics2.prototype.calculateVertices = function() {
    var wtID = this.transform._worldID;
    if (this._transformID === wtID) {
      return;
    }
    this._transformID = wtID;
    var wt = this.transform.worldTransform;
    var a2 = wt.a;
    var b2 = wt.b;
    var c = wt.c;
    var d2 = wt.d;
    var tx = wt.tx;
    var ty = wt.ty;
    var data = this._geometry.points;
    var vertexData = this.vertexData;
    var count = 0;
    for (var i = 0; i < data.length; i += 2) {
      var x2 = data[i];
      var y2 = data[i + 1];
      vertexData[count++] = a2 * x2 + c * y2 + tx;
      vertexData[count++] = d2 * y2 + b2 * x2 + ty;
    }
  };
  Graphics2.prototype.closePath = function() {
    var currentPath = this.currentPath;
    if (currentPath) {
      currentPath.closeStroke = true;
      this.finishPoly();
    }
    return this;
  };
  Graphics2.prototype.setMatrix = function(matrix) {
    this._matrix = matrix;
    return this;
  };
  Graphics2.prototype.beginHole = function() {
    this.finishPoly();
    this._holeMode = true;
    return this;
  };
  Graphics2.prototype.endHole = function() {
    this.finishPoly();
    this._holeMode = false;
    return this;
  };
  Graphics2.prototype.destroy = function(options) {
    this._geometry.refCount--;
    if (this._geometry.refCount === 0) {
      this._geometry.dispose();
    }
    this._matrix = null;
    this.currentPath = null;
    this._lineStyle.destroy();
    this._lineStyle = null;
    this._fillStyle.destroy();
    this._fillStyle = null;
    this._geometry = null;
    this.shader = null;
    this.vertexData = null;
    this.batches.length = 0;
    this.batches = null;
    _super.prototype.destroy.call(this, options);
  };
  Graphics2.nextRoundedRectBehavior = false;
  Graphics2._TEMP_POINT = new Point();
  return Graphics2;
}(Container);
/*!
 * @pixi/sprite - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/sprite is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$d = function(d2, b2) {
  extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$d(d2, b2);
};
function __extends$d(d2, b2) {
  extendStatics$d(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var tempPoint$2 = new Point();
var indices2 = new Uint16Array([0, 1, 2, 0, 2, 3]);
var Sprite = function(_super) {
  __extends$d(Sprite2, _super);
  function Sprite2(texture) {
    var _this = _super.call(this) || this;
    _this._anchor = new ObservablePoint(_this._onAnchorUpdate, _this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
    _this._texture = null;
    _this._width = 0;
    _this._height = 0;
    _this._tint = null;
    _this._tintRGB = null;
    _this.tint = 16777215;
    _this.blendMode = BLEND_MODES.NORMAL;
    _this._cachedTint = 16777215;
    _this.uvs = null;
    _this.texture = texture || Texture.EMPTY;
    _this.vertexData = new Float32Array(8);
    _this.vertexTrimmedData = null;
    _this._transformID = -1;
    _this._textureID = -1;
    _this._transformTrimmedID = -1;
    _this._textureTrimmedID = -1;
    _this.indices = indices2;
    _this.pluginName = "batch";
    _this.isSprite = true;
    _this._roundPixels = settings.ROUND_PIXELS;
    return _this;
  }
  Sprite2.prototype._onTextureUpdate = function() {
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    if (this._width) {
      this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width;
    }
    if (this._height) {
      this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height;
    }
  };
  Sprite2.prototype._onAnchorUpdate = function() {
    this._transformID = -1;
    this._transformTrimmedID = -1;
  };
  Sprite2.prototype.calculateVertices = function() {
    var texture = this._texture;
    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
      return;
    }
    if (this._textureID !== texture._updateID) {
      this.uvs = this._texture._uvs.uvsFloat32;
    }
    this._transformID = this.transform._worldID;
    this._textureID = texture._updateID;
    var wt = this.transform.worldTransform;
    var a2 = wt.a;
    var b2 = wt.b;
    var c = wt.c;
    var d2 = wt.d;
    var tx = wt.tx;
    var ty = wt.ty;
    var vertexData = this.vertexData;
    var trim3 = texture.trim;
    var orig = texture.orig;
    var anchor = this._anchor;
    var w0 = 0;
    var w1 = 0;
    var h0 = 0;
    var h1 = 0;
    if (trim3) {
      w1 = trim3.x - anchor._x * orig.width;
      w0 = w1 + trim3.width;
      h1 = trim3.y - anchor._y * orig.height;
      h0 = h1 + trim3.height;
    } else {
      w1 = -anchor._x * orig.width;
      w0 = w1 + orig.width;
      h1 = -anchor._y * orig.height;
      h0 = h1 + orig.height;
    }
    vertexData[0] = a2 * w1 + c * h1 + tx;
    vertexData[1] = d2 * h1 + b2 * w1 + ty;
    vertexData[2] = a2 * w0 + c * h1 + tx;
    vertexData[3] = d2 * h1 + b2 * w0 + ty;
    vertexData[4] = a2 * w0 + c * h0 + tx;
    vertexData[5] = d2 * h0 + b2 * w0 + ty;
    vertexData[6] = a2 * w1 + c * h0 + tx;
    vertexData[7] = d2 * h0 + b2 * w1 + ty;
    if (this._roundPixels) {
      var resolution = settings.RESOLUTION;
      for (var i = 0; i < vertexData.length; ++i) {
        vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);
      }
    }
  };
  Sprite2.prototype.calculateTrimmedVertices = function() {
    if (!this.vertexTrimmedData) {
      this.vertexTrimmedData = new Float32Array(8);
    } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
      return;
    }
    this._transformTrimmedID = this.transform._worldID;
    this._textureTrimmedID = this._texture._updateID;
    var texture = this._texture;
    var vertexData = this.vertexTrimmedData;
    var orig = texture.orig;
    var anchor = this._anchor;
    var wt = this.transform.worldTransform;
    var a2 = wt.a;
    var b2 = wt.b;
    var c = wt.c;
    var d2 = wt.d;
    var tx = wt.tx;
    var ty = wt.ty;
    var w1 = -anchor._x * orig.width;
    var w0 = w1 + orig.width;
    var h1 = -anchor._y * orig.height;
    var h0 = h1 + orig.height;
    vertexData[0] = a2 * w1 + c * h1 + tx;
    vertexData[1] = d2 * h1 + b2 * w1 + ty;
    vertexData[2] = a2 * w0 + c * h1 + tx;
    vertexData[3] = d2 * h1 + b2 * w0 + ty;
    vertexData[4] = a2 * w0 + c * h0 + tx;
    vertexData[5] = d2 * h0 + b2 * w0 + ty;
    vertexData[6] = a2 * w1 + c * h0 + tx;
    vertexData[7] = d2 * h0 + b2 * w1 + ty;
  };
  Sprite2.prototype._render = function(renderer2) {
    this.calculateVertices();
    renderer2.batch.setObjectRenderer(renderer2.plugins[this.pluginName]);
    renderer2.plugins[this.pluginName].render(this);
  };
  Sprite2.prototype._calculateBounds = function() {
    var trim3 = this._texture.trim;
    var orig = this._texture.orig;
    if (!trim3 || trim3.width === orig.width && trim3.height === orig.height) {
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    } else {
      this.calculateTrimmedVertices();
      this._bounds.addQuad(this.vertexTrimmedData);
    }
  };
  Sprite2.prototype.getLocalBounds = function(rect) {
    if (this.children.length === 0) {
      if (!this._localBounds) {
        this._localBounds = new Bounds();
      }
      this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
      this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
      this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
      this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._localBounds.getRectangle(rect);
    }
    return _super.prototype.getLocalBounds.call(this, rect);
  };
  Sprite2.prototype.containsPoint = function(point) {
    this.worldTransform.applyInverse(point, tempPoint$2);
    var width = this._texture.orig.width;
    var height = this._texture.orig.height;
    var x1 = -width * this.anchor.x;
    var y1 = 0;
    if (tempPoint$2.x >= x1 && tempPoint$2.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (tempPoint$2.y >= y1 && tempPoint$2.y < y1 + height) {
        return true;
      }
    }
    return false;
  };
  Sprite2.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    this._texture.off("update", this._onTextureUpdate, this);
    this._anchor = null;
    var destroyTexture = typeof options === "boolean" ? options : options && options.texture;
    if (destroyTexture) {
      var destroyBaseTexture = typeof options === "boolean" ? options : options && options.baseTexture;
      this._texture.destroy(!!destroyBaseTexture);
    }
    this._texture = null;
  };
  Sprite2.from = function(source, options) {
    var texture = source instanceof Texture ? source : Texture.from(source, options);
    return new Sprite2(texture);
  };
  Object.defineProperty(Sprite2.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(value) {
      if (this._roundPixels !== value) {
        this._transformID = -1;
      }
      this._roundPixels = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "width", {
    get: function() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    },
    set: function(value) {
      var s2 = sign(this.scale.x) || 1;
      this.scale.x = s2 * value / this._texture.orig.width;
      this._width = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "height", {
    get: function() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    },
    set: function(value) {
      var s2 = sign(this.scale.y) || 1;
      this.scale.y = s2 * value / this._texture.orig.height;
      this._height = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "anchor", {
    get: function() {
      return this._anchor;
    },
    set: function(value) {
      this._anchor.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      this._tint = value;
      this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "texture", {
    get: function() {
      return this._texture;
    },
    set: function(value) {
      if (this._texture === value) {
        return;
      }
      if (this._texture) {
        this._texture.off("update", this._onTextureUpdate, this);
      }
      this._texture = value || Texture.EMPTY;
      this._cachedTint = 16777215;
      this._textureID = -1;
      this._textureTrimmedID = -1;
      if (value) {
        if (value.baseTexture.valid) {
          this._onTextureUpdate();
        } else {
          value.once("update", this._onTextureUpdate, this);
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  return Sprite2;
}(Container);
/*!
 * @pixi/text - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$c = function(d2, b2) {
  extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$c(d2, b2);
};
function __extends$c(d2, b2) {
  extendStatics$c(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var TEXT_GRADIENT;
(function(TEXT_GRADIENT2) {
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));
var defaultStyle = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: false,
  whiteSpace: "pre",
  wordWrap: false,
  wordWrapWidth: 100,
  leading: 0
};
var genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
var TextStyle = function() {
  function TextStyle2(style) {
    this.styleID = 0;
    this.reset();
    deepCopyProperties(this, style, style);
  }
  TextStyle2.prototype.clone = function() {
    var clonedProperties = {};
    deepCopyProperties(clonedProperties, this, defaultStyle);
    return new TextStyle2(clonedProperties);
  };
  TextStyle2.prototype.reset = function() {
    deepCopyProperties(this, defaultStyle, defaultStyle);
  };
  Object.defineProperty(TextStyle2.prototype, "align", {
    get: function() {
      return this._align;
    },
    set: function(align) {
      if (this._align !== align) {
        this._align = align;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "breakWords", {
    get: function() {
      return this._breakWords;
    },
    set: function(breakWords) {
      if (this._breakWords !== breakWords) {
        this._breakWords = breakWords;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadow", {
    get: function() {
      return this._dropShadow;
    },
    set: function(dropShadow) {
      if (this._dropShadow !== dropShadow) {
        this._dropShadow = dropShadow;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowAlpha", {
    get: function() {
      return this._dropShadowAlpha;
    },
    set: function(dropShadowAlpha) {
      if (this._dropShadowAlpha !== dropShadowAlpha) {
        this._dropShadowAlpha = dropShadowAlpha;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowAngle", {
    get: function() {
      return this._dropShadowAngle;
    },
    set: function(dropShadowAngle) {
      if (this._dropShadowAngle !== dropShadowAngle) {
        this._dropShadowAngle = dropShadowAngle;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowBlur", {
    get: function() {
      return this._dropShadowBlur;
    },
    set: function(dropShadowBlur) {
      if (this._dropShadowBlur !== dropShadowBlur) {
        this._dropShadowBlur = dropShadowBlur;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowColor", {
    get: function() {
      return this._dropShadowColor;
    },
    set: function(dropShadowColor) {
      var outputColor = getColor(dropShadowColor);
      if (this._dropShadowColor !== outputColor) {
        this._dropShadowColor = outputColor;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowDistance", {
    get: function() {
      return this._dropShadowDistance;
    },
    set: function(dropShadowDistance) {
      if (this._dropShadowDistance !== dropShadowDistance) {
        this._dropShadowDistance = dropShadowDistance;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fill", {
    get: function() {
      return this._fill;
    },
    set: function(fill) {
      var outputColor = getColor(fill);
      if (this._fill !== outputColor) {
        this._fill = outputColor;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fillGradientType", {
    get: function() {
      return this._fillGradientType;
    },
    set: function(fillGradientType) {
      if (this._fillGradientType !== fillGradientType) {
        this._fillGradientType = fillGradientType;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fillGradientStops", {
    get: function() {
      return this._fillGradientStops;
    },
    set: function(fillGradientStops) {
      if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
        this._fillGradientStops = fillGradientStops;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontFamily", {
    get: function() {
      return this._fontFamily;
    },
    set: function(fontFamily) {
      if (this.fontFamily !== fontFamily) {
        this._fontFamily = fontFamily;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontSize", {
    get: function() {
      return this._fontSize;
    },
    set: function(fontSize) {
      if (this._fontSize !== fontSize) {
        this._fontSize = fontSize;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontStyle", {
    get: function() {
      return this._fontStyle;
    },
    set: function(fontStyle) {
      if (this._fontStyle !== fontStyle) {
        this._fontStyle = fontStyle;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontVariant", {
    get: function() {
      return this._fontVariant;
    },
    set: function(fontVariant) {
      if (this._fontVariant !== fontVariant) {
        this._fontVariant = fontVariant;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontWeight", {
    get: function() {
      return this._fontWeight;
    },
    set: function(fontWeight) {
      if (this._fontWeight !== fontWeight) {
        this._fontWeight = fontWeight;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "letterSpacing", {
    get: function() {
      return this._letterSpacing;
    },
    set: function(letterSpacing) {
      if (this._letterSpacing !== letterSpacing) {
        this._letterSpacing = letterSpacing;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "lineHeight", {
    get: function() {
      return this._lineHeight;
    },
    set: function(lineHeight) {
      if (this._lineHeight !== lineHeight) {
        this._lineHeight = lineHeight;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "leading", {
    get: function() {
      return this._leading;
    },
    set: function(leading) {
      if (this._leading !== leading) {
        this._leading = leading;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "lineJoin", {
    get: function() {
      return this._lineJoin;
    },
    set: function(lineJoin) {
      if (this._lineJoin !== lineJoin) {
        this._lineJoin = lineJoin;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "miterLimit", {
    get: function() {
      return this._miterLimit;
    },
    set: function(miterLimit) {
      if (this._miterLimit !== miterLimit) {
        this._miterLimit = miterLimit;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "padding", {
    get: function() {
      return this._padding;
    },
    set: function(padding) {
      if (this._padding !== padding) {
        this._padding = padding;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "stroke", {
    get: function() {
      return this._stroke;
    },
    set: function(stroke) {
      var outputColor = getColor(stroke);
      if (this._stroke !== outputColor) {
        this._stroke = outputColor;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "strokeThickness", {
    get: function() {
      return this._strokeThickness;
    },
    set: function(strokeThickness) {
      if (this._strokeThickness !== strokeThickness) {
        this._strokeThickness = strokeThickness;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "textBaseline", {
    get: function() {
      return this._textBaseline;
    },
    set: function(textBaseline) {
      if (this._textBaseline !== textBaseline) {
        this._textBaseline = textBaseline;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "trim", {
    get: function() {
      return this._trim;
    },
    set: function(trim3) {
      if (this._trim !== trim3) {
        this._trim = trim3;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "whiteSpace", {
    get: function() {
      return this._whiteSpace;
    },
    set: function(whiteSpace) {
      if (this._whiteSpace !== whiteSpace) {
        this._whiteSpace = whiteSpace;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "wordWrap", {
    get: function() {
      return this._wordWrap;
    },
    set: function(wordWrap) {
      if (this._wordWrap !== wordWrap) {
        this._wordWrap = wordWrap;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "wordWrapWidth", {
    get: function() {
      return this._wordWrapWidth;
    },
    set: function(wordWrapWidth) {
      if (this._wordWrapWidth !== wordWrapWidth) {
        this._wordWrapWidth = wordWrapWidth;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  TextStyle2.prototype.toFontString = function() {
    var fontSizeString = typeof this.fontSize === "number" ? this.fontSize + "px" : this.fontSize;
    var fontFamilies = this.fontFamily;
    if (!Array.isArray(this.fontFamily)) {
      fontFamilies = this.fontFamily.split(",");
    }
    for (var i = fontFamilies.length - 1; i >= 0; i--) {
      var fontFamily = fontFamilies[i].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {
        fontFamily = '"' + fontFamily + '"';
      }
      fontFamilies[i] = fontFamily;
    }
    return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + fontSizeString + " " + fontFamilies.join(",");
  };
  return TextStyle2;
}();
function getSingleColor(color) {
  if (typeof color === "number") {
    return hex2string(color);
  } else if (typeof color === "string") {
    if (color.indexOf("0x") === 0) {
      color = color.replace("0x", "#");
    }
  }
  return color;
}
function getColor(color) {
  if (!Array.isArray(color)) {
    return getSingleColor(color);
  } else {
    for (var i = 0; i < color.length; ++i) {
      color[i] = getSingleColor(color[i]);
    }
    return color;
  }
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (var i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function deepCopyProperties(target, source, propertyObj) {
  for (var prop in propertyObj) {
    if (Array.isArray(source[prop])) {
      target[prop] = source[prop].slice();
    } else {
      target[prop] = source[prop];
    }
  }
}
var contextSettings = {
  willReadFrequently: true
};
var TextMetrics = function() {
  function TextMetrics2(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text;
    this.style = style;
    this.width = width;
    this.height = height;
    this.lines = lines;
    this.lineWidths = lineWidths;
    this.lineHeight = lineHeight;
    this.maxLineWidth = maxLineWidth;
    this.fontProperties = fontProperties;
  }
  TextMetrics2.measureText = function(text, style, wordWrap, canvas) {
    if (canvas === void 0) {
      canvas = TextMetrics2._canvas;
    }
    wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
    var font = style.toFontString();
    var fontProperties = TextMetrics2.measureFont(font);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = style.fontSize;
      fontProperties.ascent = style.fontSize;
    }
    var context2 = canvas.getContext("2d", contextSettings);
    context2.font = font;
    var outputText = wordWrap ? TextMetrics2.wordWrap(text, style, canvas) : text;
    var lines = outputText.split(/(?:\r\n|\r|\n)/);
    var lineWidths = new Array(lines.length);
    var maxLineWidth = 0;
    for (var i = 0; i < lines.length; i++) {
      var lineWidth = context2.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;
      lineWidths[i] = lineWidth;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    var width = maxLineWidth + style.strokeThickness;
    if (style.dropShadow) {
      width += style.dropShadowDistance;
    }
    var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
    var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * (lineHeight + style.leading);
    if (style.dropShadow) {
      height += style.dropShadowDistance;
    }
    return new TextMetrics2(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
  };
  TextMetrics2.wordWrap = function(text, style, canvas) {
    if (canvas === void 0) {
      canvas = TextMetrics2._canvas;
    }
    var context2 = canvas.getContext("2d", contextSettings);
    var width = 0;
    var line = "";
    var lines = "";
    var cache = /* @__PURE__ */ Object.create(null);
    var letterSpacing = style.letterSpacing, whiteSpace = style.whiteSpace;
    var collapseSpaces = TextMetrics2.collapseSpaces(whiteSpace);
    var collapseNewlines = TextMetrics2.collapseNewlines(whiteSpace);
    var canPrependSpaces = !collapseSpaces;
    var wordWrapWidth = style.wordWrapWidth + letterSpacing;
    var tokens = TextMetrics2.tokenize(text);
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (TextMetrics2.isNewline(token)) {
        if (!collapseNewlines) {
          lines += TextMetrics2.addLine(line);
          canPrependSpaces = !collapseSpaces;
          line = "";
          width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        var currIsBreakingSpace = TextMetrics2.isBreakingSpace(token);
        var lastIsBreakingSpace = TextMetrics2.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace) {
          continue;
        }
      }
      var tokenWidth = TextMetrics2.getFromCache(token, letterSpacing, cache, context2);
      if (tokenWidth > wordWrapWidth) {
        if (line !== "") {
          lines += TextMetrics2.addLine(line);
          line = "";
          width = 0;
        }
        if (TextMetrics2.canBreakWords(token, style.breakWords)) {
          var characters = TextMetrics2.wordWrapSplit(token);
          for (var j2 = 0; j2 < characters.length; j2++) {
            var char = characters[j2];
            var k2 = 1;
            while (characters[j2 + k2]) {
              var nextChar = characters[j2 + k2];
              var lastChar = char[char.length - 1];
              if (!TextMetrics2.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                char += nextChar;
              } else {
                break;
              }
              k2++;
            }
            j2 += char.length - 1;
            var characterWidth = TextMetrics2.getFromCache(char, letterSpacing, cache, context2);
            if (characterWidth + width > wordWrapWidth) {
              lines += TextMetrics2.addLine(line);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
            line += char;
            width += characterWidth;
          }
        } else {
          if (line.length > 0) {
            lines += TextMetrics2.addLine(line);
            line = "";
            width = 0;
          }
          var isLastToken = i === tokens.length - 1;
          lines += TextMetrics2.addLine(token, !isLastToken);
          canPrependSpaces = false;
          line = "";
          width = 0;
        }
      } else {
        if (tokenWidth + width > wordWrapWidth) {
          canPrependSpaces = false;
          lines += TextMetrics2.addLine(line);
          line = "";
          width = 0;
        }
        if (line.length > 0 || !TextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
          line += token;
          width += tokenWidth;
        }
      }
    }
    lines += TextMetrics2.addLine(line, false);
    return lines;
  };
  TextMetrics2.addLine = function(line, newLine) {
    if (newLine === void 0) {
      newLine = true;
    }
    line = TextMetrics2.trimRight(line);
    line = newLine ? line + "\n" : line;
    return line;
  };
  TextMetrics2.getFromCache = function(key, letterSpacing, cache, context2) {
    var width = cache[key];
    if (typeof width !== "number") {
      var spacing = key.length * letterSpacing;
      width = context2.measureText(key).width + spacing;
      cache[key] = width;
    }
    return width;
  };
  TextMetrics2.collapseSpaces = function(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  };
  TextMetrics2.collapseNewlines = function(whiteSpace) {
    return whiteSpace === "normal";
  };
  TextMetrics2.trimRight = function(text) {
    if (typeof text !== "string") {
      return "";
    }
    for (var i = text.length - 1; i >= 0; i--) {
      var char = text[i];
      if (!TextMetrics2.isBreakingSpace(char)) {
        break;
      }
      text = text.slice(0, -1);
    }
    return text;
  };
  TextMetrics2.isNewline = function(char) {
    if (typeof char !== "string") {
      return false;
    }
    return TextMetrics2._newlines.indexOf(char.charCodeAt(0)) >= 0;
  };
  TextMetrics2.isBreakingSpace = function(char, _nextChar) {
    if (typeof char !== "string") {
      return false;
    }
    return TextMetrics2._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
  };
  TextMetrics2.tokenize = function(text) {
    var tokens = [];
    var token = "";
    if (typeof text !== "string") {
      return tokens;
    }
    for (var i = 0; i < text.length; i++) {
      var char = text[i];
      var nextChar = text[i + 1];
      if (TextMetrics2.isBreakingSpace(char, nextChar) || TextMetrics2.isNewline(char)) {
        if (token !== "") {
          tokens.push(token);
          token = "";
        }
        tokens.push(char);
        continue;
      }
      token += char;
    }
    if (token !== "") {
      tokens.push(token);
    }
    return tokens;
  };
  TextMetrics2.canBreakWords = function(_token, breakWords) {
    return breakWords;
  };
  TextMetrics2.canBreakChars = function(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  };
  TextMetrics2.wordWrapSplit = function(token) {
    return token.split("");
  };
  TextMetrics2.measureFont = function(font) {
    if (TextMetrics2._fonts[font]) {
      return TextMetrics2._fonts[font];
    }
    var properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    var canvas = TextMetrics2._canvas;
    var context2 = TextMetrics2._context;
    context2.font = font;
    var metricsString = TextMetrics2.METRICS_STRING + TextMetrics2.BASELINE_SYMBOL;
    var width = Math.ceil(context2.measureText(metricsString).width);
    var baseline = Math.ceil(context2.measureText(TextMetrics2.BASELINE_SYMBOL).width);
    var height = Math.ceil(TextMetrics2.HEIGHT_MULTIPLIER * baseline);
    baseline = baseline * TextMetrics2.BASELINE_MULTIPLIER | 0;
    canvas.width = width;
    canvas.height = height;
    context2.fillStyle = "#f00";
    context2.fillRect(0, 0, width, height);
    context2.font = font;
    context2.textBaseline = "alphabetic";
    context2.fillStyle = "#000";
    context2.fillText(metricsString, 0, baseline);
    var imagedata = context2.getImageData(0, 0, width, height).data;
    var pixels = imagedata.length;
    var line = width * 4;
    var i = 0;
    var idx = 0;
    var stop = false;
    for (i = 0; i < baseline; ++i) {
      for (var j2 = 0; j2 < line; j2 += 4) {
        if (imagedata[idx + j2] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }
    properties.ascent = baseline - i;
    idx = pixels - line;
    stop = false;
    for (i = height; i > baseline; --i) {
      for (var j2 = 0; j2 < line; j2 += 4) {
        if (imagedata[idx + j2] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }
    properties.descent = i - baseline;
    properties.fontSize = properties.ascent + properties.descent;
    TextMetrics2._fonts[font] = properties;
    return properties;
  };
  TextMetrics2.clearMetrics = function(font) {
    if (font === void 0) {
      font = "";
    }
    if (font) {
      delete TextMetrics2._fonts[font];
    } else {
      TextMetrics2._fonts = {};
    }
  };
  Object.defineProperty(TextMetrics2, "_canvas", {
    get: function() {
      if (!TextMetrics2.__canvas) {
        var canvas = void 0;
        try {
          var c = new OffscreenCanvas(0, 0);
          var context2 = c.getContext("2d", contextSettings);
          if (context2 && context2.measureText) {
            TextMetrics2.__canvas = c;
            return c;
          }
          canvas = settings.ADAPTER.createCanvas();
        } catch (ex) {
          canvas = settings.ADAPTER.createCanvas();
        }
        canvas.width = canvas.height = 10;
        TextMetrics2.__canvas = canvas;
      }
      return TextMetrics2.__canvas;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextMetrics2, "_context", {
    get: function() {
      if (!TextMetrics2.__context) {
        TextMetrics2.__context = TextMetrics2._canvas.getContext("2d", contextSettings);
      }
      return TextMetrics2.__context;
    },
    enumerable: false,
    configurable: true
  });
  return TextMetrics2;
}();
TextMetrics._fonts = {};
TextMetrics.METRICS_STRING = "|\xC9q\xC5";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
var defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
var Text = function(_super) {
  __extends$c(Text2, _super);
  function Text2(text, style, canvas) {
    var _this = this;
    var ownCanvas = false;
    if (!canvas) {
      canvas = settings.ADAPTER.createCanvas();
      ownCanvas = true;
    }
    canvas.width = 3;
    canvas.height = 3;
    var texture = Texture.from(canvas);
    texture.orig = new Rectangle();
    texture.trim = new Rectangle();
    _this = _super.call(this, texture) || this;
    _this._ownCanvas = ownCanvas;
    _this.canvas = canvas;
    _this.context = canvas.getContext("2d", {
      willReadFrequently: true
    });
    _this._resolution = settings.RESOLUTION;
    _this._autoResolution = true;
    _this._text = null;
    _this._style = null;
    _this._styleListener = null;
    _this._font = "";
    _this.text = text;
    _this.style = style;
    _this.localStyleID = -1;
    return _this;
  }
  Text2.prototype.updateText = function(respectDirty) {
    var style = this._style;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    this._font = this._style.toFontString();
    var context2 = this.context;
    var measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
    var width = measured.width;
    var height = measured.height;
    var lines = measured.lines;
    var lineHeight = measured.lineHeight;
    var lineWidths = measured.lineWidths;
    var maxLineWidth = measured.maxLineWidth;
    var fontProperties = measured.fontProperties;
    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
    this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
    context2.scale(this._resolution, this._resolution);
    context2.clearRect(0, 0, this.canvas.width, this.canvas.height);
    context2.font = this._font;
    context2.lineWidth = style.strokeThickness;
    context2.textBaseline = style.textBaseline;
    context2.lineJoin = style.lineJoin;
    context2.miterLimit = style.miterLimit;
    var linePositionX;
    var linePositionY;
    var passesCount = style.dropShadow ? 2 : 1;
    for (var i = 0; i < passesCount; ++i) {
      var isShadowPass = style.dropShadow && i === 0;
      var dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
      var dsOffsetShadow = dsOffsetText * this._resolution;
      if (isShadowPass) {
        context2.fillStyle = "black";
        context2.strokeStyle = "black";
        var dropShadowColor = style.dropShadowColor;
        var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
        var dropShadowBlur = style.dropShadowBlur * this._resolution;
        var dropShadowDistance = style.dropShadowDistance * this._resolution;
        context2.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
        context2.shadowBlur = dropShadowBlur;
        context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
        context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
      } else {
        context2.fillStyle = this._generateFillStyle(style, lines, measured);
        context2.strokeStyle = style.stroke;
        context2.shadowColor = "black";
        context2.shadowBlur = 0;
        context2.shadowOffsetX = 0;
        context2.shadowOffsetY = 0;
      }
      var linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      if (!Text2.nextLineHeightBehavior || lineHeight - fontProperties.fontSize < 0) {
        linePositionYShift = 0;
      }
      for (var i_1 = 0; i_1 < lines.length; i_1++) {
        linePositionX = style.strokeThickness / 2;
        linePositionY = style.strokeThickness / 2 + i_1 * lineHeight + fontProperties.ascent + linePositionYShift;
        if (style.align === "right") {
          linePositionX += maxLineWidth - lineWidths[i_1];
        } else if (style.align === "center") {
          linePositionX += (maxLineWidth - lineWidths[i_1]) / 2;
        }
        if (style.stroke && style.strokeThickness) {
          this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
        }
        if (style.fill) {
          this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
        }
      }
    }
    this.updateTexture();
  };
  Text2.prototype.drawLetterSpacing = function(text, x2, y2, isStroke) {
    if (isStroke === void 0) {
      isStroke = false;
    }
    var style = this._style;
    var letterSpacing = style.letterSpacing;
    var supportLetterSpacing = Text2.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
    if (letterSpacing === 0 || supportLetterSpacing) {
      if (supportLetterSpacing) {
        this.context.letterSpacing = letterSpacing;
        this.context.textLetterSpacing = letterSpacing;
      }
      if (isStroke) {
        this.context.strokeText(text, x2, y2);
      } else {
        this.context.fillText(text, x2, y2);
      }
      return;
    }
    var currentPosition = x2;
    var stringArray = Array.from ? Array.from(text) : text.split("");
    var previousWidth = this.context.measureText(text).width;
    var currentWidth = 0;
    for (var i = 0; i < stringArray.length; ++i) {
      var currentChar = stringArray[i];
      if (isStroke) {
        this.context.strokeText(currentChar, currentPosition, y2);
      } else {
        this.context.fillText(currentChar, currentPosition, y2);
      }
      var textStr = "";
      for (var j2 = i + 1; j2 < stringArray.length; ++j2) {
        textStr += stringArray[j2];
      }
      currentWidth = this.context.measureText(textStr).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
  };
  Text2.prototype.updateTexture = function() {
    var canvas = this.canvas;
    if (this._style.trim) {
      var trimmed = trimCanvas(canvas);
      if (trimmed.data) {
        canvas.width = trimmed.width;
        canvas.height = trimmed.height;
        this.context.putImageData(trimmed.data, 0, 0);
      }
    }
    var texture = this._texture;
    var style = this._style;
    var padding = style.trim ? 0 : style.padding;
    var baseTexture = texture.baseTexture;
    texture.trim.width = texture._frame.width = canvas.width / this._resolution;
    texture.trim.height = texture._frame.height = canvas.height / this._resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
    texture.updateUvs();
    this.dirty = false;
  };
  Text2.prototype._render = function(renderer2) {
    if (this._autoResolution && this._resolution !== renderer2.resolution) {
      this._resolution = renderer2.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    _super.prototype._render.call(this, renderer2);
  };
  Text2.prototype.updateTransform = function() {
    this.updateText(true);
    _super.prototype.updateTransform.call(this);
  };
  Text2.prototype.getBounds = function(skipUpdate, rect) {
    this.updateText(true);
    if (this._textureID === -1) {
      skipUpdate = false;
    }
    return _super.prototype.getBounds.call(this, skipUpdate, rect);
  };
  Text2.prototype.getLocalBounds = function(rect) {
    this.updateText(true);
    return _super.prototype.getLocalBounds.call(this, rect);
  };
  Text2.prototype._calculateBounds = function() {
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  };
  Text2.prototype._generateFillStyle = function(style, lines, metrics) {
    var fillStyle = style.fill;
    if (!Array.isArray(fillStyle)) {
      return fillStyle;
    } else if (fillStyle.length === 1) {
      return fillStyle[0];
    }
    var gradient;
    var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
    var padding = style.padding || 0;
    var width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
    var height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
    var fill = fillStyle.slice();
    var fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      var lengthPlus1 = fill.length + 1;
      for (var i = 1; i < lengthPlus1; ++i) {
        fillGradientStops.push(i / lengthPlus1);
      }
    }
    fill.unshift(fillStyle[0]);
    fillGradientStops.unshift(0);
    fill.push(fillStyle[fillStyle.length - 1]);
    fillGradientStops.push(1);
    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
      var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      for (var i = 0; i < lines.length; i++) {
        var lastLineBottom = metrics.lineHeight * (i - 1) + textHeight;
        var thisLineTop = metrics.lineHeight * i;
        var thisLineGradientStart = thisLineTop;
        if (i > 0 && lastLineBottom > thisLineTop) {
          thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
        }
        var thisLineBottom = thisLineTop + textHeight;
        var nextLineTop = metrics.lineHeight * (i + 1);
        var thisLineGradientEnd = thisLineBottom;
        if (i + 1 < lines.length && nextLineTop < thisLineBottom) {
          thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
        }
        var gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
        for (var j2 = 0; j2 < fill.length; j2++) {
          var lineStop = 0;
          if (typeof fillGradientStops[j2] === "number") {
            lineStop = fillGradientStops[j2];
          } else {
            lineStop = j2 / fill.length;
          }
          var globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
          globalStop = Number(globalStop.toFixed(5));
          gradient.addColorStop(globalStop, fill[j2]);
        }
      }
    } else {
      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
      var totalIterations = fill.length + 1;
      var currentIteration = 1;
      for (var i = 0; i < fill.length; i++) {
        var stop = void 0;
        if (typeof fillGradientStops[i] === "number") {
          stop = fillGradientStops[i];
        } else {
          stop = currentIteration / totalIterations;
        }
        gradient.addColorStop(stop, fill[i]);
        currentIteration++;
      }
    }
    return gradient;
  };
  Text2.prototype.destroy = function(options) {
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, defaultDestroyOptions, options);
    _super.prototype.destroy.call(this, options);
    if (this._ownCanvas) {
      this.canvas.height = this.canvas.width = 0;
    }
    this.context = null;
    this.canvas = null;
    this._style = null;
  };
  Object.defineProperty(Text2.prototype, "width", {
    get: function() {
      this.updateText(true);
      return Math.abs(this.scale.x) * this._texture.orig.width;
    },
    set: function(value) {
      this.updateText(true);
      var s2 = sign(this.scale.x) || 1;
      this.scale.x = s2 * value / this._texture.orig.width;
      this._width = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "height", {
    get: function() {
      this.updateText(true);
      return Math.abs(this.scale.y) * this._texture.orig.height;
    },
    set: function(value) {
      this.updateText(true);
      var s2 = sign(this.scale.y) || 1;
      this.scale.y = s2 * value / this._texture.orig.height;
      this._height = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "style", {
    get: function() {
      return this._style;
    },
    set: function(style) {
      style = style || {};
      if (style instanceof TextStyle) {
        this._style = style;
      } else {
        this._style = new TextStyle(style);
      }
      this.localStyleID = -1;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "text", {
    get: function() {
      return this._text;
    },
    set: function(text) {
      text = String(text === null || text === void 0 ? "" : text);
      if (this._text === text) {
        return;
      }
      this._text = text;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(value) {
      this._autoResolution = false;
      if (this._resolution === value) {
        return;
      }
      this._resolution = value;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Text2.nextLineHeightBehavior = false;
  Text2.experimentalLetterSpacing = false;
  return Text2;
}(Sprite);
/*!
 * @pixi/prepare - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.UPLOADS_PER_FRAME = 4;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$b = function(d2, b2) {
  extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$b(d2, b2);
};
function __extends$b(d2, b2) {
  extendStatics$b(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var CountLimiter = function() {
  function CountLimiter2(maxItemsPerFrame) {
    this.maxItemsPerFrame = maxItemsPerFrame;
    this.itemsLeft = 0;
  }
  CountLimiter2.prototype.beginFrame = function() {
    this.itemsLeft = this.maxItemsPerFrame;
  };
  CountLimiter2.prototype.allowedToUpload = function() {
    return this.itemsLeft-- > 0;
  };
  return CountLimiter2;
}();
function findMultipleBaseTextures(item, queue) {
  var result = false;
  if (item && item._textures && item._textures.length) {
    for (var i = 0; i < item._textures.length; i++) {
      if (item._textures[i] instanceof Texture) {
        var baseTexture = item._textures[i].baseTexture;
        if (queue.indexOf(baseTexture) === -1) {
          queue.push(baseTexture);
          result = true;
        }
      }
    }
  }
  return result;
}
function findBaseTexture(item, queue) {
  if (item.baseTexture instanceof BaseTexture) {
    var texture = item.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTexture(item, queue) {
  if (item._texture && item._texture instanceof Texture) {
    var texture = item._texture.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function drawText(_helper, item) {
  if (item instanceof Text) {
    item.updateText(true);
    return true;
  }
  return false;
}
function calculateTextStyle(_helper, item) {
  if (item instanceof TextStyle) {
    var font = item.toFontString();
    TextMetrics.measureFont(font);
    return true;
  }
  return false;
}
function findText(item, queue) {
  if (item instanceof Text) {
    if (queue.indexOf(item.style) === -1) {
      queue.push(item.style);
    }
    if (queue.indexOf(item) === -1) {
      queue.push(item);
    }
    var texture = item._texture.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTextStyle(item, queue) {
  if (item instanceof TextStyle) {
    if (queue.indexOf(item) === -1) {
      queue.push(item);
    }
    return true;
  }
  return false;
}
var BasePrepare = function() {
  function BasePrepare2(renderer2) {
    var _this = this;
    this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME);
    this.renderer = renderer2;
    this.uploadHookHelper = null;
    this.queue = [];
    this.addHooks = [];
    this.uploadHooks = [];
    this.completes = [];
    this.ticking = false;
    this.delayedTick = function() {
      if (!_this.queue) {
        return;
      }
      _this.prepareItems();
    };
    this.registerFindHook(findText);
    this.registerFindHook(findTextStyle);
    this.registerFindHook(findMultipleBaseTextures);
    this.registerFindHook(findBaseTexture);
    this.registerFindHook(findTexture);
    this.registerUploadHook(drawText);
    this.registerUploadHook(calculateTextStyle);
  }
  BasePrepare2.prototype.upload = function(item, done) {
    var _this = this;
    if (typeof item === "function") {
      done = item;
      item = null;
    }
    if (done) {
      deprecation("6.5.0", "BasePrepare.upload callback is deprecated, use the return Promise instead.");
    }
    return new Promise(function(resolve2) {
      if (item) {
        _this.add(item);
      }
      var complete = function() {
        done === null || done === void 0 ? void 0 : done();
        resolve2();
      };
      if (_this.queue.length) {
        _this.completes.push(complete);
        if (!_this.ticking) {
          _this.ticking = true;
          Ticker.system.addOnce(_this.tick, _this, UPDATE_PRIORITY.UTILITY);
        }
      } else {
        complete();
      }
    });
  };
  BasePrepare2.prototype.tick = function() {
    setTimeout(this.delayedTick, 0);
  };
  BasePrepare2.prototype.prepareItems = function() {
    this.limiter.beginFrame();
    while (this.queue.length && this.limiter.allowedToUpload()) {
      var item = this.queue[0];
      var uploaded = false;
      if (item && !item._destroyed) {
        for (var i = 0, len = this.uploadHooks.length; i < len; i++) {
          if (this.uploadHooks[i](this.uploadHookHelper, item)) {
            this.queue.shift();
            uploaded = true;
            break;
          }
        }
      }
      if (!uploaded) {
        this.queue.shift();
      }
    }
    if (!this.queue.length) {
      this.ticking = false;
      var completes = this.completes.slice(0);
      this.completes.length = 0;
      for (var i = 0, len = completes.length; i < len; i++) {
        completes[i]();
      }
    } else {
      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
    }
  };
  BasePrepare2.prototype.registerFindHook = function(addHook) {
    if (addHook) {
      this.addHooks.push(addHook);
    }
    return this;
  };
  BasePrepare2.prototype.registerUploadHook = function(uploadHook) {
    if (uploadHook) {
      this.uploadHooks.push(uploadHook);
    }
    return this;
  };
  BasePrepare2.prototype.add = function(item) {
    for (var i = 0, len = this.addHooks.length; i < len; i++) {
      if (this.addHooks[i](item, this.queue)) {
        break;
      }
    }
    if (item instanceof Container) {
      for (var i = item.children.length - 1; i >= 0; i--) {
        this.add(item.children[i]);
      }
    }
    return this;
  };
  BasePrepare2.prototype.destroy = function() {
    if (this.ticking) {
      Ticker.system.remove(this.tick, this);
    }
    this.ticking = false;
    this.addHooks = null;
    this.uploadHooks = null;
    this.renderer = null;
    this.completes = null;
    this.queue = null;
    this.limiter = null;
    this.uploadHookHelper = null;
  };
  return BasePrepare2;
}();
function uploadBaseTextures(renderer2, item) {
  if (item instanceof BaseTexture) {
    if (!item._glTextures[renderer2.CONTEXT_UID]) {
      renderer2.texture.bind(item);
    }
    return true;
  }
  return false;
}
function uploadGraphics(renderer2, item) {
  if (!(item instanceof Graphics)) {
    return false;
  }
  var geometry = item.geometry;
  item.finishPoly();
  geometry.updateBatches();
  var batches = geometry.batches;
  for (var i = 0; i < batches.length; i++) {
    var texture = batches[i].style.texture;
    if (texture) {
      uploadBaseTextures(renderer2, texture.baseTexture);
    }
  }
  if (!geometry.batchable) {
    renderer2.geometry.bind(geometry, item._resolveDirectShader(renderer2));
  }
  return true;
}
function findGraphics(item, queue) {
  if (item instanceof Graphics) {
    queue.push(item);
    return true;
  }
  return false;
}
var Prepare = function(_super) {
  __extends$b(Prepare2, _super);
  function Prepare2(renderer2) {
    var _this = _super.call(this, renderer2) || this;
    _this.uploadHookHelper = _this.renderer;
    _this.registerFindHook(findGraphics);
    _this.registerUploadHook(uploadBaseTextures);
    _this.registerUploadHook(uploadGraphics);
    return _this;
  }
  Prepare2.extension = {
    name: "prepare",
    type: ExtensionType.RendererPlugin
  };
  return Prepare2;
}(BasePrepare);
/*!
 * @pixi/spritesheet - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/spritesheet is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Spritesheet = function() {
  function Spritesheet2(texture, data, resolutionFilename) {
    if (resolutionFilename === void 0) {
      resolutionFilename = null;
    }
    this.linkedSheets = [];
    this._texture = texture instanceof Texture ? texture : null;
    this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;
    this.textures = {};
    this.animations = {};
    this.data = data;
    var resource = this.baseTexture.resource;
    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
    this._frames = this.data.frames;
    this._frameKeys = Object.keys(this._frames);
    this._batchIndex = 0;
    this._callback = null;
  }
  Spritesheet2.prototype._updateResolution = function(resolutionFilename) {
    if (resolutionFilename === void 0) {
      resolutionFilename = null;
    }
    var scale = this.data.meta.scale;
    var resolution = getResolutionOfUrl(resolutionFilename, null);
    if (resolution === null) {
      resolution = scale !== void 0 ? parseFloat(scale) : 1;
    }
    if (resolution !== 1) {
      this.baseTexture.setResolution(resolution);
    }
    return resolution;
  };
  Spritesheet2.prototype.parse = function(callback) {
    var _this = this;
    if (callback) {
      deprecation("6.5.0", "Spritesheet.parse callback is deprecated, use the return Promise instead.");
    }
    return new Promise(function(resolve2) {
      _this._callback = function(textures) {
        callback === null || callback === void 0 ? void 0 : callback(textures);
        resolve2(textures);
      };
      _this._batchIndex = 0;
      if (_this._frameKeys.length <= Spritesheet2.BATCH_SIZE) {
        _this._processFrames(0);
        _this._processAnimations();
        _this._parseComplete();
      } else {
        _this._nextBatch();
      }
    });
  };
  Spritesheet2.prototype._processFrames = function(initialFrameIndex) {
    var frameIndex = initialFrameIndex;
    var maxFrames = Spritesheet2.BATCH_SIZE;
    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
      var i = this._frameKeys[frameIndex];
      var data = this._frames[i];
      var rect = data.frame;
      if (rect) {
        var frame = null;
        var trim3 = null;
        var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
        var orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
        if (data.rotated) {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
        } else {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        if (data.trimmed !== false && data.spriteSourceSize) {
          trim3 = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        this.textures[i] = new Texture(this.baseTexture, frame, orig, trim3, data.rotated ? 2 : 0, data.anchor);
        Texture.addToCache(this.textures[i], i);
      }
      frameIndex++;
    }
  };
  Spritesheet2.prototype._processAnimations = function() {
    var animations = this.data.animations || {};
    for (var animName in animations) {
      this.animations[animName] = [];
      for (var i = 0; i < animations[animName].length; i++) {
        var frameName = animations[animName][i];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  };
  Spritesheet2.prototype._parseComplete = function() {
    var callback = this._callback;
    this._callback = null;
    this._batchIndex = 0;
    callback.call(this, this.textures);
  };
  Spritesheet2.prototype._nextBatch = function() {
    var _this = this;
    this._processFrames(this._batchIndex * Spritesheet2.BATCH_SIZE);
    this._batchIndex++;
    setTimeout(function() {
      if (_this._batchIndex * Spritesheet2.BATCH_SIZE < _this._frameKeys.length) {
        _this._nextBatch();
      } else {
        _this._processAnimations();
        _this._parseComplete();
      }
    }, 0);
  };
  Spritesheet2.prototype.destroy = function(destroyBase) {
    var _a2;
    if (destroyBase === void 0) {
      destroyBase = false;
    }
    for (var i in this.textures) {
      this.textures[i].destroy();
    }
    this._frames = null;
    this._frameKeys = null;
    this.data = null;
    this.textures = null;
    if (destroyBase) {
      (_a2 = this._texture) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      this.baseTexture.destroy();
    }
    this._texture = null;
    this.baseTexture = null;
    this.linkedSheets = [];
  };
  Spritesheet2.BATCH_SIZE = 1e3;
  return Spritesheet2;
}();
var SpritesheetLoader = function() {
  function SpritesheetLoader2() {
  }
  SpritesheetLoader2.use = function(resource, next) {
    var _a2, _b2;
    var loader = this;
    var imageResourceName = resource.name + "_image";
    if (!resource.data || resource.type !== LoaderResource.TYPE.JSON || !resource.data.frames || loader.resources[imageResourceName]) {
      next();
      return;
    }
    var multiPacks = (_b2 = (_a2 = resource.data) === null || _a2 === void 0 ? void 0 : _a2.meta) === null || _b2 === void 0 ? void 0 : _b2.related_multi_packs;
    if (Array.isArray(multiPacks)) {
      var _loop_1 = function(item2) {
        if (typeof item2 !== "string") {
          return "continue";
        }
        var itemName = item2.replace(".json", "");
        var itemUrl = url.resolve(resource.url.replace(loader.baseUrl, ""), item2);
        if (loader.resources[itemName] || Object.values(loader.resources).some(function(r2) {
          return url.format(url.parse(r2.url)) === itemUrl;
        })) {
          return "continue";
        }
        var options = {
          crossOrigin: resource.crossOrigin,
          loadType: LoaderResource.LOAD_TYPE.XHR,
          xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,
          parentResource: resource,
          metadata: resource.metadata
        };
        loader.add(itemName, itemUrl, options);
      };
      for (var _i = 0, multiPacks_1 = multiPacks; _i < multiPacks_1.length; _i++) {
        var item = multiPacks_1[_i];
        _loop_1(item);
      }
    }
    var loadOptions = {
      crossOrigin: resource.crossOrigin,
      metadata: resource.metadata.imageMetadata,
      parentResource: resource
    };
    var resourcePath = SpritesheetLoader2.getResourcePath(resource, loader.baseUrl);
    loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {
      if (res.error) {
        next(res.error);
        return;
      }
      var spritesheet = new Spritesheet(res.texture, resource.data, resource.url);
      spritesheet.parse().then(function() {
        resource.spritesheet = spritesheet;
        resource.textures = spritesheet.textures;
        next();
      });
    });
  };
  SpritesheetLoader2.getResourcePath = function(resource, baseUrl) {
    if (resource.isDataUrl) {
      return resource.data.meta.image;
    }
    return url.resolve(resource.url.replace(baseUrl, ""), resource.data.meta.image);
  };
  SpritesheetLoader2.extension = ExtensionType.Loader;
  return SpritesheetLoader2;
}();
/*!
 * @pixi/sprite-tiling - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$a = function(d2, b2) {
  extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$a(d2, b2);
};
function __extends$a(d2, b2) {
  extendStatics$a(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var tempPoint$1 = new Point();
(function(_super) {
  __extends$a(TilingSprite, _super);
  function TilingSprite(texture, width, height) {
    if (width === void 0) {
      width = 100;
    }
    if (height === void 0) {
      height = 100;
    }
    var _this = _super.call(this, texture) || this;
    _this.tileTransform = new Transform();
    _this._width = width;
    _this._height = height;
    _this.uvMatrix = _this.texture.uvMatrix || new TextureMatrix(texture);
    _this.pluginName = "tilingSprite";
    _this.uvRespectAnchor = false;
    return _this;
  }
  Object.defineProperty(TilingSprite.prototype, "clampMargin", {
    get: function() {
      return this.uvMatrix.clampMargin;
    },
    set: function(value) {
      this.uvMatrix.clampMargin = value;
      this.uvMatrix.update(true);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TilingSprite.prototype, "tileScale", {
    get: function() {
      return this.tileTransform.scale;
    },
    set: function(value) {
      this.tileTransform.scale.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TilingSprite.prototype, "tilePosition", {
    get: function() {
      return this.tileTransform.position;
    },
    set: function(value) {
      this.tileTransform.position.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  TilingSprite.prototype._onTextureUpdate = function() {
    if (this.uvMatrix) {
      this.uvMatrix.texture = this._texture;
    }
    this._cachedTint = 16777215;
  };
  TilingSprite.prototype._render = function(renderer2) {
    var texture = this._texture;
    if (!texture || !texture.valid) {
      return;
    }
    this.tileTransform.updateLocalTransform();
    this.uvMatrix.update();
    renderer2.batch.setObjectRenderer(renderer2.plugins[this.pluginName]);
    renderer2.plugins[this.pluginName].render(this);
  };
  TilingSprite.prototype._calculateBounds = function() {
    var minX = this._width * -this._anchor._x;
    var minY = this._height * -this._anchor._y;
    var maxX = this._width * (1 - this._anchor._x);
    var maxY = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  };
  TilingSprite.prototype.getLocalBounds = function(rect) {
    if (this.children.length === 0) {
      this._bounds.minX = this._width * -this._anchor._x;
      this._bounds.minY = this._height * -this._anchor._y;
      this._bounds.maxX = this._width * (1 - this._anchor._x);
      this._bounds.maxY = this._height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._bounds.getRectangle(rect);
    }
    return _super.prototype.getLocalBounds.call(this, rect);
  };
  TilingSprite.prototype.containsPoint = function(point) {
    this.worldTransform.applyInverse(point, tempPoint$1);
    var width = this._width;
    var height = this._height;
    var x1 = -width * this.anchor._x;
    if (tempPoint$1.x >= x1 && tempPoint$1.x < x1 + width) {
      var y1 = -height * this.anchor._y;
      if (tempPoint$1.y >= y1 && tempPoint$1.y < y1 + height) {
        return true;
      }
    }
    return false;
  };
  TilingSprite.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    this.tileTransform = null;
    this.uvMatrix = null;
  };
  TilingSprite.from = function(source, options) {
    var texture = source instanceof Texture ? source : Texture.from(source, options);
    return new TilingSprite(texture, options.width, options.height);
  };
  Object.defineProperty(TilingSprite.prototype, "width", {
    get: function() {
      return this._width;
    },
    set: function(value) {
      this._width = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TilingSprite.prototype, "height", {
    get: function() {
      return this._height;
    },
    set: function(value) {
      this._height = value;
    },
    enumerable: false,
    configurable: true
  });
  return TilingSprite;
})(Sprite);
var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";
var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";
var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";
var tempMat = new Matrix();
var TilingSpriteRenderer = function(_super) {
  __extends$a(TilingSpriteRenderer2, _super);
  function TilingSpriteRenderer2(renderer2) {
    var _this = _super.call(this, renderer2) || this;
    renderer2.runners.contextChange.add(_this);
    _this.quad = new QuadUv();
    _this.state = State.for2d();
    return _this;
  }
  TilingSpriteRenderer2.prototype.contextChange = function() {
    var renderer2 = this.renderer;
    var uniforms = { globals: renderer2.globalUniforms };
    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);
    this.shader = renderer2.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
  };
  TilingSpriteRenderer2.prototype.render = function(ts) {
    var renderer2 = this.renderer;
    var quad = this.quad;
    var vertices = quad.vertices;
    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
    var anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
    var anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
    vertices = quad.uvs;
    vertices[0] = vertices[6] = -anchorX;
    vertices[1] = vertices[3] = -anchorY;
    vertices[2] = vertices[4] = 1 - anchorX;
    vertices[5] = vertices[7] = 1 - anchorY;
    quad.invalidate();
    var tex = ts._texture;
    var baseTex = tex.baseTexture;
    var premultiplied = baseTex.alphaMode > 0;
    var lt = ts.tileTransform.localTransform;
    var uv = ts.uvMatrix;
    var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
    if (isSimple) {
      if (!baseTex._glTextures[renderer2.CONTEXT_UID]) {
        if (baseTex.wrapMode === WRAP_MODES.CLAMP) {
          baseTex.wrapMode = WRAP_MODES.REPEAT;
        }
      } else {
        isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;
      }
    }
    var shader = isSimple ? this.simpleShader : this.shader;
    var w2 = tex.width;
    var h2 = tex.height;
    var W = ts._width;
    var H = ts._height;
    tempMat.set(lt.a * w2 / W, lt.b * w2 / H, lt.c * h2 / W, lt.d * h2 / H, lt.tx / W, lt.ty / H);
    tempMat.invert();
    if (isSimple) {
      tempMat.prepend(uv.mapCoord);
    } else {
      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
      shader.uniforms.uClampFrame = uv.uClampFrame;
      shader.uniforms.uClampOffset = uv.uClampOffset;
    }
    shader.uniforms.uTransform = tempMat.toArray(true);
    shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, premultiplied);
    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
    shader.uniforms.uSampler = tex;
    renderer2.shader.bind(shader);
    renderer2.geometry.bind(quad);
    this.state.blendMode = correctBlendMode(ts.blendMode, premultiplied);
    renderer2.state.set(this.state);
    renderer2.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  };
  TilingSpriteRenderer2.extension = {
    name: "tilingSprite",
    type: ExtensionType.RendererPlugin
  };
  return TilingSpriteRenderer2;
}(ObjectRenderer);
/*!
 * @pixi/mesh - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$9 = function(d2, b2) {
  extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$9(d2, b2);
};
function __extends$9(d2, b2) {
  extendStatics$9(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var MeshBatchUvs = function() {
  function MeshBatchUvs2(uvBuffer, uvMatrix) {
    this.uvBuffer = uvBuffer;
    this.uvMatrix = uvMatrix;
    this.data = null;
    this._bufferUpdateId = -1;
    this._textureUpdateId = -1;
    this._updateID = 0;
  }
  MeshBatchUvs2.prototype.update = function(forceUpdate) {
    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
      return;
    }
    this._bufferUpdateId = this.uvBuffer._updateID;
    this._textureUpdateId = this.uvMatrix._updateID;
    var data = this.uvBuffer.data;
    if (!this.data || this.data.length !== data.length) {
      this.data = new Float32Array(data.length);
    }
    this.uvMatrix.multiplyUvs(data, this.data);
    this._updateID++;
  };
  return MeshBatchUvs2;
}();
var tempPoint = new Point();
var tempPolygon = new Polygon();
var Mesh = function(_super) {
  __extends$9(Mesh2, _super);
  function Mesh2(geometry, shader, state, drawMode) {
    if (drawMode === void 0) {
      drawMode = DRAW_MODES.TRIANGLES;
    }
    var _this = _super.call(this) || this;
    _this.geometry = geometry;
    _this.shader = shader;
    _this.state = state || State.for2d();
    _this.drawMode = drawMode;
    _this.start = 0;
    _this.size = 0;
    _this.uvs = null;
    _this.indices = null;
    _this.vertexData = new Float32Array(1);
    _this.vertexDirty = -1;
    _this._transformID = -1;
    _this._roundPixels = settings.ROUND_PIXELS;
    _this.batchUvs = null;
    return _this;
  }
  Object.defineProperty(Mesh2.prototype, "geometry", {
    get: function() {
      return this._geometry;
    },
    set: function(value) {
      if (this._geometry === value) {
        return;
      }
      if (this._geometry) {
        this._geometry.refCount--;
        if (this._geometry.refCount === 0) {
          this._geometry.dispose();
        }
      }
      this._geometry = value;
      if (this._geometry) {
        this._geometry.refCount++;
      }
      this.vertexDirty = -1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "uvBuffer", {
    get: function() {
      return this.geometry.buffers[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "verticesBuffer", {
    get: function() {
      return this.geometry.buffers[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "material", {
    get: function() {
      return this.shader;
    },
    set: function(value) {
      this.shader = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(value) {
      this.state.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(value) {
      if (this._roundPixels !== value) {
        this._transformID = -1;
      }
      this._roundPixels = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "tint", {
    get: function() {
      return "tint" in this.shader ? this.shader.tint : null;
    },
    set: function(value) {
      this.shader.tint = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "texture", {
    get: function() {
      return "texture" in this.shader ? this.shader.texture : null;
    },
    set: function(value) {
      this.shader.texture = value;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype._render = function(renderer2) {
    var vertices = this.geometry.buffers[0].data;
    var shader = this.shader;
    if (shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < Mesh2.BATCHABLE_SIZE * 2) {
      this._renderToBatch(renderer2);
    } else {
      this._renderDefault(renderer2);
    }
  };
  Mesh2.prototype._renderDefault = function(renderer2) {
    var shader = this.shader;
    shader.alpha = this.worldAlpha;
    if (shader.update) {
      shader.update();
    }
    renderer2.batch.flush();
    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
    renderer2.shader.bind(shader);
    renderer2.state.set(this.state);
    renderer2.geometry.bind(this.geometry, shader);
    renderer2.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  };
  Mesh2.prototype._renderToBatch = function(renderer2) {
    var geometry = this.geometry;
    var shader = this.shader;
    if (shader.uvMatrix) {
      shader.uvMatrix.update();
      this.calculateUvs();
    }
    this.calculateVertices();
    this.indices = geometry.indexBuffer.data;
    this._tintRGB = shader._tintRGB;
    this._texture = shader.texture;
    var pluginName = this.material.pluginName;
    renderer2.batch.setObjectRenderer(renderer2.plugins[pluginName]);
    renderer2.plugins[pluginName].render(this);
  };
  Mesh2.prototype.calculateVertices = function() {
    var geometry = this.geometry;
    var verticesBuffer = geometry.buffers[0];
    var vertices = verticesBuffer.data;
    var vertexDirtyId = verticesBuffer._updateID;
    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
      return;
    }
    this._transformID = this.transform._worldID;
    if (this.vertexData.length !== vertices.length) {
      this.vertexData = new Float32Array(vertices.length);
    }
    var wt = this.transform.worldTransform;
    var a2 = wt.a;
    var b2 = wt.b;
    var c = wt.c;
    var d2 = wt.d;
    var tx = wt.tx;
    var ty = wt.ty;
    var vertexData = this.vertexData;
    for (var i = 0; i < vertexData.length / 2; i++) {
      var x2 = vertices[i * 2];
      var y2 = vertices[i * 2 + 1];
      vertexData[i * 2] = a2 * x2 + c * y2 + tx;
      vertexData[i * 2 + 1] = b2 * x2 + d2 * y2 + ty;
    }
    if (this._roundPixels) {
      var resolution = settings.RESOLUTION;
      for (var i = 0; i < vertexData.length; ++i) {
        vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);
      }
    }
    this.vertexDirty = vertexDirtyId;
  };
  Mesh2.prototype.calculateUvs = function() {
    var geomUvs = this.geometry.buffers[1];
    var shader = this.shader;
    if (!shader.uvMatrix.isSimple) {
      if (!this.batchUvs) {
        this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
      }
      this.batchUvs.update();
      this.uvs = this.batchUvs.data;
    } else {
      this.uvs = geomUvs.data;
    }
  };
  Mesh2.prototype._calculateBounds = function() {
    this.calculateVertices();
    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  };
  Mesh2.prototype.containsPoint = function(point) {
    if (!this.getBounds().contains(point.x, point.y)) {
      return false;
    }
    this.worldTransform.applyInverse(point, tempPoint);
    var vertices = this.geometry.getBuffer("aVertexPosition").data;
    var points = tempPolygon.points;
    var indices3 = this.geometry.getIndex().data;
    var len = indices3.length;
    var step = this.drawMode === 4 ? 3 : 1;
    for (var i = 0; i + 2 < len; i += step) {
      var ind0 = indices3[i] * 2;
      var ind1 = indices3[i + 1] * 2;
      var ind2 = indices3[i + 2] * 2;
      points[0] = vertices[ind0];
      points[1] = vertices[ind0 + 1];
      points[2] = vertices[ind1];
      points[3] = vertices[ind1 + 1];
      points[4] = vertices[ind2];
      points[5] = vertices[ind2 + 1];
      if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
        return true;
      }
    }
    return false;
  };
  Mesh2.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    if (this._cachedTexture) {
      this._cachedTexture.destroy();
      this._cachedTexture = null;
    }
    this.geometry = null;
    this.shader = null;
    this.state = null;
    this.uvs = null;
    this.indices = null;
    this.vertexData = null;
  };
  Mesh2.BATCHABLE_SIZE = 100;
  return Mesh2;
}(Container);
var fragment$5 = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";
var vertex$2 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var MeshMaterial = function(_super) {
  __extends$9(MeshMaterial2, _super);
  function MeshMaterial2(uSampler, options) {
    var _this = this;
    var uniforms = {
      uSampler,
      alpha: 1,
      uTextureMatrix: Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    options = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, options);
    if (options.uniforms) {
      Object.assign(uniforms, options.uniforms);
    }
    _this = _super.call(this, options.program || Program.from(vertex$2, fragment$5), uniforms) || this;
    _this._colorDirty = false;
    _this.uvMatrix = new TextureMatrix(uSampler);
    _this.batchable = options.program === void 0;
    _this.pluginName = options.pluginName;
    _this.tint = options.tint;
    _this.alpha = options.alpha;
    return _this;
  }
  Object.defineProperty(MeshMaterial2.prototype, "texture", {
    get: function() {
      return this.uniforms.uSampler;
    },
    set: function(value) {
      if (this.uniforms.uSampler !== value) {
        if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {
          this._colorDirty = true;
        }
        this.uniforms.uSampler = value;
        this.uvMatrix.texture = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MeshMaterial2.prototype, "alpha", {
    get: function() {
      return this._alpha;
    },
    set: function(value) {
      if (value === this._alpha) {
        return;
      }
      this._alpha = value;
      this._colorDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MeshMaterial2.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      if (value === this._tint) {
        return;
      }
      this._tint = value;
      this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
      this._colorDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  MeshMaterial2.prototype.update = function() {
    if (this._colorDirty) {
      this._colorDirty = false;
      var baseTexture = this.texture.baseTexture;
      premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);
    }
    if (this.uvMatrix.update()) {
      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
    }
  };
  return MeshMaterial2;
}(Shader);
var MeshGeometry = function(_super) {
  __extends$9(MeshGeometry2, _super);
  function MeshGeometry2(vertices, uvs, index) {
    var _this = _super.call(this) || this;
    var verticesBuffer = new Buffer(vertices);
    var uvsBuffer = new Buffer(uvs, true);
    var indexBuffer = new Buffer(index, true, true);
    _this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES.FLOAT).addIndex(indexBuffer);
    _this._updateId = -1;
    return _this;
  }
  Object.defineProperty(MeshGeometry2.prototype, "vertexDirtyId", {
    get: function() {
      return this.buffers[0]._updateID;
    },
    enumerable: false,
    configurable: true
  });
  return MeshGeometry2;
}(Geometry);
/*!
 * @pixi/text-bitmap - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/text-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$8 = function(d2, b2) {
  extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$8(d2, b2);
};
function __extends$8(d2, b2) {
  extendStatics$8(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var BitmapFontData = function() {
  function BitmapFontData2() {
    this.info = [];
    this.common = [];
    this.page = [];
    this.char = [];
    this.kerning = [];
    this.distanceField = [];
  }
  return BitmapFontData2;
}();
var TextFormat = function() {
  function TextFormat2() {
  }
  TextFormat2.test = function(data) {
    return typeof data === "string" && data.indexOf("info face=") === 0;
  };
  TextFormat2.parse = function(txt) {
    var items = txt.match(/^[a-z]+\s+.+$/gm);
    var rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (var i in items) {
      var name = items[i].match(/^[a-z]+/gm)[0];
      var attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
      var itemData = {};
      for (var i_1 in attributeList) {
        var split2 = attributeList[i_1].split("=");
        var key = split2[0];
        var strValue2 = split2[1].replace(/"/gm, "");
        var floatValue = parseFloat(strValue2);
        var value = isNaN(floatValue) ? strValue2 : floatValue;
        itemData[key] = value;
      }
      rawData[name].push(itemData);
    }
    var font = new BitmapFontData();
    rawData.info.forEach(function(info) {
      return font.info.push({
        face: info.face,
        size: parseInt(info.size, 10)
      });
    });
    rawData.common.forEach(function(common) {
      return font.common.push({
        lineHeight: parseInt(common.lineHeight, 10)
      });
    });
    rawData.page.forEach(function(page) {
      return font.page.push({
        id: parseInt(page.id, 10),
        file: page.file
      });
    });
    rawData.char.forEach(function(char) {
      return font.char.push({
        id: parseInt(char.id, 10),
        page: parseInt(char.page, 10),
        x: parseInt(char.x, 10),
        y: parseInt(char.y, 10),
        width: parseInt(char.width, 10),
        height: parseInt(char.height, 10),
        xoffset: parseInt(char.xoffset, 10),
        yoffset: parseInt(char.yoffset, 10),
        xadvance: parseInt(char.xadvance, 10)
      });
    });
    rawData.kerning.forEach(function(kerning) {
      return font.kerning.push({
        first: parseInt(kerning.first, 10),
        second: parseInt(kerning.second, 10),
        amount: parseInt(kerning.amount, 10)
      });
    });
    rawData.distanceField.forEach(function(df) {
      return font.distanceField.push({
        distanceRange: parseInt(df.distanceRange, 10),
        fieldType: df.fieldType
      });
    });
    return font;
  };
  return TextFormat2;
}();
var XMLFormat = function() {
  function XMLFormat2() {
  }
  XMLFormat2.test = function(data) {
    return data instanceof XMLDocument && data.getElementsByTagName("page").length && data.getElementsByTagName("info")[0].getAttribute("face") !== null;
  };
  XMLFormat2.parse = function(xml) {
    var data = new BitmapFontData();
    var info = xml.getElementsByTagName("info");
    var common = xml.getElementsByTagName("common");
    var page = xml.getElementsByTagName("page");
    var char = xml.getElementsByTagName("char");
    var kerning = xml.getElementsByTagName("kerning");
    var distanceField = xml.getElementsByTagName("distanceField");
    for (var i = 0; i < info.length; i++) {
      data.info.push({
        face: info[i].getAttribute("face"),
        size: parseInt(info[i].getAttribute("size"), 10)
      });
    }
    for (var i = 0; i < common.length; i++) {
      data.common.push({
        lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)
      });
    }
    for (var i = 0; i < page.length; i++) {
      data.page.push({
        id: parseInt(page[i].getAttribute("id"), 10) || 0,
        file: page[i].getAttribute("file")
      });
    }
    for (var i = 0; i < char.length; i++) {
      var letter = char[i];
      data.char.push({
        id: parseInt(letter.getAttribute("id"), 10),
        page: parseInt(letter.getAttribute("page"), 10) || 0,
        x: parseInt(letter.getAttribute("x"), 10),
        y: parseInt(letter.getAttribute("y"), 10),
        width: parseInt(letter.getAttribute("width"), 10),
        height: parseInt(letter.getAttribute("height"), 10),
        xoffset: parseInt(letter.getAttribute("xoffset"), 10),
        yoffset: parseInt(letter.getAttribute("yoffset"), 10),
        xadvance: parseInt(letter.getAttribute("xadvance"), 10)
      });
    }
    for (var i = 0; i < kerning.length; i++) {
      data.kerning.push({
        first: parseInt(kerning[i].getAttribute("first"), 10),
        second: parseInt(kerning[i].getAttribute("second"), 10),
        amount: parseInt(kerning[i].getAttribute("amount"), 10)
      });
    }
    for (var i = 0; i < distanceField.length; i++) {
      data.distanceField.push({
        fieldType: distanceField[i].getAttribute("fieldType"),
        distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)
      });
    }
    return data;
  };
  return XMLFormat2;
}();
var XMLStringFormat = function() {
  function XMLStringFormat2() {
  }
  XMLStringFormat2.test = function(data) {
    if (typeof data === "string" && data.indexOf("<font>") > -1) {
      var xml = new globalThis.DOMParser().parseFromString(data, "text/xml");
      return XMLFormat.test(xml);
    }
    return false;
  };
  XMLStringFormat2.parse = function(xmlTxt) {
    var xml = new globalThis.DOMParser().parseFromString(xmlTxt, "text/xml");
    return XMLFormat.parse(xml);
  };
  return XMLStringFormat2;
}();
var formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];
function autoDetectFormat(data) {
  for (var i = 0; i < formats.length; i++) {
    if (formats[i].test(data)) {
      return formats[i];
    }
  }
  return null;
}
function generateFillStyle(canvas, context2, style, resolution, lines, metrics) {
  var fillStyle = style.fill;
  if (!Array.isArray(fillStyle)) {
    return fillStyle;
  } else if (fillStyle.length === 1) {
    return fillStyle[0];
  }
  var gradient;
  var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
  var padding = style.padding || 0;
  var width = canvas.width / resolution - dropShadowCorrection - padding * 2;
  var height = canvas.height / resolution - dropShadowCorrection - padding * 2;
  var fill = fillStyle.slice();
  var fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    var lengthPlus1 = fill.length + 1;
    for (var i = 1; i < lengthPlus1; ++i) {
      fillGradientStops.push(i / lengthPlus1);
    }
  }
  fill.unshift(fillStyle[0]);
  fillGradientStops.unshift(0);
  fill.push(fillStyle[fillStyle.length - 1]);
  fillGradientStops.push(1);
  if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context2.createLinearGradient(width / 2, padding, width / 2, height + padding);
    var lastIterationStop = 0;
    var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
    var gradStopLineHeight = textHeight / height;
    for (var i = 0; i < lines.length; i++) {
      var thisLineTop = metrics.lineHeight * i;
      for (var j2 = 0; j2 < fill.length; j2++) {
        var lineStop = 0;
        if (typeof fillGradientStops[j2] === "number") {
          lineStop = fillGradientStops[j2];
        } else {
          lineStop = j2 / fill.length;
        }
        var globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        var clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1);
        gradient.addColorStop(clampedStop, fill[j2]);
        lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context2.createLinearGradient(padding, height / 2, width + padding, height / 2);
    var totalIterations = fill.length + 1;
    var currentIteration = 1;
    for (var i = 0; i < fill.length; i++) {
      var stop = void 0;
      if (typeof fillGradientStops[i] === "number") {
        stop = fillGradientStops[i];
      } else {
        stop = currentIteration / totalIterations;
      }
      gradient.addColorStop(stop, fill[i]);
      currentIteration++;
    }
  }
  return gradient;
}
function drawGlyph(canvas, context2, metrics, x2, y2, resolution, style) {
  var char = metrics.text;
  var fontProperties = metrics.fontProperties;
  context2.translate(x2, y2);
  context2.scale(resolution, resolution);
  var tx = style.strokeThickness / 2;
  var ty = -(style.strokeThickness / 2);
  context2.font = style.toFontString();
  context2.lineWidth = style.strokeThickness;
  context2.textBaseline = style.textBaseline;
  context2.lineJoin = style.lineJoin;
  context2.miterLimit = style.miterLimit;
  context2.fillStyle = generateFillStyle(canvas, context2, style, resolution, [char], metrics);
  context2.strokeStyle = style.stroke;
  if (style.dropShadow) {
    var dropShadowColor = style.dropShadowColor;
    var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
    var dropShadowBlur = style.dropShadowBlur * resolution;
    var dropShadowDistance = style.dropShadowDistance * resolution;
    context2.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
    context2.shadowBlur = dropShadowBlur;
    context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
    context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else {
    context2.shadowColor = "black";
    context2.shadowBlur = 0;
    context2.shadowOffsetX = 0;
    context2.shadowOffsetY = 0;
  }
  if (style.stroke && style.strokeThickness) {
    context2.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  if (style.fill) {
    context2.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  context2.setTransform(1, 0, 0, 1, 0, 0);
  context2.fillStyle = "rgba(0, 0, 0, 0)";
}
function splitTextToCharacters(text) {
  return Array.from ? Array.from(text) : text.split("");
}
function resolveCharacters(chars) {
  if (typeof chars === "string") {
    chars = [chars];
  }
  var result = [];
  for (var i = 0, j2 = chars.length; i < j2; i++) {
    var item = chars[i];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + item.length + ".");
      }
      var startCode = item[0].charCodeAt(0);
      var endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (var i_1 = startCode, j_1 = endCode; i_1 <= j_1; i_1++) {
        result.push(String.fromCharCode(i_1));
      }
    } else {
      result.push.apply(result, splitTextToCharacters(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
function extractCharCode(str) {
  return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
}
var BitmapFont = function() {
  function BitmapFont2(data, textures, ownsTextures) {
    var _a2, _b2;
    var info = data.info[0];
    var common = data.common[0];
    var page = data.page[0];
    var distanceField = data.distanceField[0];
    var res = getResolutionOfUrl(page.file);
    var pageTextures = {};
    this._ownsTextures = ownsTextures;
    this.font = info.face;
    this.size = info.size;
    this.lineHeight = common.lineHeight / res;
    this.chars = {};
    this.pageTextures = pageTextures;
    for (var i = 0; i < data.page.length; i++) {
      var _c2 = data.page[i], id = _c2.id, file = _c2.file;
      pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];
      if ((distanceField === null || distanceField === void 0 ? void 0 : distanceField.fieldType) && distanceField.fieldType !== "none") {
        pageTextures[id].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;
        pageTextures[id].baseTexture.mipmap = MIPMAP_MODES.OFF;
      }
    }
    for (var i = 0; i < data.char.length; i++) {
      var _d = data.char[i], id = _d.id, page_1 = _d.page;
      var _e = data.char[i], x2 = _e.x, y2 = _e.y, width = _e.width, height = _e.height, xoffset = _e.xoffset, yoffset = _e.yoffset, xadvance = _e.xadvance;
      x2 /= res;
      y2 /= res;
      width /= res;
      height /= res;
      xoffset /= res;
      yoffset /= res;
      xadvance /= res;
      var rect = new Rectangle(x2 + pageTextures[page_1].frame.x / res, y2 + pageTextures[page_1].frame.y / res, width, height);
      this.chars[id] = {
        xOffset: xoffset,
        yOffset: yoffset,
        xAdvance: xadvance,
        kerning: {},
        texture: new Texture(pageTextures[page_1].baseTexture, rect),
        page: page_1
      };
    }
    for (var i = 0; i < data.kerning.length; i++) {
      var _f = data.kerning[i], first = _f.first, second = _f.second, amount = _f.amount;
      first /= res;
      second /= res;
      amount /= res;
      if (this.chars[second]) {
        this.chars[second].kerning[first] = amount;
      }
    }
    this.distanceFieldRange = distanceField === null || distanceField === void 0 ? void 0 : distanceField.distanceRange;
    this.distanceFieldType = (_b2 = (_a2 = distanceField === null || distanceField === void 0 ? void 0 : distanceField.fieldType) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) !== null && _b2 !== void 0 ? _b2 : "none";
  }
  BitmapFont2.prototype.destroy = function() {
    for (var id in this.chars) {
      this.chars[id].texture.destroy();
      this.chars[id].texture = null;
    }
    for (var id in this.pageTextures) {
      if (this._ownsTextures) {
        this.pageTextures[id].destroy(true);
      }
      this.pageTextures[id] = null;
    }
    this.chars = null;
    this.pageTextures = null;
  };
  BitmapFont2.install = function(data, textures, ownsTextures) {
    var fontData;
    if (data instanceof BitmapFontData) {
      fontData = data;
    } else {
      var format2 = autoDetectFormat(data);
      if (!format2) {
        throw new Error("Unrecognized data format for font.");
      }
      fontData = format2.parse(data);
    }
    if (textures instanceof Texture) {
      textures = [textures];
    }
    var font = new BitmapFont2(fontData, textures, ownsTextures);
    BitmapFont2.available[font.font] = font;
    return font;
  };
  BitmapFont2.uninstall = function(name) {
    var font = BitmapFont2.available[name];
    if (!font) {
      throw new Error("No font found named '" + name + "'");
    }
    font.destroy();
    delete BitmapFont2.available[name];
  };
  BitmapFont2.from = function(name, textStyle, options) {
    if (!name) {
      throw new Error("[BitmapFont] Property `name` is required.");
    }
    var _a2 = Object.assign({}, BitmapFont2.defaultOptions, options), chars = _a2.chars, padding = _a2.padding, resolution = _a2.resolution, textureWidth = _a2.textureWidth, textureHeight = _a2.textureHeight;
    var charsList = resolveCharacters(chars);
    var style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
    var lineWidth = textureWidth;
    var fontData = new BitmapFontData();
    fontData.info[0] = {
      face: style.fontFamily,
      size: style.fontSize
    };
    fontData.common[0] = {
      lineHeight: style.fontSize
    };
    var positionX = 0;
    var positionY = 0;
    var canvas;
    var context2;
    var baseTexture;
    var maxCharHeight = 0;
    var textures = [];
    for (var i = 0; i < charsList.length; i++) {
      if (!canvas) {
        canvas = settings.ADAPTER.createCanvas();
        canvas.width = textureWidth;
        canvas.height = textureHeight;
        context2 = canvas.getContext("2d");
        baseTexture = new BaseTexture(canvas, { resolution });
        textures.push(new Texture(baseTexture));
        fontData.page.push({
          id: textures.length - 1,
          file: ""
        });
      }
      var character = charsList[i];
      var metrics = TextMetrics.measureText(character, style, false, canvas);
      var width = metrics.width;
      var height = Math.ceil(metrics.height);
      var textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      if (positionY >= textureHeight - height * resolution) {
        if (positionY === 0) {
          throw new Error("[BitmapFont] textureHeight " + textureHeight + "px is too small " + ("(fontFamily: '" + style.fontFamily + "', fontSize: " + style.fontSize + "px, char: '" + character + "')"));
        }
        --i;
        canvas = null;
        context2 = null;
        baseTexture = null;
        positionY = 0;
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
      if (textureGlyphWidth * resolution + positionX >= lineWidth) {
        if (positionX === 0) {
          throw new Error("[BitmapFont] textureWidth " + textureWidth + "px is too small " + ("(fontFamily: '" + style.fontFamily + "', fontSize: " + style.fontSize + "px, char: '" + character + "')"));
        }
        --i;
        positionY += maxCharHeight * resolution;
        positionY = Math.ceil(positionY);
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      drawGlyph(canvas, context2, metrics, positionX, positionY, resolution, style);
      var id = extractCharCode(metrics.text);
      fontData.char.push({
        id,
        page: textures.length - 1,
        x: positionX / resolution,
        y: positionY / resolution,
        width: textureGlyphWidth,
        height,
        xoffset: 0,
        yoffset: 0,
        xadvance: Math.ceil(width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0))
      });
      positionX += (textureGlyphWidth + 2 * padding) * resolution;
      positionX = Math.ceil(positionX);
    }
    if (!(options === null || options === void 0 ? void 0 : options.skipKerning)) {
      for (var i = 0, len = charsList.length; i < len; i++) {
        var first = charsList[i];
        for (var j2 = 0; j2 < len; j2++) {
          var second = charsList[j2];
          var c1 = context2.measureText(first).width;
          var c2 = context2.measureText(second).width;
          var total = context2.measureText(first + second).width;
          var amount = total - (c1 + c2);
          if (amount) {
            fontData.kerning.push({
              first: extractCharCode(first),
              second: extractCharCode(second),
              amount
            });
          }
        }
      }
    }
    var font = new BitmapFont2(fontData, textures, true);
    if (BitmapFont2.available[name] !== void 0) {
      BitmapFont2.uninstall(name);
    }
    BitmapFont2.available[name] = font;
    return font;
  };
  BitmapFont2.ALPHA = [["a", "z"], ["A", "Z"], " "];
  BitmapFont2.NUMERIC = [["0", "9"]];
  BitmapFont2.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
  BitmapFont2.ASCII = [[" ", "~"]];
  BitmapFont2.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: BitmapFont2.ALPHANUMERIC
  };
  BitmapFont2.available = {};
  return BitmapFont2;
}();
var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n";
var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
var pageMeshDataDefaultPageMeshData = [];
var pageMeshDataMSDFPageMeshData = [];
var charRenderDataPool = [];
(function(_super) {
  __extends$8(BitmapText, _super);
  function BitmapText(text, style) {
    if (style === void 0) {
      style = {};
    }
    var _this = _super.call(this) || this;
    _this._tint = 16777215;
    var _a2 = Object.assign({}, BitmapText.styleDefaults, style), align = _a2.align, tint = _a2.tint, maxWidth = _a2.maxWidth, letterSpacing = _a2.letterSpacing, fontName = _a2.fontName, fontSize = _a2.fontSize;
    if (!BitmapFont.available[fontName]) {
      throw new Error('Missing BitmapFont "' + fontName + '"');
    }
    _this._activePagesMeshData = [];
    _this._textWidth = 0;
    _this._textHeight = 0;
    _this._align = align;
    _this._tint = tint;
    _this._font = void 0;
    _this._fontName = fontName;
    _this._fontSize = fontSize;
    _this.text = text;
    _this._maxWidth = maxWidth;
    _this._maxLineHeight = 0;
    _this._letterSpacing = letterSpacing;
    _this._anchor = new ObservablePoint(function() {
      _this.dirty = true;
    }, _this, 0, 0);
    _this._roundPixels = settings.ROUND_PIXELS;
    _this.dirty = true;
    _this._resolution = settings.RESOLUTION;
    _this._autoResolution = true;
    _this._textureCache = {};
    return _this;
  }
  BitmapText.prototype.updateText = function() {
    var _a2;
    var data = BitmapFont.available[this._fontName];
    var fontSize = this.fontSize;
    var scale = fontSize / data.size;
    var pos = new Point();
    var chars = [];
    var lineWidths = [];
    var lineSpaces = [];
    var text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
    var charsInput = splitTextToCharacters(text);
    var maxWidth = this._maxWidth * data.size / fontSize;
    var pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    var prevCharCode = null;
    var lastLineWidth = 0;
    var maxLineWidth = 0;
    var line = 0;
    var lastBreakPos = -1;
    var lastBreakWidth = 0;
    var spacesRemoved = 0;
    var maxLineHeight = 0;
    var spaceCount = 0;
    for (var i = 0; i < charsInput.length; i++) {
      var char = charsInput[i];
      var charCode = extractCharCode(char);
      if (/(?:\s)/.test(char)) {
        lastBreakPos = i;
        lastBreakWidth = lastLineWidth;
        spaceCount++;
      }
      if (char === "\r" || char === "\n") {
        lineWidths.push(lastLineWidth);
        lineSpaces.push(-1);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        ++line;
        ++spacesRemoved;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
        continue;
      }
      var charData = data.chars[charCode];
      if (!charData) {
        continue;
      }
      if (prevCharCode && charData.kerning[prevCharCode]) {
        pos.x += charData.kerning[prevCharCode];
      }
      var charRenderData = charRenderDataPool.pop() || {
        texture: Texture.EMPTY,
        line: 0,
        charCode: 0,
        prevSpaces: 0,
        position: new Point()
      };
      charRenderData.texture = charData.texture;
      charRenderData.line = line;
      charRenderData.charCode = charCode;
      charRenderData.position.x = pos.x + charData.xOffset + this._letterSpacing / 2;
      charRenderData.position.y = pos.y + charData.yOffset;
      charRenderData.prevSpaces = spaceCount;
      chars.push(charRenderData);
      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);
      pos.x += charData.xAdvance + this._letterSpacing;
      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
      prevCharCode = charCode;
      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
        ++spacesRemoved;
        removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
        i = lastBreakPos;
        lastBreakPos = -1;
        lineWidths.push(lastBreakWidth);
        lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
        line++;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
      }
    }
    var lastChar = charsInput[charsInput.length - 1];
    if (lastChar !== "\r" && lastChar !== "\n") {
      if (/(?:\s)/.test(lastChar)) {
        lastLineWidth = lastBreakWidth;
      }
      lineWidths.push(lastLineWidth);
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      lineSpaces.push(-1);
    }
    var lineAlignOffsets = [];
    for (var i = 0; i <= line; i++) {
      var alignOffset = 0;
      if (this._align === "right") {
        alignOffset = maxLineWidth - lineWidths[i];
      } else if (this._align === "center") {
        alignOffset = (maxLineWidth - lineWidths[i]) / 2;
      } else if (this._align === "justify") {
        alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];
      }
      lineAlignOffsets.push(alignOffset);
    }
    var lenChars = chars.length;
    var pagesMeshData = {};
    var newPagesMeshData = [];
    var activePagesMeshData = this._activePagesMeshData;
    pageMeshDataPool.push.apply(pageMeshDataPool, activePagesMeshData);
    for (var i = 0; i < lenChars; i++) {
      var texture = chars[i].texture;
      var baseTextureUid = texture.baseTexture.uid;
      if (!pagesMeshData[baseTextureUid]) {
        var pageMeshData = pageMeshDataPool.pop();
        if (!pageMeshData) {
          var geometry = new MeshGeometry();
          var material = void 0;
          var meshBlendMode = void 0;
          if (data.distanceFieldType === "none") {
            material = new MeshMaterial(Texture.EMPTY);
            meshBlendMode = BLEND_MODES.NORMAL;
          } else {
            material = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });
            meshBlendMode = BLEND_MODES.NORMAL_NPM;
          }
          var mesh = new Mesh(geometry, material);
          mesh.blendMode = meshBlendMode;
          pageMeshData = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        pageMeshData.index = 0;
        pageMeshData.indexCount = 0;
        pageMeshData.vertexCount = 0;
        pageMeshData.uvsCount = 0;
        pageMeshData.total = 0;
        var _textureCache = this._textureCache;
        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);
        pageMeshData.mesh.texture = _textureCache[baseTextureUid];
        pageMeshData.mesh.tint = this._tint;
        newPagesMeshData.push(pageMeshData);
        pagesMeshData[baseTextureUid] = pageMeshData;
      }
      pagesMeshData[baseTextureUid].total++;
    }
    for (var i = 0; i < activePagesMeshData.length; i++) {
      if (newPagesMeshData.indexOf(activePagesMeshData[i]) === -1) {
        this.removeChild(activePagesMeshData[i].mesh);
      }
    }
    for (var i = 0; i < newPagesMeshData.length; i++) {
      if (newPagesMeshData[i].mesh.parent !== this) {
        this.addChild(newPagesMeshData[i].mesh);
      }
    }
    this._activePagesMeshData = newPagesMeshData;
    for (var i in pagesMeshData) {
      var pageMeshData = pagesMeshData[i];
      var total = pageMeshData.total;
      if (!(((_a2 = pageMeshData.indices) === null || _a2 === void 0 ? void 0 : _a2.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
        pageMeshData.vertices = new Float32Array(4 * 2 * total);
        pageMeshData.uvs = new Float32Array(4 * 2 * total);
        pageMeshData.indices = new Uint16Array(6 * total);
      } else {
        var total_1 = pageMeshData.total;
        var vertices = pageMeshData.vertices;
        for (var i_1 = total_1 * 4 * 2; i_1 < vertices.length; i_1++) {
          vertices[i_1] = 0;
        }
      }
      pageMeshData.mesh.size = 6 * total;
    }
    for (var i = 0; i < lenChars; i++) {
      var char = chars[i];
      var offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
      if (this._roundPixels) {
        offset = Math.round(offset);
      }
      var xPos = offset * scale;
      var yPos = char.position.y * scale;
      var texture = char.texture;
      var pageMesh = pagesMeshData[texture.baseTexture.uid];
      var textureFrame = texture.frame;
      var textureUvs = texture._uvs;
      var index = pageMesh.index++;
      pageMesh.indices[index * 6 + 0] = 0 + index * 4;
      pageMesh.indices[index * 6 + 1] = 1 + index * 4;
      pageMesh.indices[index * 6 + 2] = 2 + index * 4;
      pageMesh.indices[index * 6 + 3] = 0 + index * 4;
      pageMesh.indices[index * 6 + 4] = 2 + index * 4;
      pageMesh.indices[index * 6 + 5] = 3 + index * 4;
      pageMesh.vertices[index * 8 + 0] = xPos;
      pageMesh.vertices[index * 8 + 1] = yPos;
      pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 3] = yPos;
      pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;
      pageMesh.vertices[index * 8 + 6] = xPos;
      pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;
      pageMesh.uvs[index * 8 + 0] = textureUvs.x0;
      pageMesh.uvs[index * 8 + 1] = textureUvs.y0;
      pageMesh.uvs[index * 8 + 2] = textureUvs.x1;
      pageMesh.uvs[index * 8 + 3] = textureUvs.y1;
      pageMesh.uvs[index * 8 + 4] = textureUvs.x2;
      pageMesh.uvs[index * 8 + 5] = textureUvs.y2;
      pageMesh.uvs[index * 8 + 6] = textureUvs.x3;
      pageMesh.uvs[index * 8 + 7] = textureUvs.y3;
    }
    this._textWidth = maxLineWidth * scale;
    this._textHeight = (pos.y + data.lineHeight) * scale;
    for (var i in pagesMeshData) {
      var pageMeshData = pagesMeshData[i];
      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
        var vertexCount = 0;
        var anchorOffsetX = this._textWidth * this.anchor.x;
        var anchorOffsetY = this._textHeight * this.anchor.y;
        for (var i_2 = 0; i_2 < pageMeshData.total; i_2++) {
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
        }
      }
      this._maxLineHeight = maxLineHeight * scale;
      var vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
      var textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
      var indexBuffer = pageMeshData.mesh.geometry.getIndex();
      vertexBuffer.data = pageMeshData.vertices;
      textureBuffer.data = pageMeshData.uvs;
      indexBuffer.data = pageMeshData.indices;
      vertexBuffer.update();
      textureBuffer.update();
      indexBuffer.update();
    }
    for (var i = 0; i < chars.length; i++) {
      charRenderDataPool.push(chars[i]);
    }
    this._font = data;
    this.dirty = false;
  };
  BitmapText.prototype.updateTransform = function() {
    this.validate();
    this.containerUpdateTransform();
  };
  BitmapText.prototype._render = function(renderer2) {
    if (this._autoResolution && this._resolution !== renderer2.resolution) {
      this._resolution = renderer2.resolution;
      this.dirty = true;
    }
    var _a2 = BitmapFont.available[this._fontName], distanceFieldRange = _a2.distanceFieldRange, distanceFieldType = _a2.distanceFieldType, size = _a2.size;
    if (distanceFieldType !== "none") {
      var _b2 = this.worldTransform, a2 = _b2.a, b2 = _b2.b, c = _b2.c, d2 = _b2.d;
      var dx = Math.sqrt(a2 * a2 + b2 * b2);
      var dy = Math.sqrt(c * c + d2 * d2);
      var worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
      var fontScale = this.fontSize / size;
      for (var _i = 0, _c2 = this._activePagesMeshData; _i < _c2.length; _i++) {
        var mesh = _c2[_i];
        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * this._resolution;
      }
    }
    _super.prototype._render.call(this, renderer2);
  };
  BitmapText.prototype.getLocalBounds = function() {
    this.validate();
    return _super.prototype.getLocalBounds.call(this);
  };
  BitmapText.prototype.validate = function() {
    var font = BitmapFont.available[this._fontName];
    if (!font) {
      throw new Error('Missing BitmapFont "' + this._fontName + '"');
    }
    if (this._font !== font) {
      this.dirty = true;
    }
    if (this.dirty) {
      this.updateText();
    }
  };
  Object.defineProperty(BitmapText.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      if (this._tint === value) {
        return;
      }
      this._tint = value;
      for (var i = 0; i < this._activePagesMeshData.length; i++) {
        this._activePagesMeshData[i].mesh.tint = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "align", {
    get: function() {
      return this._align;
    },
    set: function(value) {
      if (this._align !== value) {
        this._align = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "fontName", {
    get: function() {
      return this._fontName;
    },
    set: function(value) {
      if (!BitmapFont.available[value]) {
        throw new Error('Missing BitmapFont "' + value + '"');
      }
      if (this._fontName !== value) {
        this._fontName = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "fontSize", {
    get: function() {
      var _a2;
      return (_a2 = this._fontSize) !== null && _a2 !== void 0 ? _a2 : BitmapFont.available[this._fontName].size;
    },
    set: function(value) {
      if (this._fontSize !== value) {
        this._fontSize = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "anchor", {
    get: function() {
      return this._anchor;
    },
    set: function(value) {
      if (typeof value === "number") {
        this._anchor.set(value);
      } else {
        this._anchor.copyFrom(value);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "text", {
    get: function() {
      return this._text;
    },
    set: function(text) {
      text = String(text === null || text === void 0 ? "" : text);
      if (this._text === text) {
        return;
      }
      this._text = text;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "maxWidth", {
    get: function() {
      return this._maxWidth;
    },
    set: function(value) {
      if (this._maxWidth === value) {
        return;
      }
      this._maxWidth = value;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "maxLineHeight", {
    get: function() {
      this.validate();
      return this._maxLineHeight;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "textWidth", {
    get: function() {
      this.validate();
      return this._textWidth;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "letterSpacing", {
    get: function() {
      return this._letterSpacing;
    },
    set: function(value) {
      if (this._letterSpacing !== value) {
        this._letterSpacing = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(value) {
      if (value !== this._roundPixels) {
        this._roundPixels = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "textHeight", {
    get: function() {
      this.validate();
      return this._textHeight;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(value) {
      this._autoResolution = false;
      if (this._resolution === value) {
        return;
      }
      this._resolution = value;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  BitmapText.prototype.destroy = function(options) {
    var _textureCache = this._textureCache;
    var data = BitmapFont.available[this._fontName];
    var pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    pageMeshDataPool.push.apply(pageMeshDataPool, this._activePagesMeshData);
    for (var _i = 0, _a2 = this._activePagesMeshData; _i < _a2.length; _i++) {
      var pageMeshData = _a2[_i];
      this.removeChild(pageMeshData.mesh);
    }
    this._activePagesMeshData = [];
    pageMeshDataPool.filter(function(page) {
      return _textureCache[page.mesh.texture.baseTexture.uid];
    }).forEach(function(page) {
      page.mesh.texture = Texture.EMPTY;
    });
    for (var id in _textureCache) {
      var texture = _textureCache[id];
      texture.destroy();
      delete _textureCache[id];
    }
    this._font = null;
    this._textureCache = null;
    _super.prototype.destroy.call(this, options);
  };
  BitmapText.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  };
  return BitmapText;
})(Container);
var BitmapFontLoader = function() {
  function BitmapFontLoader2() {
  }
  BitmapFontLoader2.add = function() {
    LoaderResource.setExtensionXhrType("fnt", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
  };
  BitmapFontLoader2.use = function(resource, next) {
    var format2 = autoDetectFormat(resource.data);
    if (!format2) {
      next();
      return;
    }
    var baseUrl = BitmapFontLoader2.getBaseUrl(this, resource);
    var data = format2.parse(resource.data);
    var textures = {};
    var completed = function(page) {
      textures[page.metadata.pageFile] = page.texture;
      if (Object.keys(textures).length === data.page.length) {
        resource.bitmapFont = BitmapFont.install(data, textures, true);
        next();
      }
    };
    for (var i = 0; i < data.page.length; ++i) {
      var pageFile = data.page[i].file;
      var url2 = baseUrl + pageFile;
      var exists = false;
      for (var name in this.resources) {
        var bitmapResource = this.resources[name];
        if (bitmapResource.url === url2) {
          bitmapResource.metadata.pageFile = pageFile;
          if (bitmapResource.texture) {
            completed(bitmapResource);
          } else {
            bitmapResource.onAfterMiddleware.add(completed);
          }
          exists = true;
          break;
        }
      }
      if (!exists) {
        var options = {
          crossOrigin: resource.crossOrigin,
          loadType: LoaderResource.LOAD_TYPE.IMAGE,
          metadata: Object.assign({ pageFile }, resource.metadata.imageMetadata),
          parentResource: resource
        };
        this.add(url2, options, completed);
      }
    }
  };
  BitmapFontLoader2.getBaseUrl = function(loader, resource) {
    var resUrl = !resource.isDataUrl ? BitmapFontLoader2.dirname(resource.url) : "";
    if (resource.isDataUrl) {
      if (resUrl === ".") {
        resUrl = "";
      }
      if (loader.baseUrl && resUrl) {
        if (loader.baseUrl.charAt(loader.baseUrl.length - 1) === "/") {
          resUrl += "/";
        }
      }
    }
    resUrl = resUrl.replace(loader.baseUrl, "");
    if (resUrl && resUrl.charAt(resUrl.length - 1) !== "/") {
      resUrl += "/";
    }
    return resUrl;
  };
  BitmapFontLoader2.dirname = function(url2) {
    var dir = url2.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
    if (dir === url2) {
      return ".";
    } else if (dir === "") {
      return "/";
    }
    return dir;
  };
  BitmapFontLoader2.extension = ExtensionType.Loader;
  return BitmapFontLoader2;
}();
/*!
 * @pixi/filter-alpha - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-alpha is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$7 = function(d2, b2) {
  extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$7(d2, b2);
};
function __extends$7(d2, b2) {
  extendStatics$7(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var fragment$4 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";
(function(_super) {
  __extends$7(AlphaFilter, _super);
  function AlphaFilter(alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    var _this = _super.call(this, defaultVertex$1, fragment$4, { uAlpha: 1 }) || this;
    _this.alpha = alpha;
    return _this;
  }
  Object.defineProperty(AlphaFilter.prototype, "alpha", {
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(value) {
      this.uniforms.uAlpha = value;
    },
    enumerable: false,
    configurable: true
  });
  return AlphaFilter;
})(Filter);
/*!
 * @pixi/filter-blur - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$6 = function(d2, b2) {
  extendStatics$6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$6(d2, b2);
};
function __extends$6(d2, b2) {
  extendStatics$6(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertTemplate = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
function generateBlurVertSource(kernelSize, x2) {
  var halfLength = Math.ceil(kernelSize / 2);
  var vertSource = vertTemplate;
  var blurLoop = "";
  var template;
  if (x2) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  }
  for (var i = 0; i < kernelSize; i++) {
    var blur = template.replace("%index%", i.toString());
    blur = blur.replace("%sampleIndex%", i - (halfLength - 1) + ".0");
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  return vertSource;
}
var GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};
var fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join("\n");
function generateBlurFragSource(kernelSize) {
  var kernel = GAUSSIAN_VALUES[kernelSize];
  var halfLength = kernel.length;
  var fragSource = fragTemplate;
  var blurLoop = "";
  var template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  var value;
  for (var i = 0; i < kernelSize; i++) {
    var blur = template.replace("%index%", i.toString());
    value = i;
    if (i >= halfLength) {
      value = kernelSize - i - 1;
    }
    blur = blur.replace("%value%", kernel[value].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
}
var BlurFilterPass = function(_super) {
  __extends$6(BlurFilterPass2, _super);
  function BlurFilterPass2(horizontal, strength, quality, resolution, kernelSize) {
    if (strength === void 0) {
      strength = 8;
    }
    if (quality === void 0) {
      quality = 4;
    }
    if (resolution === void 0) {
      resolution = settings.FILTER_RESOLUTION;
    }
    if (kernelSize === void 0) {
      kernelSize = 5;
    }
    var _this = this;
    var vertSrc = generateBlurVertSource(kernelSize, horizontal);
    var fragSrc = generateBlurFragSource(kernelSize);
    _this = _super.call(
      this,
      vertSrc,
      fragSrc
    ) || this;
    _this.horizontal = horizontal;
    _this.resolution = resolution;
    _this._quality = 0;
    _this.quality = quality;
    _this.blur = strength;
    return _this;
  }
  BlurFilterPass2.prototype.apply = function(filterManager, input, output, clearMode) {
    if (output) {
      if (this.horizontal) {
        this.uniforms.strength = 1 / output.width * (output.width / input.width);
      } else {
        this.uniforms.strength = 1 / output.height * (output.height / input.height);
      }
    } else {
      if (this.horizontal) {
        this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
      } else {
        this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
      }
    }
    this.uniforms.strength *= this.strength;
    this.uniforms.strength /= this.passes;
    if (this.passes === 1) {
      filterManager.applyFilter(this, input, output, clearMode);
    } else {
      var renderTarget = filterManager.getFilterTexture();
      var renderer2 = filterManager.renderer;
      var flip = input;
      var flop = renderTarget;
      this.state.blend = false;
      filterManager.applyFilter(this, flip, flop, CLEAR_MODES.CLEAR);
      for (var i = 1; i < this.passes - 1; i++) {
        filterManager.bindAndClear(flip, CLEAR_MODES.BLIT);
        this.uniforms.uSampler = flop;
        var temp2 = flop;
        flop = flip;
        flip = temp2;
        renderer2.shader.bind(this);
        renderer2.geometry.draw(5);
      }
      this.state.blend = true;
      filterManager.applyFilter(this, flop, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    }
  };
  Object.defineProperty(BlurFilterPass2.prototype, "blur", {
    get: function() {
      return this.strength;
    },
    set: function(value) {
      this.padding = 1 + Math.abs(value) * 2;
      this.strength = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilterPass2.prototype, "quality", {
    get: function() {
      return this._quality;
    },
    set: function(value) {
      this._quality = value;
      this.passes = value;
    },
    enumerable: false,
    configurable: true
  });
  return BlurFilterPass2;
}(Filter);
(function(_super) {
  __extends$6(BlurFilter, _super);
  function BlurFilter(strength, quality, resolution, kernelSize) {
    if (strength === void 0) {
      strength = 8;
    }
    if (quality === void 0) {
      quality = 4;
    }
    if (resolution === void 0) {
      resolution = settings.FILTER_RESOLUTION;
    }
    if (kernelSize === void 0) {
      kernelSize = 5;
    }
    var _this = _super.call(this) || this;
    _this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
    _this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);
    _this.resolution = resolution;
    _this.quality = quality;
    _this.blur = strength;
    _this.repeatEdgePixels = false;
    return _this;
  }
  BlurFilter.prototype.apply = function(filterManager, input, output, clearMode) {
    var xStrength = Math.abs(this.blurXFilter.strength);
    var yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      var renderTarget = filterManager.getFilterTexture();
      this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES.CLEAR);
      this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    } else if (yStrength) {
      this.blurYFilter.apply(filterManager, input, output, clearMode);
    } else {
      this.blurXFilter.apply(filterManager, input, output, clearMode);
    }
  };
  BlurFilter.prototype.updatePadding = function() {
    if (this._repeatEdgePixels) {
      this.padding = 0;
    } else {
      this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }
  };
  Object.defineProperty(BlurFilter.prototype, "blur", {
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(value) {
      this.blurXFilter.blur = this.blurYFilter.blur = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "quality", {
    get: function() {
      return this.blurXFilter.quality;
    },
    set: function(value) {
      this.blurXFilter.quality = this.blurYFilter.quality = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "blurX", {
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(value) {
      this.blurXFilter.blur = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "blurY", {
    get: function() {
      return this.blurYFilter.blur;
    },
    set: function(value) {
      this.blurYFilter.blur = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "blendMode", {
    get: function() {
      return this.blurYFilter.blendMode;
    },
    set: function(value) {
      this.blurYFilter.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "repeatEdgePixels", {
    get: function() {
      return this._repeatEdgePixels;
    },
    set: function(value) {
      this._repeatEdgePixels = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  return BlurFilter;
})(Filter);
/*!
 * @pixi/filter-color-matrix - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-color-matrix is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$5 = function(d2, b2) {
  extendStatics$5 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$5(d2, b2);
};
function __extends$5(d2, b2) {
  extendStatics$5(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var fragment$3 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";
var ColorMatrixFilter = function(_super) {
  __extends$5(ColorMatrixFilter2, _super);
  function ColorMatrixFilter2() {
    var _this = this;
    var uniforms = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    _this = _super.call(this, defaultFilterVertex, fragment$3, uniforms) || this;
    _this.alpha = 1;
    return _this;
  }
  ColorMatrixFilter2.prototype._loadMatrix = function(matrix, multiply) {
    if (multiply === void 0) {
      multiply = false;
    }
    var newMatrix = matrix;
    if (multiply) {
      this._multiply(newMatrix, this.uniforms.m, matrix);
      newMatrix = this._colorMatrix(newMatrix);
    }
    this.uniforms.m = newMatrix;
  };
  ColorMatrixFilter2.prototype._multiply = function(out, a2, b2) {
    out[0] = a2[0] * b2[0] + a2[1] * b2[5] + a2[2] * b2[10] + a2[3] * b2[15];
    out[1] = a2[0] * b2[1] + a2[1] * b2[6] + a2[2] * b2[11] + a2[3] * b2[16];
    out[2] = a2[0] * b2[2] + a2[1] * b2[7] + a2[2] * b2[12] + a2[3] * b2[17];
    out[3] = a2[0] * b2[3] + a2[1] * b2[8] + a2[2] * b2[13] + a2[3] * b2[18];
    out[4] = a2[0] * b2[4] + a2[1] * b2[9] + a2[2] * b2[14] + a2[3] * b2[19] + a2[4];
    out[5] = a2[5] * b2[0] + a2[6] * b2[5] + a2[7] * b2[10] + a2[8] * b2[15];
    out[6] = a2[5] * b2[1] + a2[6] * b2[6] + a2[7] * b2[11] + a2[8] * b2[16];
    out[7] = a2[5] * b2[2] + a2[6] * b2[7] + a2[7] * b2[12] + a2[8] * b2[17];
    out[8] = a2[5] * b2[3] + a2[6] * b2[8] + a2[7] * b2[13] + a2[8] * b2[18];
    out[9] = a2[5] * b2[4] + a2[6] * b2[9] + a2[7] * b2[14] + a2[8] * b2[19] + a2[9];
    out[10] = a2[10] * b2[0] + a2[11] * b2[5] + a2[12] * b2[10] + a2[13] * b2[15];
    out[11] = a2[10] * b2[1] + a2[11] * b2[6] + a2[12] * b2[11] + a2[13] * b2[16];
    out[12] = a2[10] * b2[2] + a2[11] * b2[7] + a2[12] * b2[12] + a2[13] * b2[17];
    out[13] = a2[10] * b2[3] + a2[11] * b2[8] + a2[12] * b2[13] + a2[13] * b2[18];
    out[14] = a2[10] * b2[4] + a2[11] * b2[9] + a2[12] * b2[14] + a2[13] * b2[19] + a2[14];
    out[15] = a2[15] * b2[0] + a2[16] * b2[5] + a2[17] * b2[10] + a2[18] * b2[15];
    out[16] = a2[15] * b2[1] + a2[16] * b2[6] + a2[17] * b2[11] + a2[18] * b2[16];
    out[17] = a2[15] * b2[2] + a2[16] * b2[7] + a2[17] * b2[12] + a2[18] * b2[17];
    out[18] = a2[15] * b2[3] + a2[16] * b2[8] + a2[17] * b2[13] + a2[18] * b2[18];
    out[19] = a2[15] * b2[4] + a2[16] * b2[9] + a2[17] * b2[14] + a2[18] * b2[19] + a2[19];
    return out;
  };
  ColorMatrixFilter2.prototype._colorMatrix = function(matrix) {
    var m2 = new Float32Array(matrix);
    m2[4] /= 255;
    m2[9] /= 255;
    m2[14] /= 255;
    m2[19] /= 255;
    return m2;
  };
  ColorMatrixFilter2.prototype.brightness = function(b2, multiply) {
    var matrix = [
      b2,
      0,
      0,
      0,
      0,
      0,
      b2,
      0,
      0,
      0,
      0,
      0,
      b2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.tint = function(color, multiply) {
    var r2 = color >> 16 & 255;
    var g2 = color >> 8 & 255;
    var b2 = color & 255;
    var matrix = [
      r2 / 255,
      0,
      0,
      0,
      0,
      0,
      g2 / 255,
      0,
      0,
      0,
      0,
      0,
      b2 / 255,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.greyscale = function(scale, multiply) {
    var matrix = [
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.blackAndWhite = function(multiply) {
    var matrix = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.hue = function(rotation, multiply) {
    rotation = (rotation || 0) / 180 * Math.PI;
    var cosR = Math.cos(rotation);
    var sinR = Math.sin(rotation);
    var sqrt = Math.sqrt;
    var w2 = 1 / 3;
    var sqrW = sqrt(w2);
    var a00 = cosR + (1 - cosR) * w2;
    var a01 = w2 * (1 - cosR) - sqrW * sinR;
    var a02 = w2 * (1 - cosR) + sqrW * sinR;
    var a10 = w2 * (1 - cosR) + sqrW * sinR;
    var a11 = cosR + w2 * (1 - cosR);
    var a12 = w2 * (1 - cosR) - sqrW * sinR;
    var a20 = w2 * (1 - cosR) - sqrW * sinR;
    var a21 = w2 * (1 - cosR) + sqrW * sinR;
    var a22 = cosR + w2 * (1 - cosR);
    var matrix = [
      a00,
      a01,
      a02,
      0,
      0,
      a10,
      a11,
      a12,
      0,
      0,
      a20,
      a21,
      a22,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.contrast = function(amount, multiply) {
    var v2 = (amount || 0) + 1;
    var o2 = -0.5 * (v2 - 1);
    var matrix = [
      v2,
      0,
      0,
      0,
      o2,
      0,
      v2,
      0,
      0,
      o2,
      0,
      0,
      v2,
      0,
      o2,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.saturate = function(amount, multiply) {
    if (amount === void 0) {
      amount = 0;
    }
    var x2 = amount * 2 / 3 + 1;
    var y2 = (x2 - 1) * -0.5;
    var matrix = [
      x2,
      y2,
      y2,
      0,
      0,
      y2,
      x2,
      y2,
      0,
      0,
      y2,
      y2,
      x2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.desaturate = function() {
    this.saturate(-1);
  };
  ColorMatrixFilter2.prototype.negative = function(multiply) {
    var matrix = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.sepia = function(multiply) {
    var matrix = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.technicolor = function(multiply) {
    var matrix = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.polaroid = function(multiply) {
    var matrix = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.toBGR = function(multiply) {
    var matrix = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.kodachrome = function(multiply) {
    var matrix = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.browni = function(multiply) {
    var matrix = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.vintage = function(multiply) {
    var matrix = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.colorTone = function(desaturation, toned, lightColor, darkColor, multiply) {
    desaturation = desaturation || 0.2;
    toned = toned || 0.15;
    lightColor = lightColor || 16770432;
    darkColor = darkColor || 3375104;
    var lR = (lightColor >> 16 & 255) / 255;
    var lG = (lightColor >> 8 & 255) / 255;
    var lB = (lightColor & 255) / 255;
    var dR = (darkColor >> 16 & 255) / 255;
    var dG = (darkColor >> 8 & 255) / 255;
    var dB = (darkColor & 255) / 255;
    var matrix = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      lR,
      lG,
      lB,
      desaturation,
      0,
      dR,
      dG,
      dB,
      toned,
      0,
      lR - dR,
      lG - dG,
      lB - dB,
      0,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.night = function(intensity, multiply) {
    intensity = intensity || 0.1;
    var matrix = [
      intensity * -2,
      -intensity,
      0,
      0,
      0,
      -intensity,
      0,
      intensity,
      0,
      0,
      0,
      intensity,
      intensity * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.predator = function(amount, multiply) {
    var matrix = [
      11.224130630493164 * amount,
      -4.794486999511719 * amount,
      -2.8746118545532227 * amount,
      0 * amount,
      0.40342438220977783 * amount,
      -3.6330697536468506 * amount,
      9.193157196044922 * amount,
      -2.951810836791992 * amount,
      0 * amount,
      -1.316135048866272 * amount,
      -3.2184197902679443 * amount,
      -4.2375030517578125 * amount,
      7.476448059082031 * amount,
      0 * amount,
      0.8044459223747253 * amount,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.lsd = function(multiply) {
    var matrix = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  };
  ColorMatrixFilter2.prototype.reset = function() {
    var matrix = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, false);
  };
  Object.defineProperty(ColorMatrixFilter2.prototype, "matrix", {
    get: function() {
      return this.uniforms.m;
    },
    set: function(value) {
      this.uniforms.m = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorMatrixFilter2.prototype, "alpha", {
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(value) {
      this.uniforms.uAlpha = value;
    },
    enumerable: false,
    configurable: true
  });
  return ColorMatrixFilter2;
}(Filter);
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
/*!
 * @pixi/filter-displacement - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$4 = function(d2, b2) {
  extendStatics$4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$4(d2, b2);
};
function __extends$4(d2, b2) {
  extendStatics$4(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var fragment$2 = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";
var vertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";
(function(_super) {
  __extends$4(DisplacementFilter, _super);
  function DisplacementFilter(sprite, scale) {
    var _this = this;
    var maskMatrix = new Matrix();
    sprite.renderable = false;
    _this = _super.call(this, vertex$1, fragment$2, {
      mapSampler: sprite._texture,
      filterMatrix: maskMatrix,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    }) || this;
    _this.maskSprite = sprite;
    _this.maskMatrix = maskMatrix;
    if (scale === null || scale === void 0) {
      scale = 20;
    }
    _this.scale = new Point(scale, scale);
    return _this;
  }
  DisplacementFilter.prototype.apply = function(filterManager, input, output, clearMode) {
    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
    this.uniforms.scale.x = this.scale.x;
    this.uniforms.scale.y = this.scale.y;
    var wt = this.maskSprite.worldTransform;
    var lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
    var lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
    if (lenX !== 0 && lenY !== 0) {
      this.uniforms.rotation[0] = wt.a / lenX;
      this.uniforms.rotation[1] = wt.b / lenX;
      this.uniforms.rotation[2] = wt.c / lenY;
      this.uniforms.rotation[3] = wt.d / lenY;
    }
    filterManager.applyFilter(this, input, output, clearMode);
  };
  Object.defineProperty(DisplacementFilter.prototype, "map", {
    get: function() {
      return this.uniforms.mapSampler;
    },
    set: function(value) {
      this.uniforms.mapSampler = value;
    },
    enumerable: false,
    configurable: true
  });
  return DisplacementFilter;
})(Filter);
/*!
 * @pixi/filter-fxaa - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-fxaa is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$3 = function(d2, b2) {
  extendStatics$3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$3(d2, b2);
};
function __extends$3(d2, b2) {
  extendStatics$3(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";
var fragment$1 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
(function(_super) {
  __extends$3(FXAAFilter, _super);
  function FXAAFilter() {
    return _super.call(this, vertex, fragment$1) || this;
  }
  return FXAAFilter;
})(Filter);
/*!
 * @pixi/filter-noise - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-noise is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$2 = function(d2, b2) {
  extendStatics$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$2(d2, b2);
};
function __extends$2(d2, b2) {
  extendStatics$2(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var fragment = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";
(function(_super) {
  __extends$2(NoiseFilter, _super);
  function NoiseFilter(noise, seed) {
    if (noise === void 0) {
      noise = 0.5;
    }
    if (seed === void 0) {
      seed = Math.random();
    }
    var _this = _super.call(this, defaultFilterVertex, fragment, {
      uNoise: 0,
      uSeed: 0
    }) || this;
    _this.noise = noise;
    _this.seed = seed;
    return _this;
  }
  Object.defineProperty(NoiseFilter.prototype, "noise", {
    get: function() {
      return this.uniforms.uNoise;
    },
    set: function(value) {
      this.uniforms.uNoise = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NoiseFilter.prototype, "seed", {
    get: function() {
      return this.uniforms.uSeed;
    },
    set: function(value) {
      this.uniforms.uSeed = value;
    },
    enumerable: false,
    configurable: true
  });
  return NoiseFilter;
})(Filter);
/*!
 * @pixi/mixin-cache-as-bitmap - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var _tempMatrix = new Matrix();
DisplayObject.prototype._cacheAsBitmap = false;
DisplayObject.prototype._cacheData = null;
DisplayObject.prototype._cacheAsBitmapResolution = null;
DisplayObject.prototype._cacheAsBitmapMultisample = MSAA_QUALITY.NONE;
var CacheData = function() {
  function CacheData2() {
    this.textureCacheId = null;
    this.originalRender = null;
    this.originalRenderCanvas = null;
    this.originalCalculateBounds = null;
    this.originalGetLocalBounds = null;
    this.originalUpdateTransform = null;
    this.originalDestroy = null;
    this.originalMask = null;
    this.originalFilterArea = null;
    this.originalContainsPoint = null;
    this.sprite = null;
  }
  return CacheData2;
}();
Object.defineProperties(DisplayObject.prototype, {
  cacheAsBitmapResolution: {
    get: function() {
      return this._cacheAsBitmapResolution;
    },
    set: function(resolution) {
      if (resolution === this._cacheAsBitmapResolution) {
        return;
      }
      this._cacheAsBitmapResolution = resolution;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmapMultisample: {
    get: function() {
      return this._cacheAsBitmapMultisample;
    },
    set: function(multisample) {
      if (multisample === this._cacheAsBitmapMultisample) {
        return;
      }
      this._cacheAsBitmapMultisample = multisample;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmap: {
    get: function() {
      return this._cacheAsBitmap;
    },
    set: function(value) {
      if (this._cacheAsBitmap === value) {
        return;
      }
      this._cacheAsBitmap = value;
      var data;
      if (value) {
        if (!this._cacheData) {
          this._cacheData = new CacheData();
        }
        data = this._cacheData;
        data.originalRender = this.render;
        data.originalRenderCanvas = this.renderCanvas;
        data.originalUpdateTransform = this.updateTransform;
        data.originalCalculateBounds = this.calculateBounds;
        data.originalGetLocalBounds = this.getLocalBounds;
        data.originalDestroy = this.destroy;
        data.originalContainsPoint = this.containsPoint;
        data.originalMask = this._mask;
        data.originalFilterArea = this.filterArea;
        this.render = this._renderCached;
        this.renderCanvas = this._renderCachedCanvas;
        this.destroy = this._cacheAsBitmapDestroy;
      } else {
        data = this._cacheData;
        if (data.sprite) {
          this._destroyCachedDisplayObject();
        }
        this.render = data.originalRender;
        this.renderCanvas = data.originalRenderCanvas;
        this.calculateBounds = data.originalCalculateBounds;
        this.getLocalBounds = data.originalGetLocalBounds;
        this.destroy = data.originalDestroy;
        this.updateTransform = data.originalUpdateTransform;
        this.containsPoint = data.originalContainsPoint;
        this._mask = data.originalMask;
        this.filterArea = data.originalFilterArea;
      }
    }
  }
});
DisplayObject.prototype._renderCached = function _renderCached(renderer2) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObject(renderer2);
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._render(renderer2);
};
DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer2) {
  var _a2;
  if (this._cacheData && this._cacheData.sprite) {
    return;
  }
  var cacheAlpha = this.alpha;
  this.alpha = 1;
  renderer2.batch.flush();
  var bounds = this.getLocalBounds(null, true).clone();
  if (this.filters && this.filters.length) {
    var padding = this.filters[0].padding;
    bounds.pad(padding);
  }
  bounds.ceil(settings.RESOLUTION);
  var cachedRenderTexture = renderer2.renderTexture.current;
  var cachedSourceFrame = renderer2.renderTexture.sourceFrame.clone();
  var cachedDestinationFrame = renderer2.renderTexture.destinationFrame.clone();
  var cachedProjectionTransform = renderer2.projection.transform;
  var renderTexture = RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution: this.cacheAsBitmapResolution || renderer2.resolution,
    multisample: (_a2 = this.cacheAsBitmapMultisample) !== null && _a2 !== void 0 ? _a2 : renderer2.multisample
  });
  var textureCacheId = "cacheAsBitmap_" + uid();
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  var m2 = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
  this.render = this._cacheData.originalRender;
  renderer2.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false });
  renderer2.framebuffer.blit();
  renderer2.projection.transform = cachedProjectionTransform;
  renderer2.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
  this.render = this._renderCached;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  var cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.enableTempParent();
    this.updateTransform();
    this.disableTempParent(null);
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer2) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObjectCanvas(renderer2);
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._renderCanvas(renderer2);
};
DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer2) {
  if (this._cacheData && this._cacheData.sprite) {
    return;
  }
  var bounds = this.getLocalBounds(null, true);
  var cacheAlpha = this.alpha;
  this.alpha = 1;
  var cachedRenderTarget = renderer2.context;
  var cachedProjectionTransform = renderer2._projTransform;
  bounds.ceil(settings.RESOLUTION);
  var renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
  var textureCacheId = "cacheAsBitmap_" + uid();
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  var m2 = _tempMatrix;
  this.transform.localTransform.copyTo(m2);
  m2.invert();
  m2.tx -= bounds.x;
  m2.ty -= bounds.y;
  this.renderCanvas = this._cacheData.originalRenderCanvas;
  renderer2.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false });
  renderer2.context = cachedRenderTarget;
  renderer2._projTransform = cachedProjectionTransform;
  this.renderCanvas = this._renderCachedCanvas;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  var cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.parent = renderer2._tempDisplayObjectParent;
    this.updateTransform();
    this.parent = null;
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
  this._bounds.clear();
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite._calculateBounds();
  this._bounds.updateID = this._boundsID;
};
DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
  return this._cacheData.sprite.getLocalBounds(null);
};
DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
  this._cacheData.sprite._texture.destroy(true);
  this._cacheData.sprite = null;
  BaseTexture.removeFromCache(this._cacheData.textureCacheId);
  Texture.removeFromCache(this._cacheData.textureCacheId);
  this._cacheData.textureCacheId = null;
};
DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
  this.cacheAsBitmap = false;
  this.destroy(options);
};
/*!
 * @pixi/mixin-get-child-by-name - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.name = null;
Container.prototype.getChildByName = function getChildByName(name, deep) {
  for (var i = 0, j2 = this.children.length; i < j2; i++) {
    if (this.children[i].name === name) {
      return this.children[i];
    }
  }
  if (deep) {
    for (var i = 0, j2 = this.children.length; i < j2; i++) {
      var child = this.children[i];
      if (!child.getChildByName) {
        continue;
      }
      var target = child.getChildByName(name, true);
      if (target) {
        return target;
      }
    }
  }
  return null;
};
/*!
 * @pixi/mixin-get-global-position - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point, skipUpdate) {
  if (point === void 0) {
    point = new Point();
  }
  if (skipUpdate === void 0) {
    skipUpdate = false;
  }
  if (this.parent) {
    this.parent.toGlobal(this.position, point, skipUpdate);
  } else {
    point.x = this.position.x;
    point.y = this.position.y;
  }
  return point;
};
/*!
 * @pixi/app - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ResizePlugin = function() {
  function ResizePlugin2() {
  }
  ResizePlugin2.init = function(options) {
    var _this = this;
    Object.defineProperty(
      this,
      "resizeTo",
      {
        set: function(dom) {
          globalThis.removeEventListener("resize", this.queueResize);
          this._resizeTo = dom;
          if (dom) {
            globalThis.addEventListener("resize", this.queueResize);
            this.resize();
          }
        },
        get: function() {
          return this._resizeTo;
        }
      }
    );
    this.queueResize = function() {
      if (!_this._resizeTo) {
        return;
      }
      _this.cancelResize();
      _this._resizeId = requestAnimationFrame(function() {
        return _this.resize();
      });
    };
    this.cancelResize = function() {
      if (_this._resizeId) {
        cancelAnimationFrame(_this._resizeId);
        _this._resizeId = null;
      }
    };
    this.resize = function() {
      if (!_this._resizeTo) {
        return;
      }
      _this.cancelResize();
      var width;
      var height;
      if (_this._resizeTo === globalThis.window) {
        width = globalThis.innerWidth;
        height = globalThis.innerHeight;
      } else {
        var _a2 = _this._resizeTo, clientWidth = _a2.clientWidth, clientHeight = _a2.clientHeight;
        width = clientWidth;
        height = clientHeight;
      }
      _this.renderer.resize(width, height);
    };
    this._resizeId = null;
    this._resizeTo = null;
    this.resizeTo = options.resizeTo || null;
  };
  ResizePlugin2.destroy = function() {
    globalThis.removeEventListener("resize", this.queueResize);
    this.cancelResize();
    this.cancelResize = null;
    this.queueResize = null;
    this.resizeTo = null;
    this.resize = null;
  };
  ResizePlugin2.extension = ExtensionType.Application;
  return ResizePlugin2;
}();
var Application = function() {
  function Application2(options) {
    var _this = this;
    this.stage = new Container();
    options = Object.assign({
      forceCanvas: false
    }, options);
    this.renderer = autoDetectRenderer(options);
    Application2._plugins.forEach(function(plugin) {
      plugin.init.call(_this, options);
    });
  }
  Application2.registerPlugin = function(plugin) {
    deprecation("6.5.0", "Application.registerPlugin() is deprecated, use extensions.add()");
    extensions.add({
      type: ExtensionType.Application,
      ref: plugin
    });
  };
  Application2.prototype.render = function() {
    this.renderer.render(this.stage);
  };
  Object.defineProperty(Application2.prototype, "view", {
    get: function() {
      return this.renderer.view;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Application2.prototype, "screen", {
    get: function() {
      return this.renderer.screen;
    },
    enumerable: false,
    configurable: true
  });
  Application2.prototype.destroy = function(removeView, stageOptions) {
    var _this = this;
    var plugins = Application2._plugins.slice(0);
    plugins.reverse();
    plugins.forEach(function(plugin) {
      plugin.destroy.call(_this);
    });
    this.stage.destroy(stageOptions);
    this.stage = null;
    this.renderer.destroy(removeView);
    this.renderer = null;
  };
  Application2._plugins = [];
  return Application2;
}();
extensions.handleByList(ExtensionType.Application, Application._plugins);
extensions.add(ResizePlugin);
/*!
 * @pixi/mesh-extras - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(d2, b2) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$1(d2, b2);
};
function __extends$1(d2, b2) {
  extendStatics$1(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var PlaneGeometry = function(_super) {
  __extends$1(PlaneGeometry2, _super);
  function PlaneGeometry2(width, height, segWidth, segHeight) {
    if (width === void 0) {
      width = 100;
    }
    if (height === void 0) {
      height = 100;
    }
    if (segWidth === void 0) {
      segWidth = 10;
    }
    if (segHeight === void 0) {
      segHeight = 10;
    }
    var _this = _super.call(this) || this;
    _this.segWidth = segWidth;
    _this.segHeight = segHeight;
    _this.width = width;
    _this.height = height;
    _this.build();
    return _this;
  }
  PlaneGeometry2.prototype.build = function() {
    var total = this.segWidth * this.segHeight;
    var verts = [];
    var uvs = [];
    var indices3 = [];
    var segmentsX = this.segWidth - 1;
    var segmentsY = this.segHeight - 1;
    var sizeX = this.width / segmentsX;
    var sizeY = this.height / segmentsY;
    for (var i = 0; i < total; i++) {
      var x2 = i % this.segWidth;
      var y2 = i / this.segWidth | 0;
      verts.push(x2 * sizeX, y2 * sizeY);
      uvs.push(x2 / segmentsX, y2 / segmentsY);
    }
    var totalSub = segmentsX * segmentsY;
    for (var i = 0; i < totalSub; i++) {
      var xpos = i % segmentsX;
      var ypos = i / segmentsX | 0;
      var value = ypos * this.segWidth + xpos;
      var value2 = ypos * this.segWidth + xpos + 1;
      var value3 = (ypos + 1) * this.segWidth + xpos;
      var value4 = (ypos + 1) * this.segWidth + xpos + 1;
      indices3.push(value, value2, value3, value2, value4, value3);
    }
    this.buffers[0].data = new Float32Array(verts);
    this.buffers[1].data = new Float32Array(uvs);
    this.indexBuffer.data = new Uint16Array(indices3);
    this.buffers[0].update();
    this.buffers[1].update();
    this.indexBuffer.update();
  };
  return PlaneGeometry2;
}(MeshGeometry);
var RopeGeometry = function(_super) {
  __extends$1(RopeGeometry2, _super);
  function RopeGeometry2(width, points, textureScale) {
    if (width === void 0) {
      width = 200;
    }
    if (textureScale === void 0) {
      textureScale = 0;
    }
    var _this = _super.call(this, new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6)) || this;
    _this.points = points;
    _this._width = width;
    _this.textureScale = textureScale;
    _this.build();
    return _this;
  }
  Object.defineProperty(RopeGeometry2.prototype, "width", {
    get: function() {
      return this._width;
    },
    enumerable: false,
    configurable: true
  });
  RopeGeometry2.prototype.build = function() {
    var points = this.points;
    if (!points) {
      return;
    }
    var vertexBuffer = this.getBuffer("aVertexPosition");
    var uvBuffer = this.getBuffer("aTextureCoord");
    var indexBuffer = this.getIndex();
    if (points.length < 1) {
      return;
    }
    if (vertexBuffer.data.length / 4 !== points.length) {
      vertexBuffer.data = new Float32Array(points.length * 4);
      uvBuffer.data = new Float32Array(points.length * 4);
      indexBuffer.data = new Uint16Array((points.length - 1) * 6);
    }
    var uvs = uvBuffer.data;
    var indices3 = indexBuffer.data;
    uvs[0] = 0;
    uvs[1] = 0;
    uvs[2] = 0;
    uvs[3] = 1;
    var amount = 0;
    var prev = points[0];
    var textureWidth = this._width * this.textureScale;
    var total = points.length;
    for (var i = 0; i < total; i++) {
      var index = i * 4;
      if (this.textureScale > 0) {
        var dx = prev.x - points[i].x;
        var dy = prev.y - points[i].y;
        var distance = Math.sqrt(dx * dx + dy * dy);
        prev = points[i];
        amount += distance / textureWidth;
      } else {
        amount = i / (total - 1);
      }
      uvs[index] = amount;
      uvs[index + 1] = 0;
      uvs[index + 2] = amount;
      uvs[index + 3] = 1;
    }
    var indexCount = 0;
    for (var i = 0; i < total - 1; i++) {
      var index = i * 2;
      indices3[indexCount++] = index;
      indices3[indexCount++] = index + 1;
      indices3[indexCount++] = index + 2;
      indices3[indexCount++] = index + 2;
      indices3[indexCount++] = index + 1;
      indices3[indexCount++] = index + 3;
    }
    uvBuffer.update();
    indexBuffer.update();
    this.updateVertices();
  };
  RopeGeometry2.prototype.updateVertices = function() {
    var points = this.points;
    if (points.length < 1) {
      return;
    }
    var lastPoint = points[0];
    var nextPoint;
    var perpX = 0;
    var perpY = 0;
    var vertices = this.buffers[0].data;
    var total = points.length;
    for (var i = 0; i < total; i++) {
      var point = points[i];
      var index = i * 4;
      if (i < points.length - 1) {
        nextPoint = points[i + 1];
      } else {
        nextPoint = point;
      }
      perpY = -(nextPoint.x - lastPoint.x);
      perpX = nextPoint.y - lastPoint.y;
      var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
      var num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
      perpX /= perpLength;
      perpY /= perpLength;
      perpX *= num;
      perpY *= num;
      vertices[index] = point.x + perpX;
      vertices[index + 1] = point.y + perpY;
      vertices[index + 2] = point.x - perpX;
      vertices[index + 3] = point.y - perpY;
      lastPoint = point;
    }
    this.buffers[0].update();
  };
  RopeGeometry2.prototype.update = function() {
    if (this.textureScale > 0) {
      this.build();
    } else {
      this.updateVertices();
    }
  };
  return RopeGeometry2;
}(MeshGeometry);
(function(_super) {
  __extends$1(SimpleRope, _super);
  function SimpleRope(texture, points, textureScale) {
    if (textureScale === void 0) {
      textureScale = 0;
    }
    var _this = this;
    var ropeGeometry = new RopeGeometry(texture.height, points, textureScale);
    var meshMaterial = new MeshMaterial(texture);
    if (textureScale > 0) {
      texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;
    }
    _this = _super.call(this, ropeGeometry, meshMaterial) || this;
    _this.autoUpdate = true;
    return _this;
  }
  SimpleRope.prototype._render = function(renderer2) {
    var geometry = this.geometry;
    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
      geometry._width = this.shader.texture.height;
      geometry.update();
    }
    _super.prototype._render.call(this, renderer2);
  };
  return SimpleRope;
})(Mesh);
var SimplePlane = function(_super) {
  __extends$1(SimplePlane2, _super);
  function SimplePlane2(texture, verticesX, verticesY) {
    var _this = this;
    var planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
    var meshMaterial = new MeshMaterial(Texture.WHITE);
    _this = _super.call(this, planeGeometry, meshMaterial) || this;
    _this.texture = texture;
    _this.autoResize = true;
    return _this;
  }
  SimplePlane2.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID;
    var geometry = this.geometry;
    var _a2 = this.shader.texture, width = _a2.width, height = _a2.height;
    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
      geometry.width = this.shader.texture.width;
      geometry.height = this.shader.texture.height;
      geometry.build();
    }
  };
  Object.defineProperty(SimplePlane2.prototype, "texture", {
    get: function() {
      return this.shader.texture;
    },
    set: function(value) {
      if (this.shader.texture === value) {
        return;
      }
      this.shader.texture = value;
      this._textureID = -1;
      if (value.baseTexture.valid) {
        this.textureUpdated();
      } else {
        value.once("update", this.textureUpdated, this);
      }
    },
    enumerable: false,
    configurable: true
  });
  SimplePlane2.prototype._render = function(renderer2) {
    if (this._textureID !== this.shader.texture._updateID) {
      this.textureUpdated();
    }
    _super.prototype._render.call(this, renderer2);
  };
  SimplePlane2.prototype.destroy = function(options) {
    this.shader.texture.off("update", this.textureUpdated, this);
    _super.prototype.destroy.call(this, options);
  };
  return SimplePlane2;
}(Mesh);
(function(_super) {
  __extends$1(SimpleMesh, _super);
  function SimpleMesh(texture, vertices, uvs, indices3, drawMode) {
    if (texture === void 0) {
      texture = Texture.EMPTY;
    }
    var _this = this;
    var geometry = new MeshGeometry(vertices, uvs, indices3);
    geometry.getBuffer("aVertexPosition").static = false;
    var meshMaterial = new MeshMaterial(texture);
    _this = _super.call(this, geometry, meshMaterial, null, drawMode) || this;
    _this.autoUpdate = true;
    return _this;
  }
  Object.defineProperty(SimpleMesh.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(value) {
      this.geometry.getBuffer("aVertexPosition").data = value;
    },
    enumerable: false,
    configurable: true
  });
  SimpleMesh.prototype._render = function(renderer2) {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aVertexPosition").update();
    }
    _super.prototype._render.call(this, renderer2);
  };
  return SimpleMesh;
})(Mesh);
var DEFAULT_BORDER_SIZE = 10;
(function(_super) {
  __extends$1(NineSlicePlane, _super);
  function NineSlicePlane(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
    if (leftWidth === void 0) {
      leftWidth = DEFAULT_BORDER_SIZE;
    }
    if (topHeight === void 0) {
      topHeight = DEFAULT_BORDER_SIZE;
    }
    if (rightWidth === void 0) {
      rightWidth = DEFAULT_BORDER_SIZE;
    }
    if (bottomHeight === void 0) {
      bottomHeight = DEFAULT_BORDER_SIZE;
    }
    var _this = _super.call(this, Texture.WHITE, 4, 4) || this;
    _this._origWidth = texture.orig.width;
    _this._origHeight = texture.orig.height;
    _this._width = _this._origWidth;
    _this._height = _this._origHeight;
    _this._leftWidth = leftWidth;
    _this._rightWidth = rightWidth;
    _this._topHeight = topHeight;
    _this._bottomHeight = bottomHeight;
    _this.texture = texture;
    return _this;
  }
  NineSlicePlane.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID;
    this._refresh();
  };
  Object.defineProperty(NineSlicePlane.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(value) {
      this.geometry.getBuffer("aVertexPosition").data = value;
    },
    enumerable: false,
    configurable: true
  });
  NineSlicePlane.prototype.updateHorizontalVertices = function() {
    var vertices = this.vertices;
    var scale = this._getMinScale();
    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
  };
  NineSlicePlane.prototype.updateVerticalVertices = function() {
    var vertices = this.vertices;
    var scale = this._getMinScale();
    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
  };
  NineSlicePlane.prototype._getMinScale = function() {
    var w2 = this._leftWidth + this._rightWidth;
    var scaleW = this._width > w2 ? 1 : this._width / w2;
    var h2 = this._topHeight + this._bottomHeight;
    var scaleH = this._height > h2 ? 1 : this._height / h2;
    var scale = Math.min(scaleW, scaleH);
    return scale;
  };
  Object.defineProperty(NineSlicePlane.prototype, "width", {
    get: function() {
      return this._width;
    },
    set: function(value) {
      this._width = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "height", {
    get: function() {
      return this._height;
    },
    set: function(value) {
      this._height = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "leftWidth", {
    get: function() {
      return this._leftWidth;
    },
    set: function(value) {
      this._leftWidth = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "rightWidth", {
    get: function() {
      return this._rightWidth;
    },
    set: function(value) {
      this._rightWidth = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "topHeight", {
    get: function() {
      return this._topHeight;
    },
    set: function(value) {
      this._topHeight = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "bottomHeight", {
    get: function() {
      return this._bottomHeight;
    },
    set: function(value) {
      this._bottomHeight = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  NineSlicePlane.prototype._refresh = function() {
    var texture = this.texture;
    var uvs = this.geometry.buffers[1].data;
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    var _uvw = 1 / this._origWidth;
    var _uvh = 1 / this._origHeight;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    this.updateHorizontalVertices();
    this.updateVerticalVertices();
    this.geometry.buffers[0].update();
    this.geometry.buffers[1].update();
  };
  return NineSlicePlane;
})(SimplePlane);
/*!
 * @pixi/sprite-animated - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/sprite-animated is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
(function(_super) {
  __extends(AnimatedSprite, _super);
  function AnimatedSprite(textures, autoUpdate) {
    if (autoUpdate === void 0) {
      autoUpdate = true;
    }
    var _this = _super.call(this, textures[0] instanceof Texture ? textures[0] : textures[0].texture) || this;
    _this._textures = null;
    _this._durations = null;
    _this._autoUpdate = autoUpdate;
    _this._isConnectedToTicker = false;
    _this.animationSpeed = 1;
    _this.loop = true;
    _this.updateAnchor = false;
    _this.onComplete = null;
    _this.onFrameChange = null;
    _this.onLoop = null;
    _this._currentTime = 0;
    _this._playing = false;
    _this._previousFrame = null;
    _this.textures = textures;
    return _this;
  }
  AnimatedSprite.prototype.stop = function() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  };
  AnimatedSprite.prototype.play = function() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
  };
  AnimatedSprite.prototype.gotoAndStop = function(frameNumber) {
    this.stop();
    var previousFrame = this.currentFrame;
    this._currentTime = frameNumber;
    if (previousFrame !== this.currentFrame) {
      this.updateTexture();
    }
  };
  AnimatedSprite.prototype.gotoAndPlay = function(frameNumber) {
    var previousFrame = this.currentFrame;
    this._currentTime = frameNumber;
    if (previousFrame !== this.currentFrame) {
      this.updateTexture();
    }
    this.play();
  };
  AnimatedSprite.prototype.update = function(deltaTime) {
    if (!this._playing) {
      return;
    }
    var elapsed = this.animationSpeed * deltaTime;
    var previousFrame = this.currentFrame;
    if (this._durations !== null) {
      var lag = this._currentTime % 1 * this._durations[this.currentFrame];
      lag += elapsed / 60 * 1e3;
      while (lag < 0) {
        this._currentTime--;
        lag += this._durations[this.currentFrame];
      }
      var sign2 = Math.sign(this.animationSpeed * deltaTime);
      this._currentTime = Math.floor(this._currentTime);
      while (lag >= this._durations[this.currentFrame]) {
        lag -= this._durations[this.currentFrame] * sign2;
        this._currentTime += sign2;
      }
      this._currentTime += lag / this._durations[this.currentFrame];
    } else {
      this._currentTime += elapsed;
    }
    if (this._currentTime < 0 && !this.loop) {
      this.gotoAndStop(0);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (this._currentTime >= this._textures.length && !this.loop) {
      this.gotoAndStop(this._textures.length - 1);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (previousFrame !== this.currentFrame) {
      if (this.loop && this.onLoop) {
        if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
          this.onLoop();
        } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
          this.onLoop();
        }
      }
      this.updateTexture();
    }
  };
  AnimatedSprite.prototype.updateTexture = function() {
    var currentFrame = this.currentFrame;
    if (this._previousFrame === currentFrame) {
      return;
    }
    this._previousFrame = currentFrame;
    this._texture = this._textures[currentFrame];
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    this.uvs = this._texture._uvs.uvsFloat32;
    if (this.updateAnchor) {
      this._anchor.copyFrom(this._texture.defaultAnchor);
    }
    if (this.onFrameChange) {
      this.onFrameChange(this.currentFrame);
    }
  };
  AnimatedSprite.prototype.destroy = function(options) {
    this.stop();
    _super.prototype.destroy.call(this, options);
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
  };
  AnimatedSprite.fromFrames = function(frames) {
    var textures = [];
    for (var i = 0; i < frames.length; ++i) {
      textures.push(Texture.from(frames[i]));
    }
    return new AnimatedSprite(textures);
  };
  AnimatedSprite.fromImages = function(images) {
    var textures = [];
    for (var i = 0; i < images.length; ++i) {
      textures.push(Texture.from(images[i]));
    }
    return new AnimatedSprite(textures);
  };
  Object.defineProperty(AnimatedSprite.prototype, "totalFrames", {
    get: function() {
      return this._textures.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite.prototype, "textures", {
    get: function() {
      return this._textures;
    },
    set: function(value) {
      if (value[0] instanceof Texture) {
        this._textures = value;
        this._durations = null;
      } else {
        this._textures = [];
        this._durations = [];
        for (var i = 0; i < value.length; i++) {
          this._textures.push(value[i].texture);
          this._durations.push(value[i].time);
        }
      }
      this._previousFrame = null;
      this.gotoAndStop(0);
      this.updateTexture();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite.prototype, "currentFrame", {
    get: function() {
      var currentFrame = Math.floor(this._currentTime) % this._textures.length;
      if (currentFrame < 0) {
        currentFrame += this._textures.length;
      }
      return currentFrame;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite.prototype, "playing", {
    get: function() {
      return this._playing;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite.prototype, "autoUpdate", {
    get: function() {
      return this._autoUpdate;
    },
    set: function(value) {
      if (value !== this._autoUpdate) {
        this._autoUpdate = value;
        if (!this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  return AnimatedSprite;
})(Sprite);
/*!
 * pixi.js - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
extensions.add(
  AccessibilityManager,
  Extract,
  InteractionManager,
  ParticleRenderer,
  Prepare,
  BatchRenderer,
  TilingSpriteRenderer,
  BitmapFontLoader,
  CompressedTextureLoader,
  DDSLoader,
  KTXLoader,
  SpritesheetLoader,
  TickerPlugin,
  AppLoaderPlugin
);
var Config = {
  test: 1
};
var webfontloader = { exports: {} };
(function(module) {
  (function() {
    function aa(a2, b2, c) {
      return a2.call.apply(a2.bind, arguments);
    }
    function ba(a2, b2, c) {
      if (!a2)
        throw Error();
      if (2 < arguments.length) {
        var d2 = Array.prototype.slice.call(arguments, 2);
        return function() {
          var c2 = Array.prototype.slice.call(arguments);
          Array.prototype.unshift.apply(c2, d2);
          return a2.apply(b2, c2);
        };
      }
      return function() {
        return a2.apply(b2, arguments);
      };
    }
    function p2(a2, b2, c) {
      p2 = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? aa : ba;
      return p2.apply(null, arguments);
    }
    var q2 = Date.now || function() {
      return +new Date();
    };
    function ca(a2, b2) {
      this.a = a2;
      this.o = b2 || a2;
      this.c = this.o.document;
    }
    var da = !!window.FontFace;
    function t2(a2, b2, c, d2) {
      b2 = a2.c.createElement(b2);
      if (c)
        for (var e2 in c)
          c.hasOwnProperty(e2) && ("style" == e2 ? b2.style.cssText = c[e2] : b2.setAttribute(e2, c[e2]));
      d2 && b2.appendChild(a2.c.createTextNode(d2));
      return b2;
    }
    function u2(a2, b2, c) {
      a2 = a2.c.getElementsByTagName(b2)[0];
      a2 || (a2 = document.documentElement);
      a2.insertBefore(c, a2.lastChild);
    }
    function v2(a2) {
      a2.parentNode && a2.parentNode.removeChild(a2);
    }
    function w2(a2, b2, c) {
      b2 = b2 || [];
      c = c || [];
      for (var d2 = a2.className.split(/\s+/), e2 = 0; e2 < b2.length; e2 += 1) {
        for (var f2 = false, g2 = 0; g2 < d2.length; g2 += 1)
          if (b2[e2] === d2[g2]) {
            f2 = true;
            break;
          }
        f2 || d2.push(b2[e2]);
      }
      b2 = [];
      for (e2 = 0; e2 < d2.length; e2 += 1) {
        f2 = false;
        for (g2 = 0; g2 < c.length; g2 += 1)
          if (d2[e2] === c[g2]) {
            f2 = true;
            break;
          }
        f2 || b2.push(d2[e2]);
      }
      a2.className = b2.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "");
    }
    function y2(a2, b2) {
      for (var c = a2.className.split(/\s+/), d2 = 0, e2 = c.length; d2 < e2; d2++)
        if (c[d2] == b2)
          return true;
      return false;
    }
    function ea(a2) {
      return a2.o.location.hostname || a2.a.location.hostname;
    }
    function z2(a2, b2, c) {
      function d2() {
        m2 && e2 && f2 && (m2(g2), m2 = null);
      }
      b2 = t2(a2, "link", { rel: "stylesheet", href: b2, media: "all" });
      var e2 = false, f2 = true, g2 = null, m2 = c || null;
      da ? (b2.onload = function() {
        e2 = true;
        d2();
      }, b2.onerror = function() {
        e2 = true;
        g2 = Error("Stylesheet failed to load");
        d2();
      }) : setTimeout(function() {
        e2 = true;
        d2();
      }, 0);
      u2(a2, "head", b2);
    }
    function A(a2, b2, c, d2) {
      var e2 = a2.c.getElementsByTagName("head")[0];
      if (e2) {
        var f2 = t2(a2, "script", { src: b2 }), g2 = false;
        f2.onload = f2.onreadystatechange = function() {
          g2 || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (g2 = true, c && c(null), f2.onload = f2.onreadystatechange = null, "HEAD" == f2.parentNode.tagName && e2.removeChild(f2));
        };
        e2.appendChild(f2);
        setTimeout(function() {
          g2 || (g2 = true, c && c(Error("Script load timeout")));
        }, d2 || 5e3);
        return f2;
      }
      return null;
    }
    function B() {
      this.a = 0;
      this.c = null;
    }
    function C(a2) {
      a2.a++;
      return function() {
        a2.a--;
        D(a2);
      };
    }
    function E(a2, b2) {
      a2.c = b2;
      D(a2);
    }
    function D(a2) {
      0 == a2.a && a2.c && (a2.c(), a2.c = null);
    }
    function F(a2) {
      this.a = a2 || "-";
    }
    F.prototype.c = function(a2) {
      for (var b2 = [], c = 0; c < arguments.length; c++)
        b2.push(arguments[c].replace(/[\W_]+/g, "").toLowerCase());
      return b2.join(this.a);
    };
    function G(a2, b2) {
      this.c = a2;
      this.f = 4;
      this.a = "n";
      var c = (b2 || "n4").match(/^([nio])([1-9])$/i);
      c && (this.a = c[1], this.f = parseInt(c[2], 10));
    }
    function fa(a2) {
      return H(a2) + " " + (a2.f + "00") + " 300px " + I(a2.c);
    }
    function I(a2) {
      var b2 = [];
      a2 = a2.split(/,\s*/);
      for (var c = 0; c < a2.length; c++) {
        var d2 = a2[c].replace(/['"]/g, "");
        -1 != d2.indexOf(" ") || /^\d/.test(d2) ? b2.push("'" + d2 + "'") : b2.push(d2);
      }
      return b2.join(",");
    }
    function J(a2) {
      return a2.a + a2.f;
    }
    function H(a2) {
      var b2 = "normal";
      "o" === a2.a ? b2 = "oblique" : "i" === a2.a && (b2 = "italic");
      return b2;
    }
    function ga(a2) {
      var b2 = 4, c = "n", d2 = null;
      a2 && ((d2 = a2.match(/(normal|oblique|italic)/i)) && d2[1] && (c = d2[1].substr(0, 1).toLowerCase()), (d2 = a2.match(/([1-9]00|normal|bold)/i)) && d2[1] && (/bold/i.test(d2[1]) ? b2 = 7 : /[1-9]00/.test(d2[1]) && (b2 = parseInt(d2[1].substr(0, 1), 10))));
      return c + b2;
    }
    function ha(a2, b2) {
      this.c = a2;
      this.f = a2.o.document.documentElement;
      this.h = b2;
      this.a = new F("-");
      this.j = false !== b2.events;
      this.g = false !== b2.classes;
    }
    function ia(a2) {
      a2.g && w2(a2.f, [a2.a.c("wf", "loading")]);
      K(a2, "loading");
    }
    function L(a2) {
      if (a2.g) {
        var b2 = y2(a2.f, a2.a.c("wf", "active")), c = [], d2 = [a2.a.c("wf", "loading")];
        b2 || c.push(a2.a.c("wf", "inactive"));
        w2(a2.f, c, d2);
      }
      K(a2, "inactive");
    }
    function K(a2, b2, c) {
      if (a2.j && a2.h[b2])
        if (c)
          a2.h[b2](c.c, J(c));
        else
          a2.h[b2]();
    }
    function ja() {
      this.c = {};
    }
    function ka(a2, b2, c) {
      var d2 = [], e2;
      for (e2 in b2)
        if (b2.hasOwnProperty(e2)) {
          var f2 = a2.c[e2];
          f2 && d2.push(f2(b2[e2], c));
        }
      return d2;
    }
    function M(a2, b2) {
      this.c = a2;
      this.f = b2;
      this.a = t2(this.c, "span", { "aria-hidden": "true" }, this.f);
    }
    function N(a2) {
      u2(a2.c, "body", a2.a);
    }
    function O(a2) {
      return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + I(a2.c) + ";" + ("font-style:" + H(a2) + ";font-weight:" + (a2.f + "00") + ";");
    }
    function P(a2, b2, c, d2, e2, f2) {
      this.g = a2;
      this.j = b2;
      this.a = d2;
      this.c = c;
      this.f = e2 || 3e3;
      this.h = f2 || void 0;
    }
    P.prototype.start = function() {
      var a2 = this.c.o.document, b2 = this, c = q2(), d2 = new Promise(function(d3, e3) {
        function f3() {
          q2() - c >= b2.f ? e3() : a2.fonts.load(fa(b2.a), b2.h).then(function(a3) {
            1 <= a3.length ? d3() : setTimeout(f3, 25);
          }, function() {
            e3();
          });
        }
        f3();
      }), e2 = null, f2 = new Promise(function(a3, d3) {
        e2 = setTimeout(d3, b2.f);
      });
      Promise.race([f2, d2]).then(function() {
        e2 && (clearTimeout(e2), e2 = null);
        b2.g(b2.a);
      }, function() {
        b2.j(b2.a);
      });
    };
    function Q(a2, b2, c, d2, e2, f2, g2) {
      this.v = a2;
      this.B = b2;
      this.c = c;
      this.a = d2;
      this.s = g2 || "BESbswy";
      this.f = {};
      this.w = e2 || 3e3;
      this.u = f2 || null;
      this.m = this.j = this.h = this.g = null;
      this.g = new M(this.c, this.s);
      this.h = new M(this.c, this.s);
      this.j = new M(this.c, this.s);
      this.m = new M(this.c, this.s);
      a2 = new G(this.a.c + ",serif", J(this.a));
      a2 = O(a2);
      this.g.a.style.cssText = a2;
      a2 = new G(this.a.c + ",sans-serif", J(this.a));
      a2 = O(a2);
      this.h.a.style.cssText = a2;
      a2 = new G("serif", J(this.a));
      a2 = O(a2);
      this.j.a.style.cssText = a2;
      a2 = new G("sans-serif", J(this.a));
      a2 = O(a2);
      this.m.a.style.cssText = a2;
      N(this.g);
      N(this.h);
      N(this.j);
      N(this.m);
    }
    var R2 = { D: "serif", C: "sans-serif" }, S = null;
    function T() {
      if (null === S) {
        var a2 = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
        S = !!a2 && (536 > parseInt(a2[1], 10) || 536 === parseInt(a2[1], 10) && 11 >= parseInt(a2[2], 10));
      }
      return S;
    }
    Q.prototype.start = function() {
      this.f.serif = this.j.a.offsetWidth;
      this.f["sans-serif"] = this.m.a.offsetWidth;
      this.A = q2();
      U(this);
    };
    function la(a2, b2, c) {
      for (var d2 in R2)
        if (R2.hasOwnProperty(d2) && b2 === a2.f[R2[d2]] && c === a2.f[R2[d2]])
          return true;
      return false;
    }
    function U(a2) {
      var b2 = a2.g.a.offsetWidth, c = a2.h.a.offsetWidth, d2;
      (d2 = b2 === a2.f.serif && c === a2.f["sans-serif"]) || (d2 = T() && la(a2, b2, c));
      d2 ? q2() - a2.A >= a2.w ? T() && la(a2, b2, c) && (null === a2.u || a2.u.hasOwnProperty(a2.a.c)) ? V(a2, a2.v) : V(a2, a2.B) : ma(a2) : V(a2, a2.v);
    }
    function ma(a2) {
      setTimeout(p2(function() {
        U(this);
      }, a2), 50);
    }
    function V(a2, b2) {
      setTimeout(p2(function() {
        v2(this.g.a);
        v2(this.h.a);
        v2(this.j.a);
        v2(this.m.a);
        b2(this.a);
      }, a2), 0);
    }
    function W(a2, b2, c) {
      this.c = a2;
      this.a = b2;
      this.f = 0;
      this.m = this.j = false;
      this.s = c;
    }
    var X = null;
    W.prototype.g = function(a2) {
      var b2 = this.a;
      b2.g && w2(b2.f, [b2.a.c("wf", a2.c, J(a2).toString(), "active")], [b2.a.c("wf", a2.c, J(a2).toString(), "loading"), b2.a.c("wf", a2.c, J(a2).toString(), "inactive")]);
      K(b2, "fontactive", a2);
      this.m = true;
      na(this);
    };
    W.prototype.h = function(a2) {
      var b2 = this.a;
      if (b2.g) {
        var c = y2(b2.f, b2.a.c("wf", a2.c, J(a2).toString(), "active")), d2 = [], e2 = [b2.a.c("wf", a2.c, J(a2).toString(), "loading")];
        c || d2.push(b2.a.c("wf", a2.c, J(a2).toString(), "inactive"));
        w2(b2.f, d2, e2);
      }
      K(b2, "fontinactive", a2);
      na(this);
    };
    function na(a2) {
      0 == --a2.f && a2.j && (a2.m ? (a2 = a2.a, a2.g && w2(a2.f, [a2.a.c("wf", "active")], [a2.a.c("wf", "loading"), a2.a.c("wf", "inactive")]), K(a2, "active")) : L(a2.a));
    }
    function oa(a2) {
      this.j = a2;
      this.a = new ja();
      this.h = 0;
      this.f = this.g = true;
    }
    oa.prototype.load = function(a2) {
      this.c = new ca(this.j, a2.context || this.j);
      this.g = false !== a2.events;
      this.f = false !== a2.classes;
      pa(this, new ha(this.c, a2), a2);
    };
    function qa(a2, b2, c, d2, e2) {
      var f2 = 0 == --a2.h;
      (a2.f || a2.g) && setTimeout(function() {
        var a3 = e2 || null, m2 = d2 || null || {};
        if (0 === c.length && f2)
          L(b2.a);
        else {
          b2.f += c.length;
          f2 && (b2.j = f2);
          var h2, l2 = [];
          for (h2 = 0; h2 < c.length; h2++) {
            var k2 = c[h2], n2 = m2[k2.c], r2 = b2.a, x2 = k2;
            r2.g && w2(r2.f, [r2.a.c("wf", x2.c, J(x2).toString(), "loading")]);
            K(r2, "fontloading", x2);
            r2 = null;
            if (null === X)
              if (window.FontFace) {
                var x2 = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent), xa = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                X = x2 ? 42 < parseInt(x2[1], 10) : xa ? false : true;
              } else
                X = false;
            X ? r2 = new P(p2(b2.g, b2), p2(b2.h, b2), b2.c, k2, b2.s, n2) : r2 = new Q(p2(b2.g, b2), p2(b2.h, b2), b2.c, k2, b2.s, a3, n2);
            l2.push(r2);
          }
          for (h2 = 0; h2 < l2.length; h2++)
            l2[h2].start();
        }
      }, 0);
    }
    function pa(a2, b2, c) {
      var d2 = [], e2 = c.timeout;
      ia(b2);
      var d2 = ka(a2.a, c, a2.c), f2 = new W(a2.c, b2, e2);
      a2.h = d2.length;
      b2 = 0;
      for (c = d2.length; b2 < c; b2++)
        d2[b2].load(function(b3, d3, c2) {
          qa(a2, f2, b3, d3, c2);
        });
    }
    function ra(a2, b2) {
      this.c = a2;
      this.a = b2;
    }
    ra.prototype.load = function(a2) {
      function b2() {
        if (f2["__mti_fntLst" + d2]) {
          var c2 = f2["__mti_fntLst" + d2](), e3 = [], h2;
          if (c2)
            for (var l2 = 0; l2 < c2.length; l2++) {
              var k2 = c2[l2].fontfamily;
              void 0 != c2[l2].fontStyle && void 0 != c2[l2].fontWeight ? (h2 = c2[l2].fontStyle + c2[l2].fontWeight, e3.push(new G(k2, h2))) : e3.push(new G(k2));
            }
          a2(e3);
        } else
          setTimeout(function() {
            b2();
          }, 50);
      }
      var c = this, d2 = c.a.projectId, e2 = c.a.version;
      if (d2) {
        var f2 = c.c.o;
        A(this.c, (c.a.api || "https://fast.fonts.net/jsapi") + "/" + d2 + ".js" + (e2 ? "?v=" + e2 : ""), function(e3) {
          e3 ? a2([]) : (f2["__MonotypeConfiguration__" + d2] = function() {
            return c.a;
          }, b2());
        }).id = "__MonotypeAPIScript__" + d2;
      } else
        a2([]);
    };
    function sa(a2, b2) {
      this.c = a2;
      this.a = b2;
    }
    sa.prototype.load = function(a2) {
      var b2, c, d2 = this.a.urls || [], e2 = this.a.families || [], f2 = this.a.testStrings || {}, g2 = new B();
      b2 = 0;
      for (c = d2.length; b2 < c; b2++)
        z2(this.c, d2[b2], C(g2));
      var m2 = [];
      b2 = 0;
      for (c = e2.length; b2 < c; b2++)
        if (d2 = e2[b2].split(":"), d2[1])
          for (var h2 = d2[1].split(","), l2 = 0; l2 < h2.length; l2 += 1)
            m2.push(new G(d2[0], h2[l2]));
        else
          m2.push(new G(d2[0]));
      E(g2, function() {
        a2(m2, f2);
      });
    };
    function ta(a2, b2) {
      a2 ? this.c = a2 : this.c = ua;
      this.a = [];
      this.f = [];
      this.g = b2 || "";
    }
    var ua = "https://fonts.googleapis.com/css";
    function va(a2, b2) {
      for (var c = b2.length, d2 = 0; d2 < c; d2++) {
        var e2 = b2[d2].split(":");
        3 == e2.length && a2.f.push(e2.pop());
        var f2 = "";
        2 == e2.length && "" != e2[1] && (f2 = ":");
        a2.a.push(e2.join(f2));
      }
    }
    function wa(a2) {
      if (0 == a2.a.length)
        throw Error("No fonts to load!");
      if (-1 != a2.c.indexOf("kit="))
        return a2.c;
      for (var b2 = a2.a.length, c = [], d2 = 0; d2 < b2; d2++)
        c.push(a2.a[d2].replace(/ /g, "+"));
      b2 = a2.c + "?family=" + c.join("%7C");
      0 < a2.f.length && (b2 += "&subset=" + a2.f.join(","));
      0 < a2.g.length && (b2 += "&text=" + encodeURIComponent(a2.g));
      return b2;
    }
    function ya(a2) {
      this.f = a2;
      this.a = [];
      this.c = {};
    }
    var za = { latin: "BESbswy", "latin-ext": "\xE7\xF6\xFC\u011F\u015F", cyrillic: "\u0439\u044F\u0416", greek: "\u03B1\u03B2\u03A3", khmer: "\u1780\u1781\u1782", Hanuman: "\u1780\u1781\u1782" }, Aa = { thin: "1", extralight: "2", "extra-light": "2", ultralight: "2", "ultra-light": "2", light: "3", regular: "4", book: "4", medium: "5", "semi-bold": "6", semibold: "6", "demi-bold": "6", demibold: "6", bold: "7", "extra-bold": "8", extrabold: "8", "ultra-bold": "8", ultrabold: "8", black: "9", heavy: "9", l: "3", r: "4", b: "7" }, Ba = { i: "i", italic: "i", n: "n", normal: "n" }, Ca = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
    function Da(a2) {
      for (var b2 = a2.f.length, c = 0; c < b2; c++) {
        var d2 = a2.f[c].split(":"), e2 = d2[0].replace(/\+/g, " "), f2 = ["n4"];
        if (2 <= d2.length) {
          var g2;
          var m2 = d2[1];
          g2 = [];
          if (m2)
            for (var m2 = m2.split(","), h2 = m2.length, l2 = 0; l2 < h2; l2++) {
              var k2;
              k2 = m2[l2];
              if (k2.match(/^[\w-]+$/)) {
                var n2 = Ca.exec(k2.toLowerCase());
                if (null == n2)
                  k2 = "";
                else {
                  k2 = n2[2];
                  k2 = null == k2 || "" == k2 ? "n" : Ba[k2];
                  n2 = n2[1];
                  if (null == n2 || "" == n2)
                    n2 = "4";
                  else
                    var r2 = Aa[n2], n2 = r2 ? r2 : isNaN(n2) ? "4" : n2.substr(0, 1);
                  k2 = [k2, n2].join("");
                }
              } else
                k2 = "";
              k2 && g2.push(k2);
            }
          0 < g2.length && (f2 = g2);
          3 == d2.length && (d2 = d2[2], g2 = [], d2 = d2 ? d2.split(",") : g2, 0 < d2.length && (d2 = za[d2[0]]) && (a2.c[e2] = d2));
        }
        a2.c[e2] || (d2 = za[e2]) && (a2.c[e2] = d2);
        for (d2 = 0; d2 < f2.length; d2 += 1)
          a2.a.push(new G(e2, f2[d2]));
      }
    }
    function Ea(a2, b2) {
      this.c = a2;
      this.a = b2;
    }
    var Fa = { Arimo: true, Cousine: true, Tinos: true };
    Ea.prototype.load = function(a2) {
      var b2 = new B(), c = this.c, d2 = new ta(this.a.api, this.a.text), e2 = this.a.families;
      va(d2, e2);
      var f2 = new ya(e2);
      Da(f2);
      z2(c, wa(d2), C(b2));
      E(b2, function() {
        a2(f2.a, f2.c, Fa);
      });
    };
    function Ga(a2, b2) {
      this.c = a2;
      this.a = b2;
    }
    Ga.prototype.load = function(a2) {
      var b2 = this.a.id, c = this.c.o;
      b2 ? A(this.c, (this.a.api || "https://use.typekit.net") + "/" + b2 + ".js", function(b3) {
        if (b3)
          a2([]);
        else if (c.Typekit && c.Typekit.config && c.Typekit.config.fn) {
          b3 = c.Typekit.config.fn;
          for (var e2 = [], f2 = 0; f2 < b3.length; f2 += 2)
            for (var g2 = b3[f2], m2 = b3[f2 + 1], h2 = 0; h2 < m2.length; h2++)
              e2.push(new G(g2, m2[h2]));
          try {
            c.Typekit.load({ events: false, classes: false, async: true });
          } catch (l2) {
          }
          a2(e2);
        }
      }, 2e3) : a2([]);
    };
    function Ha(a2, b2) {
      this.c = a2;
      this.f = b2;
      this.a = [];
    }
    Ha.prototype.load = function(a2) {
      var b2 = this.f.id, c = this.c.o, d2 = this;
      b2 ? (c.__webfontfontdeckmodule__ || (c.__webfontfontdeckmodule__ = {}), c.__webfontfontdeckmodule__[b2] = function(b3, c2) {
        for (var g2 = 0, m2 = c2.fonts.length; g2 < m2; ++g2) {
          var h2 = c2.fonts[g2];
          d2.a.push(new G(h2.name, ga("font-weight:" + h2.weight + ";font-style:" + h2.style)));
        }
        a2(d2.a);
      }, A(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + ea(this.c) + "/" + b2 + ".js", function(b3) {
        b3 && a2([]);
      })) : a2([]);
    };
    var Y = new oa(window);
    Y.a.c.custom = function(a2, b2) {
      return new sa(b2, a2);
    };
    Y.a.c.fontdeck = function(a2, b2) {
      return new Ha(b2, a2);
    };
    Y.a.c.monotype = function(a2, b2) {
      return new ra(b2, a2);
    };
    Y.a.c.typekit = function(a2, b2) {
      return new Ga(b2, a2);
    };
    Y.a.c.google = function(a2, b2) {
      return new Ea(b2, a2);
    };
    var Z = { load: p2(Y.load, Y) };
    module.exports ? module.exports = Z : (window.WebFont = Z, window.WebFontConfig && Y.load(window.WebFontConfig));
  })();
})(webfontloader);
var WebFont = webfontloader.exports;
var toStr$7 = Object.prototype.toString;
var isArguments$2 = function isArguments(value) {
  var str = toStr$7.call(value);
  var isArgs2 = str === "[object Arguments]";
  if (!isArgs2) {
    isArgs2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$7.call(value.callee) === "[object Function]";
  }
  return isArgs2;
};
var keysShim$1;
if (!Object.keys) {
  var has$1 = Object.prototype.hasOwnProperty;
  var toStr$6 = Object.prototype.toString;
  var isArgs$1 = isArguments$2;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
  var hasProtoEnumBug = isEnumerable.call(function() {
  }, "prototype");
  var dontEnums = [
    "toString",
    "toLocaleString",
    "valueOf",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "constructor"
  ];
  var equalsConstructorPrototype = function(o2) {
    var ctor = o2.constructor;
    return ctor && ctor.prototype === o2;
  };
  var excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };
  var hasAutomationEqualityBug = function() {
    if (typeof window === "undefined") {
      return false;
    }
    for (var k2 in window) {
      try {
        if (!excludedKeys["$" + k2] && has$1.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
          try {
            equalsConstructorPrototype(window[k2]);
          } catch (e2) {
            return true;
          }
        }
      } catch (e2) {
        return true;
      }
    }
    return false;
  }();
  var equalsConstructorPrototypeIfNotBuggy = function(o2) {
    if (typeof window === "undefined" || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o2);
    }
    try {
      return equalsConstructorPrototype(o2);
    } catch (e2) {
      return false;
    }
  };
  keysShim$1 = function keys3(object) {
    var isObject2 = object !== null && typeof object === "object";
    var isFunction2 = toStr$6.call(object) === "[object Function]";
    var isArguments5 = isArgs$1(object);
    var isString3 = isObject2 && toStr$6.call(object) === "[object String]";
    var theKeys = [];
    if (!isObject2 && !isFunction2 && !isArguments5) {
      throw new TypeError("Object.keys called on a non-object");
    }
    var skipProto = hasProtoEnumBug && isFunction2;
    if (isString3 && object.length > 0 && !has$1.call(object, 0)) {
      for (var i = 0; i < object.length; ++i) {
        theKeys.push(String(i));
      }
    }
    if (isArguments5 && object.length > 0) {
      for (var j2 = 0; j2 < object.length; ++j2) {
        theKeys.push(String(j2));
      }
    } else {
      for (var name in object) {
        if (!(skipProto && name === "prototype") && has$1.call(object, name)) {
          theKeys.push(String(name));
        }
      }
    }
    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
      for (var k2 = 0; k2 < dontEnums.length; ++k2) {
        if (!(skipConstructor && dontEnums[k2] === "constructor") && has$1.call(object, dontEnums[k2])) {
          theKeys.push(dontEnums[k2]);
        }
      }
    }
    return theKeys;
  };
}
var implementation$9 = keysShim$1;
var slice = Array.prototype.slice;
var isArgs = isArguments$2;
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o2) {
  return origKeys(o2);
} : implementation$9;
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys3(object) {
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
var objectKeys = keysShim;
var keys2 = objectKeys;
var hasSymbols$3 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr$5 = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty2 = defineDataProperty$1;
var isFunction$2 = function(fn) {
  return typeof fn === "function" && toStr$5.call(fn) === "[object Function]";
};
var supportsDescriptors = hasPropertyDescriptors_1();
var defineProperty = function(object, name, value, predicate) {
  if (name in object) {
    if (predicate === true) {
      if (object[name] === value) {
        return;
      }
    } else if (!isFunction$2(predicate) || !predicate()) {
      return;
    }
  }
  if (supportsDescriptors) {
    defineDataProperty2(object, name, value, true);
  } else {
    defineDataProperty2(object, name, value);
  }
};
var defineProperties = function(object, map4) {
  var predicates2 = arguments.length > 2 ? arguments[2] : {};
  var props = keys2(map4);
  if (hasSymbols$3) {
    props = concat.call(props, Object.getOwnPropertySymbols(map4));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty(object, props[i], map4[props[i]], predicates2[props[i]]);
  }
};
defineProperties.supportsDescriptors = !!supportsDescriptors;
var defineProperties_1 = defineProperties;
var requirePromise$4 = function requirePromise() {
  if (typeof Promise !== "function") {
    throw new TypeError("`Promise.allSettled` requires a global `Promise` be available.");
  }
};
var GetIntrinsic$r = getIntrinsic;
var callBind$3 = callBind$5.exports;
var $resolve = GetIntrinsic$r("%Promise.resolve%", true);
var $PromiseResolve = $resolve && callBind$3($resolve);
var PromiseResolve$1 = function PromiseResolve(C, x2) {
  if (!$PromiseResolve) {
    throw new SyntaxError("This environment does not support Promises.");
  }
  return $PromiseResolve(C, x2);
};
var Type$h = function Type(x2) {
  if (x2 === null) {
    return "Null";
  }
  if (typeof x2 === "undefined") {
    return "Undefined";
  }
  if (typeof x2 === "function" || typeof x2 === "object") {
    return "Object";
  }
  if (typeof x2 === "number") {
    return "Number";
  }
  if (typeof x2 === "boolean") {
    return "Boolean";
  }
  if (typeof x2 === "string") {
    return "String";
  }
};
var ES5Type = Type$h;
var Type$g = function Type2(x2) {
  if (typeof x2 === "symbol") {
    return "Symbol";
  }
  if (typeof x2 === "bigint") {
    return "BigInt";
  }
  return ES5Type(x2);
};
var esGetIterator = { exports: {} };
var hasSymbols$2 = shams$1;
var shams = function hasToStringTagShams() {
  return hasSymbols$2() && !!Symbol.toStringTag;
};
var hasToStringTag$4 = shams();
var callBound$9 = callBound$b;
var $toString$1 = callBound$9("Object.prototype.toString");
var isStandardArguments = function isArguments2(value) {
  if (hasToStringTag$4 && value && typeof value === "object" && Symbol.toStringTag in value) {
    return false;
  }
  return $toString$1(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments3(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString$1(value) !== "[object Array]" && $toString$1(value.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
var hasOwn$6 = hasown;
var channel = sideChannel();
var $TypeError$l = type;
var SLOT$1 = {
  assert: function(O, slot) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new $TypeError$l("`O` is not an object");
    }
    if (typeof slot !== "string") {
      throw new $TypeError$l("`slot` must be a string");
    }
    channel.assert(O);
    if (!SLOT$1.has(O, slot)) {
      throw new $TypeError$l("`" + slot + "` is not present on `O`");
    }
  },
  get: function(O, slot) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new $TypeError$l("`O` is not an object");
    }
    if (typeof slot !== "string") {
      throw new $TypeError$l("`slot` must be a string");
    }
    var slots = channel.get(O);
    return slots && slots["$" + slot];
  },
  has: function(O, slot) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new $TypeError$l("`O` is not an object");
    }
    if (typeof slot !== "string") {
      throw new $TypeError$l("`slot` must be a string");
    }
    var slots = channel.get(O);
    return !!slots && hasOwn$6(slots, "$" + slot);
  },
  set: function(O, slot, V) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new $TypeError$l("`O` is not an object");
    }
    if (typeof slot !== "string") {
      throw new $TypeError$l("`slot` must be a string");
    }
    var slots = channel.get(O);
    if (!slots) {
      slots = {};
      channel.set(O, slots);
    }
    slots["$" + slot] = V;
  }
};
if (Object.freeze) {
  Object.freeze(SLOT$1);
}
var internalSlot = SLOT$1;
var SLOT = internalSlot;
var $SyntaxError$3 = SyntaxError;
var $StopIteration = typeof StopIteration === "object" ? StopIteration : null;
var stopIterationIterator = function getStopIterationIterator(origIterator) {
  if (!$StopIteration) {
    throw new $SyntaxError$3("this environment lacks StopIteration");
  }
  SLOT.set(origIterator, "[[Done]]", false);
  var siIterator = {
    next: function next() {
      var iterator = SLOT.get(this, "[[Iterator]]");
      var done = SLOT.get(iterator, "[[Done]]");
      try {
        return {
          done,
          value: done ? void 0 : iterator.next()
        };
      } catch (e2) {
        SLOT.set(iterator, "[[Done]]", true);
        if (e2 !== $StopIteration) {
          throw e2;
        }
        return {
          done: true,
          value: void 0
        };
      }
    }
  };
  SLOT.set(siIterator, "[[Iterator]]", origIterator);
  return siIterator;
};
var toString$2 = {}.toString;
var isarray = Array.isArray || function(arr) {
  return toString$2.call(arr) == "[object Array]";
};
var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject2(value) {
  try {
    strValue.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr$4 = Object.prototype.toString;
var strClass = "[object String]";
var hasToStringTag$3 = shams();
var isString$2 = function isString(value) {
  if (typeof value === "string") {
    return true;
  }
  if (typeof value !== "object") {
    return false;
  }
  return hasToStringTag$3 ? tryStringObject(value) : toStr$4.call(value) === strClass;
};
var $Map$2 = typeof Map === "function" && Map.prototype ? Map : null;
var $Set$2 = typeof Set === "function" && Set.prototype ? Set : null;
var exported$1;
if (!$Map$2) {
  exported$1 = function isMap2(x2) {
    return false;
  };
}
var $mapHas$1 = $Map$2 ? Map.prototype.has : null;
var $setHas$1 = $Set$2 ? Set.prototype.has : null;
if (!exported$1 && !$mapHas$1) {
  exported$1 = function isMap2(x2) {
    return false;
  };
}
var isMap$1 = exported$1 || function isMap(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    $mapHas$1.call(x2);
    if ($setHas$1) {
      try {
        $setHas$1.call(x2);
      } catch (e2) {
        return true;
      }
    }
    return x2 instanceof $Map$2;
  } catch (e2) {
  }
  return false;
};
var $Map$1 = typeof Map === "function" && Map.prototype ? Map : null;
var $Set$1 = typeof Set === "function" && Set.prototype ? Set : null;
var exported;
if (!$Set$1) {
  exported = function isSet2(x2) {
    return false;
  };
}
var $mapHas = $Map$1 ? Map.prototype.has : null;
var $setHas = $Set$1 ? Set.prototype.has : null;
if (!exported && !$setHas) {
  exported = function isSet2(x2) {
    return false;
  };
}
var isSet$1 = exported || function isSet(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    $setHas.call(x2);
    if ($mapHas) {
      try {
        $mapHas.call(x2);
      } catch (e2) {
        return true;
      }
    }
    return x2 instanceof $Set$1;
  } catch (e2) {
  }
  return false;
};
var isArguments4 = isArguments$1;
var getStopIterationIterator2 = stopIterationIterator;
if (hasSymbols$5() || shams$1()) {
  var $iterator = Symbol.iterator;
  esGetIterator.exports = function getIterator2(iterable) {
    if (iterable != null && typeof iterable[$iterator] !== "undefined") {
      return iterable[$iterator]();
    }
    if (isArguments4(iterable)) {
      return Array.prototype[$iterator].call(iterable);
    }
  };
} else {
  var isArray$5 = isarray;
  var isString$1 = isString$2;
  var GetIntrinsic$q = getIntrinsic;
  var $Map = GetIntrinsic$q("%Map%", true);
  var $Set = GetIntrinsic$q("%Set%", true);
  var callBound$8 = callBound$b;
  var $arrayPush = callBound$8("Array.prototype.push");
  var $charCodeAt = callBound$8("String.prototype.charCodeAt");
  var $stringSlice = callBound$8("String.prototype.slice");
  var advanceStringIndex = function advanceStringIndex2(S, index) {
    var length = S.length;
    if (index + 1 >= length) {
      return index + 1;
    }
    var first = $charCodeAt(S, index);
    if (first < 55296 || first > 56319) {
      return index + 1;
    }
    var second = $charCodeAt(S, index + 1);
    if (second < 56320 || second > 57343) {
      return index + 1;
    }
    return index + 2;
  };
  var getArrayIterator = function getArrayIterator2(arraylike) {
    var i = 0;
    return {
      next: function next() {
        var done = i >= arraylike.length;
        var value;
        if (!done) {
          value = arraylike[i];
          i += 1;
        }
        return {
          done,
          value
        };
      }
    };
  };
  var getNonCollectionIterator = function getNonCollectionIterator2(iterable, noPrimordialCollections) {
    if (isArray$5(iterable) || isArguments4(iterable)) {
      return getArrayIterator(iterable);
    }
    if (isString$1(iterable)) {
      var i = 0;
      return {
        next: function next() {
          var nextIndex = advanceStringIndex(iterable, i);
          var value = $stringSlice(iterable, i, nextIndex);
          i = nextIndex;
          return {
            done: nextIndex > iterable.length,
            value
          };
        }
      };
    }
    if (noPrimordialCollections && typeof iterable["_es6-shim iterator_"] !== "undefined") {
      return iterable["_es6-shim iterator_"]();
    }
  };
  if (!$Map && !$Set) {
    esGetIterator.exports = function getIterator2(iterable) {
      if (iterable != null) {
        return getNonCollectionIterator(iterable, true);
      }
    };
  } else {
    var isMap2 = isMap$1;
    var isSet2 = isSet$1;
    var $mapForEach = callBound$8("Map.prototype.forEach", true);
    var $setForEach = callBound$8("Set.prototype.forEach", true);
    if (typeof process === "undefined" || !process.versions || !process.versions.node) {
      var $mapIterator = callBound$8("Map.prototype.iterator", true);
      var $setIterator = callBound$8("Set.prototype.iterator", true);
    }
    var $mapAtAtIterator = callBound$8("Map.prototype.@@iterator", true) || callBound$8("Map.prototype._es6-shim iterator_", true);
    var $setAtAtIterator = callBound$8("Set.prototype.@@iterator", true) || callBound$8("Set.prototype._es6-shim iterator_", true);
    var getCollectionIterator = function getCollectionIterator2(iterable) {
      if (isMap2(iterable)) {
        if ($mapIterator) {
          return getStopIterationIterator2($mapIterator(iterable));
        }
        if ($mapAtAtIterator) {
          return $mapAtAtIterator(iterable);
        }
        if ($mapForEach) {
          var entries = [];
          $mapForEach(iterable, function(v2, k2) {
            $arrayPush(entries, [k2, v2]);
          });
          return getArrayIterator(entries);
        }
      }
      if (isSet2(iterable)) {
        if ($setIterator) {
          return getStopIterationIterator2($setIterator(iterable));
        }
        if ($setAtAtIterator) {
          return $setAtAtIterator(iterable);
        }
        if ($setForEach) {
          var values = [];
          $setForEach(iterable, function(v2) {
            $arrayPush(values, v2);
          });
          return getArrayIterator(values);
        }
      }
    };
    esGetIterator.exports = function getIterator2(iterable) {
      return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
    };
  }
}
var $TypeError$k = TypeError;
var iterateIterator = function iterateIterator2(iterator) {
  if (!iterator || typeof iterator.next !== "function") {
    throw new $TypeError$k("iterator must be an object with a `next` method");
  }
  if (arguments.length > 1) {
    var callback = arguments[1];
    if (typeof callback !== "function") {
      throw new $TypeError$k("`callback`, if provided, must be a function");
    }
  }
  var values = callback || [];
  var result;
  while ((result = iterator.next()) && !result.done) {
    if (callback) {
      callback(result.value);
    } else {
      values.push(result.value);
    }
  }
  if (!callback) {
    return values;
  }
};
var getIterator = esGetIterator.exports;
var $TypeError$j = TypeError;
var iterate$1 = iterateIterator;
var iterateValue = function iterateValue2(iterable) {
  var iterator = getIterator(iterable);
  if (!iterator) {
    throw new $TypeError$j("non-iterable value provided");
  }
  if (arguments.length > 1) {
    return iterate$1(iterator, arguments[1]);
  }
  return iterate$1(iterator);
};
var GetIntrinsic$p = getIntrinsic;
var $TypeError$i = GetIntrinsic$p("%TypeError%");
var CheckObjectCoercible = function CheckObjectCoercible2(value, optMessage) {
  if (value == null) {
    throw new $TypeError$i(optMessage || "Cannot call method on " + value);
  }
  return value;
};
var RequireObjectCoercible$4 = CheckObjectCoercible;
var _isNaN = Number.isNaN || function isNaN2(a2) {
  return a2 !== a2;
};
var $isNaN$2 = _isNaN;
var _isFinite = function(x2) {
  return (typeof x2 === "number" || typeof x2 === "bigint") && !$isNaN$2(x2) && x2 !== Infinity && x2 !== -Infinity;
};
var GetIntrinsic$o = getIntrinsic;
var $abs = GetIntrinsic$o("%Math.abs%");
var $floor$2 = GetIntrinsic$o("%Math.floor%");
var $isNaN$1 = _isNaN;
var $isFinite = _isFinite;
var isInteger$3 = function isInteger(argument) {
  if (typeof argument !== "number" || $isNaN$1(argument) || !$isFinite(argument)) {
    return false;
  }
  var absValue = $abs(argument);
  return $floor$2(absValue) === absValue;
};
var GetIntrinsic$n = getIntrinsic;
var $ArrayPrototype = GetIntrinsic$n("%Array.prototype%");
var $RangeError = GetIntrinsic$n("%RangeError%");
var $SyntaxError$2 = GetIntrinsic$n("%SyntaxError%");
var $TypeError$h = GetIntrinsic$n("%TypeError%");
var isInteger$2 = isInteger$3;
var MAX_ARRAY_LENGTH$1 = Math.pow(2, 32) - 1;
var hasProto2 = hasProto$2();
var $setProto = GetIntrinsic$n("%Object.setPrototypeOf%", true) || (hasProto2 ? function(O, proto) {
  O.__proto__ = proto;
  return O;
} : null);
var ArrayCreate$1 = function ArrayCreate(length) {
  if (!isInteger$2(length) || length < 0) {
    throw new $TypeError$h("Assertion failed: `length` must be an integer Number >= 0");
  }
  if (length > MAX_ARRAY_LENGTH$1) {
    throw new $RangeError("length is greater than (2**32 - 1)");
  }
  var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
  var A = [];
  if (proto !== $ArrayPrototype) {
    if (!$setProto) {
      throw new $SyntaxError$2("ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]");
    }
    $setProto(A, proto);
  }
  if (length !== 0) {
    A.length = length;
  }
  return A;
};
var IsPropertyKey$7 = function IsPropertyKey(argument) {
  return typeof argument === "string" || typeof argument === "symbol";
};
var GetIntrinsic$m = getIntrinsic;
var $TypeError$g = GetIntrinsic$m("%TypeError%");
var inspect = objectInspect;
var IsPropertyKey$6 = IsPropertyKey$7;
var Type$f = Type$g;
var Get$2 = function Get(O, P) {
  if (Type$f(O) !== "Object") {
    throw new $TypeError$g("Assertion failed: Type(O) is not Object");
  }
  if (!IsPropertyKey$6(P)) {
    throw new $TypeError$g("Assertion failed: IsPropertyKey(P) is not true, got " + inspect(P));
  }
  return O[P];
};
var GetIntrinsic$l = getIntrinsic;
var $Array = GetIntrinsic$l("%Array%");
var toStr$3 = !$Array.isArray && callBound$b("Object.prototype.toString");
var IsArray$3 = $Array.isArray || function IsArray(argument) {
  return toStr$3(argument) === "[object Array]";
};
var IsArray$2 = IsArray$3;
var IsConstructor$1 = { exports: {} };
var GetIntrinsic$k = getIntrinsic;
var GetIntrinsic$j = getIntrinsic;
var hasOwn$5 = hasown;
var $TypeError$f = GetIntrinsic$j("%TypeError%");
var isPropertyDescriptor$3 = function IsPropertyDescriptor(ES, Desc) {
  if (ES.Type(Desc) !== "Object") {
    return false;
  }
  var allowed = {
    "[[Configurable]]": true,
    "[[Enumerable]]": true,
    "[[Get]]": true,
    "[[Set]]": true,
    "[[Value]]": true,
    "[[Writable]]": true
  };
  for (var key in Desc) {
    if (hasOwn$5(Desc, key) && !allowed[key]) {
      return false;
    }
  }
  if (ES.IsDataDescriptor(Desc) && ES.IsAccessorDescriptor(Desc)) {
    throw new $TypeError$f("Property Descriptors may not be both accessor and data descriptors");
  }
  return true;
};
var hasPropertyDescriptors2 = hasPropertyDescriptors_1;
var GetIntrinsic$i = getIntrinsic;
var $defineProperty = hasPropertyDescriptors2() && GetIntrinsic$i("%Object.defineProperty%", true);
var hasArrayLengthDefineBug2 = hasPropertyDescriptors2.hasArrayLengthDefineBug();
var isArray$4 = hasArrayLengthDefineBug2 && IsArray$3;
var callBound$7 = callBound$b;
var $isEnumerable = callBound$7("Object.prototype.propertyIsEnumerable");
var DefineOwnProperty$2 = function DefineOwnProperty(IsDataDescriptor3, SameValue3, FromPropertyDescriptor3, O, P, desc) {
  if (!$defineProperty) {
    if (!IsDataDescriptor3(desc)) {
      return false;
    }
    if (!desc["[[Configurable]]"] || !desc["[[Writable]]"]) {
      return false;
    }
    if (P in O && $isEnumerable(O, P) !== !!desc["[[Enumerable]]"]) {
      return false;
    }
    var V = desc["[[Value]]"];
    O[P] = V;
    return SameValue3(O[P], V);
  }
  if (hasArrayLengthDefineBug2 && P === "length" && "[[Value]]" in desc && isArray$4(O) && O.length !== desc["[[Value]]"]) {
    O.length = desc["[[Value]]"];
    return O.length === desc["[[Value]]"];
  }
  $defineProperty(O, P, FromPropertyDescriptor3(desc));
  return true;
};
var hasOwn$4 = hasown;
var isMatchRecord$1 = function isMatchRecord(record) {
  return hasOwn$4(record, "[[StartIndex]]") && hasOwn$4(record, "[[EndIndex]]") && record["[[StartIndex]]"] >= 0 && record["[[EndIndex]]"] >= record["[[StartIndex]]"] && String(parseInt(record["[[StartIndex]]"], 10)) === String(record["[[StartIndex]]"]) && String(parseInt(record["[[EndIndex]]"], 10)) === String(record["[[EndIndex]]"]);
};
var GetIntrinsic$h = getIntrinsic;
var $TypeError$e = GetIntrinsic$h("%TypeError%");
var $SyntaxError$1 = GetIntrinsic$h("%SyntaxError%");
var hasOwn$3 = hasown;
var isInteger$1 = isInteger$3;
var isMatchRecord2 = isMatchRecord$1;
var predicates = {
  "Property Descriptor": function isPropertyDescriptor(Desc) {
    var allowed = {
      "[[Configurable]]": true,
      "[[Enumerable]]": true,
      "[[Get]]": true,
      "[[Set]]": true,
      "[[Value]]": true,
      "[[Writable]]": true
    };
    if (!Desc) {
      return false;
    }
    for (var key in Desc) {
      if (hasOwn$3(Desc, key) && !allowed[key]) {
        return false;
      }
    }
    var isData = hasOwn$3(Desc, "[[Value]]");
    var IsAccessor = hasOwn$3(Desc, "[[Get]]") || hasOwn$3(Desc, "[[Set]]");
    if (isData && IsAccessor) {
      throw new $TypeError$e("Property Descriptors may not be both accessor and data descriptors");
    }
    return true;
  },
  "Match Record": isMatchRecord2,
  "Iterator Record": function isIteratorRecord(value) {
    return hasOwn$3(value, "[[Iterator]]") && hasOwn$3(value, "[[NextMethod]]") && hasOwn$3(value, "[[Done]]");
  },
  "PromiseCapability Record": function isPromiseCapabilityRecord(value) {
    return !!value && hasOwn$3(value, "[[Resolve]]") && typeof value["[[Resolve]]"] === "function" && hasOwn$3(value, "[[Reject]]") && typeof value["[[Reject]]"] === "function" && hasOwn$3(value, "[[Promise]]") && value["[[Promise]]"] && typeof value["[[Promise]]"].then === "function";
  },
  "AsyncGeneratorRequest Record": function isAsyncGeneratorRequestRecord(value) {
    return !!value && hasOwn$3(value, "[[Completion]]") && hasOwn$3(value, "[[Capability]]") && predicates["PromiseCapability Record"](value["[[Capability]]"]);
  },
  "RegExp Record": function isRegExpRecord(value) {
    return value && hasOwn$3(value, "[[IgnoreCase]]") && typeof value["[[IgnoreCase]]"] === "boolean" && hasOwn$3(value, "[[Multiline]]") && typeof value["[[Multiline]]"] === "boolean" && hasOwn$3(value, "[[DotAll]]") && typeof value["[[DotAll]]"] === "boolean" && hasOwn$3(value, "[[Unicode]]") && typeof value["[[Unicode]]"] === "boolean" && hasOwn$3(value, "[[CapturingGroupsCount]]") && typeof value["[[CapturingGroupsCount]]"] === "number" && isInteger$1(value["[[CapturingGroupsCount]]"]) && value["[[CapturingGroupsCount]]"] >= 0;
  }
};
var assertRecord$4 = function assertRecord(Type4, recordType, argumentName, value) {
  var predicate = predicates[recordType];
  if (typeof predicate !== "function") {
    throw new $SyntaxError$1("unknown record type: " + recordType);
  }
  if (Type4(value) !== "Object" || !predicate(value)) {
    throw new $TypeError$e(argumentName + " must be a " + recordType);
  }
};
var fromPropertyDescriptor$1 = function fromPropertyDescriptor(Desc) {
  if (typeof Desc === "undefined") {
    return Desc;
  }
  var obj = {};
  if ("[[Value]]" in Desc) {
    obj.value = Desc["[[Value]]"];
  }
  if ("[[Writable]]" in Desc) {
    obj.writable = !!Desc["[[Writable]]"];
  }
  if ("[[Get]]" in Desc) {
    obj.get = Desc["[[Get]]"];
  }
  if ("[[Set]]" in Desc) {
    obj.set = Desc["[[Set]]"];
  }
  if ("[[Enumerable]]" in Desc) {
    obj.enumerable = !!Desc["[[Enumerable]]"];
  }
  if ("[[Configurable]]" in Desc) {
    obj.configurable = !!Desc["[[Configurable]]"];
  }
  return obj;
};
var assertRecord$3 = assertRecord$4;
var fromPropertyDescriptor2 = fromPropertyDescriptor$1;
var Type$e = Type$g;
var FromPropertyDescriptor$2 = function FromPropertyDescriptor(Desc) {
  if (typeof Desc !== "undefined") {
    assertRecord$3(Type$e, "Property Descriptor", "Desc", Desc);
  }
  return fromPropertyDescriptor2(Desc);
};
var hasOwn$2 = hasown;
var Type$d = Type$g;
var assertRecord$2 = assertRecord$4;
var IsAccessorDescriptor$4 = function IsAccessorDescriptor(Desc) {
  if (typeof Desc === "undefined") {
    return false;
  }
  assertRecord$2(Type$d, "Property Descriptor", "Desc", Desc);
  if (!hasOwn$2(Desc, "[[Get]]") && !hasOwn$2(Desc, "[[Set]]")) {
    return false;
  }
  return true;
};
var hasOwn$1 = hasown;
var Type$c = Type$g;
var assertRecord$1 = assertRecord$4;
var IsDataDescriptor$4 = function IsDataDescriptor(Desc) {
  if (typeof Desc === "undefined") {
    return false;
  }
  assertRecord$1(Type$c, "Property Descriptor", "Desc", Desc);
  if (!hasOwn$1(Desc, "[[Value]]") && !hasOwn$1(Desc, "[[Writable]]")) {
    return false;
  }
  return true;
};
var $isNaN = _isNaN;
var SameValue$3 = function SameValue(x2, y2) {
  if (x2 === y2) {
    if (x2 === 0) {
      return 1 / x2 === 1 / y2;
    }
    return true;
  }
  return $isNaN(x2) && $isNaN(y2);
};
var ToBoolean$1 = function ToBoolean(value) {
  return !!value;
};
var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
var badArrayLike$1;
var isCallableMarker;
if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
  try {
    badArrayLike$1 = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    });
    isCallableMarker = {};
    reflectApply(function() {
      throw 42;
    }, null, badArrayLike$1);
  } catch (_) {
    if (_ !== isCallableMarker) {
      reflectApply = null;
    }
  }
} else {
  reflectApply = null;
}
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
  try {
    var fnStr = fnToStr.call(value);
    return constructorRegex.test(fnStr);
  } catch (e2) {
    return false;
  }
};
var tryFunctionObject = function tryFunctionToStr(value) {
  try {
    if (isES6ClassFn(value)) {
      return false;
    }
    fnToStr.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr$2 = Object.prototype.toString;
var objectClass = "[object Object]";
var fnClass = "[object Function]";
var genClass = "[object GeneratorFunction]";
var ddaClass = "[object HTMLAllCollection]";
var ddaClass2 = "[object HTML document.all class]";
var ddaClass3 = "[object HTMLCollection]";
var hasToStringTag$2 = typeof Symbol === "function" && !!Symbol.toStringTag;
var isIE68 = !(0 in [,]);
var isDDA = function isDocumentDotAll() {
  return false;
};
if (typeof document === "object") {
  var all$1 = document.all;
  if (toStr$2.call(all$1) === toStr$2.call(document.all)) {
    isDDA = function isDocumentDotAll2(value) {
      if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
        try {
          var str = toStr$2.call(value);
          return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
        } catch (e2) {
        }
      }
      return false;
    };
  }
}
var isCallable$1 = reflectApply ? function isCallable(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== "function" && typeof value !== "object") {
    return false;
  }
  try {
    reflectApply(value, null, badArrayLike$1);
  } catch (e2) {
    if (e2 !== isCallableMarker) {
      return false;
    }
  }
  return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable2(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== "function" && typeof value !== "object") {
    return false;
  }
  if (hasToStringTag$2) {
    return tryFunctionObject(value);
  }
  if (isES6ClassFn(value)) {
    return false;
  }
  var strClass2 = toStr$2.call(value);
  if (strClass2 !== fnClass && strClass2 !== genClass && !/^\[object HTML/.test(strClass2)) {
    return false;
  }
  return tryFunctionObject(value);
};
var IsCallable$2 = isCallable$1;
var hasOwn = hasown;
var GetIntrinsic$g = getIntrinsic;
var $TypeError$d = GetIntrinsic$g("%TypeError%");
var Type$b = Type$g;
var ToBoolean2 = ToBoolean$1;
var IsCallable$1 = IsCallable$2;
var ToPropertyDescriptor$2 = function ToPropertyDescriptor(Obj) {
  if (Type$b(Obj) !== "Object") {
    throw new $TypeError$d("ToPropertyDescriptor requires an object");
  }
  var desc = {};
  if (hasOwn(Obj, "enumerable")) {
    desc["[[Enumerable]]"] = ToBoolean2(Obj.enumerable);
  }
  if (hasOwn(Obj, "configurable")) {
    desc["[[Configurable]]"] = ToBoolean2(Obj.configurable);
  }
  if (hasOwn(Obj, "value")) {
    desc["[[Value]]"] = Obj.value;
  }
  if (hasOwn(Obj, "writable")) {
    desc["[[Writable]]"] = ToBoolean2(Obj.writable);
  }
  if (hasOwn(Obj, "get")) {
    var getter = Obj.get;
    if (typeof getter !== "undefined" && !IsCallable$1(getter)) {
      throw new $TypeError$d("getter must be a function");
    }
    desc["[[Get]]"] = getter;
  }
  if (hasOwn(Obj, "set")) {
    var setter = Obj.set;
    if (typeof setter !== "undefined" && !IsCallable$1(setter)) {
      throw new $TypeError$d("setter must be a function");
    }
    desc["[[Set]]"] = setter;
  }
  if ((hasOwn(desc, "[[Get]]") || hasOwn(desc, "[[Set]]")) && (hasOwn(desc, "[[Value]]") || hasOwn(desc, "[[Writable]]"))) {
    throw new $TypeError$d("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
  }
  return desc;
};
var GetIntrinsic$f = getIntrinsic;
var $TypeError$c = GetIntrinsic$f("%TypeError%");
var isPropertyDescriptor$2 = isPropertyDescriptor$3;
var DefineOwnProperty$1 = DefineOwnProperty$2;
var FromPropertyDescriptor$1 = FromPropertyDescriptor$2;
var IsAccessorDescriptor$3 = IsAccessorDescriptor$4;
var IsDataDescriptor$3 = IsDataDescriptor$4;
var IsPropertyKey$5 = IsPropertyKey$7;
var SameValue$2 = SameValue$3;
var ToPropertyDescriptor$1 = ToPropertyDescriptor$2;
var Type$a = Type$g;
var DefinePropertyOrThrow$1 = function DefinePropertyOrThrow(O, P, desc) {
  if (Type$a(O) !== "Object") {
    throw new $TypeError$c("Assertion failed: Type(O) is not Object");
  }
  if (!IsPropertyKey$5(P)) {
    throw new $TypeError$c("Assertion failed: IsPropertyKey(P) is not true");
  }
  var Desc = isPropertyDescriptor$2({
    Type: Type$a,
    IsDataDescriptor: IsDataDescriptor$3,
    IsAccessorDescriptor: IsAccessorDescriptor$3
  }, desc) ? desc : ToPropertyDescriptor$1(desc);
  if (!isPropertyDescriptor$2({
    Type: Type$a,
    IsDataDescriptor: IsDataDescriptor$3,
    IsAccessorDescriptor: IsAccessorDescriptor$3
  }, Desc)) {
    throw new $TypeError$c("Assertion failed: Desc is not a valid Property Descriptor");
  }
  return DefineOwnProperty$1(
    IsDataDescriptor$3,
    SameValue$2,
    FromPropertyDescriptor$1,
    O,
    P,
    Desc
  );
};
var GetIntrinsic$e = GetIntrinsic$k;
var $construct = GetIntrinsic$e("%Reflect.construct%", true);
var DefinePropertyOrThrow2 = DefinePropertyOrThrow$1;
try {
  DefinePropertyOrThrow2({}, "", { "[[Get]]": function() {
  } });
} catch (e2) {
  DefinePropertyOrThrow2 = null;
}
if (DefinePropertyOrThrow2 && $construct) {
  var isConstructorMarker = {};
  var badArrayLike = {};
  DefinePropertyOrThrow2(badArrayLike, "length", {
    "[[Get]]": function() {
      throw isConstructorMarker;
    },
    "[[Enumerable]]": true
  });
  IsConstructor$1.exports = function IsConstructor2(argument) {
    try {
      $construct(argument, badArrayLike);
    } catch (err) {
      return err === isConstructorMarker;
    }
  };
} else {
  IsConstructor$1.exports = function IsConstructor2(argument) {
    return typeof argument === "function" && !!argument.prototype;
  };
}
var GetIntrinsic$d = getIntrinsic;
var $species = GetIntrinsic$d("%Symbol.species%", true);
var $TypeError$b = GetIntrinsic$d("%TypeError%");
var ArrayCreate2 = ArrayCreate$1;
var Get$1 = Get$2;
var IsArray$1 = IsArray$2;
var IsConstructor = IsConstructor$1.exports;
var Type$9 = Type$g;
var isInteger2 = isInteger$3;
var ArraySpeciesCreate$1 = function ArraySpeciesCreate(originalArray, length) {
  if (!isInteger2(length) || length < 0) {
    throw new $TypeError$b("Assertion failed: length must be an integer >= 0");
  }
  var isArray2 = IsArray$1(originalArray);
  if (!isArray2) {
    return ArrayCreate2(length);
  }
  var C = Get$1(originalArray, "constructor");
  if ($species && Type$9(C) === "Object") {
    C = Get$1(C, $species);
    if (C === null) {
      C = void 0;
    }
  }
  if (typeof C === "undefined") {
    return ArrayCreate2(length);
  }
  if (!IsConstructor(C)) {
    throw new $TypeError$b("C must be a constructor");
  }
  return new C(length);
};
var GetIntrinsic$c = getIntrinsic;
var callBound$6 = callBound$b;
var $TypeError$a = GetIntrinsic$c("%TypeError%");
var IsArray2 = IsArray$2;
var $apply = GetIntrinsic$c("%Reflect.apply%", true) || callBound$6("Function.prototype.apply");
var Call$1 = function Call(F, V) {
  var argumentsList = arguments.length > 2 ? arguments[2] : [];
  if (!IsArray2(argumentsList)) {
    throw new $TypeError$a("Assertion failed: optional `argumentsList`, if provided, must be a List");
  }
  return $apply(F, V, argumentsList);
};
var isPrimitive$4 = function isPrimitive(value) {
  return value === null || typeof value !== "function" && typeof value !== "object";
};
var GetIntrinsic$b = getIntrinsic;
var $preventExtensions = GetIntrinsic$b("%Object.preventExtensions%", true);
var $isExtensible = GetIntrinsic$b("%Object.isExtensible%", true);
var isPrimitive$3 = isPrimitive$4;
var IsExtensible$1 = $preventExtensions ? function IsExtensible(obj) {
  return !isPrimitive$3(obj) && $isExtensible(obj);
} : function IsExtensible2(obj) {
  return !isPrimitive$3(obj);
};
var isFullyPopulatedPropertyDescriptor$1 = function isFullyPopulatedPropertyDescriptor(ES, Desc) {
  return !!Desc && typeof Desc === "object" && "[[Enumerable]]" in Desc && "[[Configurable]]" in Desc && (ES.IsAccessorDescriptor(Desc) || ES.IsDataDescriptor(Desc));
};
var assertRecord2 = assertRecord$4;
var IsAccessorDescriptor$2 = IsAccessorDescriptor$4;
var IsDataDescriptor$2 = IsDataDescriptor$4;
var Type$8 = Type$g;
var IsGenericDescriptor$1 = function IsGenericDescriptor(Desc) {
  if (typeof Desc === "undefined") {
    return false;
  }
  assertRecord2(Type$8, "Property Descriptor", "Desc", Desc);
  if (!IsAccessorDescriptor$2(Desc) && !IsDataDescriptor$2(Desc)) {
    return true;
  }
  return false;
};
var GetIntrinsic$a = getIntrinsic;
var $TypeError$9 = GetIntrinsic$a("%TypeError%");
var DefineOwnProperty2 = DefineOwnProperty$2;
var isFullyPopulatedPropertyDescriptor2 = isFullyPopulatedPropertyDescriptor$1;
var isPropertyDescriptor$1 = isPropertyDescriptor$3;
var FromPropertyDescriptor2 = FromPropertyDescriptor$2;
var IsAccessorDescriptor$1 = IsAccessorDescriptor$4;
var IsDataDescriptor$1 = IsDataDescriptor$4;
var IsGenericDescriptor2 = IsGenericDescriptor$1;
var IsPropertyKey$4 = IsPropertyKey$7;
var SameValue$1 = SameValue$3;
var Type$7 = Type$g;
var ValidateAndApplyPropertyDescriptor$1 = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current2) {
  var oType = Type$7(O);
  if (oType !== "Undefined" && oType !== "Object") {
    throw new $TypeError$9("Assertion failed: O must be undefined or an Object");
  }
  if (!IsPropertyKey$4(P)) {
    throw new $TypeError$9("Assertion failed: P must be a Property Key");
  }
  if (Type$7(extensible) !== "Boolean") {
    throw new $TypeError$9("Assertion failed: extensible must be a Boolean");
  }
  if (!isPropertyDescriptor$1({
    Type: Type$7,
    IsDataDescriptor: IsDataDescriptor$1,
    IsAccessorDescriptor: IsAccessorDescriptor$1
  }, Desc)) {
    throw new $TypeError$9("Assertion failed: Desc must be a Property Descriptor");
  }
  if (Type$7(current2) !== "Undefined" && !isPropertyDescriptor$1({
    Type: Type$7,
    IsDataDescriptor: IsDataDescriptor$1,
    IsAccessorDescriptor: IsAccessorDescriptor$1
  }, current2)) {
    throw new $TypeError$9("Assertion failed: current must be a Property Descriptor, or undefined");
  }
  if (Type$7(current2) === "Undefined") {
    if (!extensible) {
      return false;
    }
    if (oType === "Undefined") {
      return true;
    }
    if (IsAccessorDescriptor$1(Desc)) {
      return DefineOwnProperty2(
        IsDataDescriptor$1,
        SameValue$1,
        FromPropertyDescriptor2,
        O,
        P,
        Desc
      );
    }
    return DefineOwnProperty2(
      IsDataDescriptor$1,
      SameValue$1,
      FromPropertyDescriptor2,
      O,
      P,
      {
        "[[Configurable]]": !!Desc["[[Configurable]]"],
        "[[Enumerable]]": !!Desc["[[Enumerable]]"],
        "[[Value]]": Desc["[[Value]]"],
        "[[Writable]]": !!Desc["[[Writable]]"]
      }
    );
  }
  if (!isFullyPopulatedPropertyDescriptor2({
    IsAccessorDescriptor: IsAccessorDescriptor$1,
    IsDataDescriptor: IsDataDescriptor$1
  }, current2)) {
    throw new $TypeError$9("`current`, when present, must be a fully populated and valid Property Descriptor");
  }
  if (!current2["[[Configurable]]"]) {
    if ("[[Configurable]]" in Desc && Desc["[[Configurable]]"]) {
      return false;
    }
    if ("[[Enumerable]]" in Desc && !SameValue$1(Desc["[[Enumerable]]"], current2["[[Enumerable]]"])) {
      return false;
    }
    if (!IsGenericDescriptor2(Desc) && !SameValue$1(IsAccessorDescriptor$1(Desc), IsAccessorDescriptor$1(current2))) {
      return false;
    }
    if (IsAccessorDescriptor$1(current2)) {
      if ("[[Get]]" in Desc && !SameValue$1(Desc["[[Get]]"], current2["[[Get]]"])) {
        return false;
      }
      if ("[[Set]]" in Desc && !SameValue$1(Desc["[[Set]]"], current2["[[Set]]"])) {
        return false;
      }
    } else if (!current2["[[Writable]]"]) {
      if ("[[Writable]]" in Desc && Desc["[[Writable]]"]) {
        return false;
      }
      if ("[[Value]]" in Desc && !SameValue$1(Desc["[[Value]]"], current2["[[Value]]"])) {
        return false;
      }
    }
  }
  if (oType !== "Undefined") {
    var configurable;
    var enumerable;
    if (IsDataDescriptor$1(current2) && IsAccessorDescriptor$1(Desc)) {
      configurable = ("[[Configurable]]" in Desc ? Desc : current2)["[[Configurable]]"];
      enumerable = ("[[Enumerable]]" in Desc ? Desc : current2)["[[Enumerable]]"];
      return DefineOwnProperty2(
        IsDataDescriptor$1,
        SameValue$1,
        FromPropertyDescriptor2,
        O,
        P,
        {
          "[[Configurable]]": !!configurable,
          "[[Enumerable]]": !!enumerable,
          "[[Get]]": ("[[Get]]" in Desc ? Desc : current2)["[[Get]]"],
          "[[Set]]": ("[[Set]]" in Desc ? Desc : current2)["[[Set]]"]
        }
      );
    } else if (IsAccessorDescriptor$1(current2) && IsDataDescriptor$1(Desc)) {
      configurable = ("[[Configurable]]" in Desc ? Desc : current2)["[[Configurable]]"];
      enumerable = ("[[Enumerable]]" in Desc ? Desc : current2)["[[Enumerable]]"];
      return DefineOwnProperty2(
        IsDataDescriptor$1,
        SameValue$1,
        FromPropertyDescriptor2,
        O,
        P,
        {
          "[[Configurable]]": !!configurable,
          "[[Enumerable]]": !!enumerable,
          "[[Value]]": ("[[Value]]" in Desc ? Desc : current2)["[[Value]]"],
          "[[Writable]]": !!("[[Writable]]" in Desc ? Desc : current2)["[[Writable]]"]
        }
      );
    }
    return DefineOwnProperty2(
      IsDataDescriptor$1,
      SameValue$1,
      FromPropertyDescriptor2,
      O,
      P,
      Desc
    );
  }
  return true;
};
var GetIntrinsic$9 = getIntrinsic;
var $gOPD = gopd$1;
var $SyntaxError = GetIntrinsic$9("%SyntaxError%");
var $TypeError$8 = GetIntrinsic$9("%TypeError%");
var isPropertyDescriptor2 = isPropertyDescriptor$3;
var IsAccessorDescriptor2 = IsAccessorDescriptor$4;
var IsDataDescriptor2 = IsDataDescriptor$4;
var IsExtensible3 = IsExtensible$1;
var IsPropertyKey$3 = IsPropertyKey$7;
var ToPropertyDescriptor2 = ToPropertyDescriptor$2;
var SameValue2 = SameValue$3;
var Type$6 = Type$g;
var ValidateAndApplyPropertyDescriptor2 = ValidateAndApplyPropertyDescriptor$1;
var OrdinaryDefineOwnProperty$1 = function OrdinaryDefineOwnProperty(O, P, Desc) {
  if (Type$6(O) !== "Object") {
    throw new $TypeError$8("Assertion failed: O must be an Object");
  }
  if (!IsPropertyKey$3(P)) {
    throw new $TypeError$8("Assertion failed: P must be a Property Key");
  }
  if (!isPropertyDescriptor2({
    Type: Type$6,
    IsDataDescriptor: IsDataDescriptor2,
    IsAccessorDescriptor: IsAccessorDescriptor2
  }, Desc)) {
    throw new $TypeError$8("Assertion failed: Desc must be a Property Descriptor");
  }
  if (!$gOPD) {
    if (IsAccessorDescriptor2(Desc)) {
      throw new $SyntaxError("This environment does not support accessor property descriptors.");
    }
    var creatingNormalDataProperty = !(P in O) && Desc["[[Writable]]"] && Desc["[[Enumerable]]"] && Desc["[[Configurable]]"] && "[[Value]]" in Desc;
    var settingExistingDataProperty = P in O && (!("[[Configurable]]" in Desc) || Desc["[[Configurable]]"]) && (!("[[Enumerable]]" in Desc) || Desc["[[Enumerable]]"]) && (!("[[Writable]]" in Desc) || Desc["[[Writable]]"]) && "[[Value]]" in Desc;
    if (creatingNormalDataProperty || settingExistingDataProperty) {
      O[P] = Desc["[[Value]]"];
      return SameValue2(O[P], Desc["[[Value]]"]);
    }
    throw new $SyntaxError("This environment does not support defining non-writable, non-enumerable, or non-configurable properties");
  }
  var desc = $gOPD(O, P);
  var current2 = desc && ToPropertyDescriptor2(desc);
  var extensible = IsExtensible3(O);
  return ValidateAndApplyPropertyDescriptor2(O, P, extensible, Desc, current2);
};
var GetIntrinsic$8 = getIntrinsic;
var $TypeError$7 = GetIntrinsic$8("%TypeError%");
var IsPropertyKey$2 = IsPropertyKey$7;
var OrdinaryDefineOwnProperty2 = OrdinaryDefineOwnProperty$1;
var Type$5 = Type$g;
var CreateDataProperty$1 = function CreateDataProperty(O, P, V) {
  if (Type$5(O) !== "Object") {
    throw new $TypeError$7("Assertion failed: Type(O) is not Object");
  }
  if (!IsPropertyKey$2(P)) {
    throw new $TypeError$7("Assertion failed: IsPropertyKey(P) is not true");
  }
  var newDesc = {
    "[[Configurable]]": true,
    "[[Enumerable]]": true,
    "[[Value]]": V,
    "[[Writable]]": true
  };
  return OrdinaryDefineOwnProperty2(O, P, newDesc);
};
var GetIntrinsic$7 = getIntrinsic;
var $TypeError$6 = GetIntrinsic$7("%TypeError%");
var CreateDataProperty2 = CreateDataProperty$1;
var IsPropertyKey$1 = IsPropertyKey$7;
var Type$4 = Type$g;
var CreateDataPropertyOrThrow$1 = function CreateDataPropertyOrThrow(O, P, V) {
  if (Type$4(O) !== "Object") {
    throw new $TypeError$6("Assertion failed: Type(O) is not Object");
  }
  if (!IsPropertyKey$1(P)) {
    throw new $TypeError$6("Assertion failed: IsPropertyKey(P) is not true");
  }
  var success = CreateDataProperty2(O, P, V);
  if (!success) {
    throw new $TypeError$6("unable to create data property");
  }
};
var GetIntrinsic$6 = getIntrinsic;
var $TypeError$5 = GetIntrinsic$6("%TypeError%");
var IsPropertyKey2 = IsPropertyKey$7;
var Type$3 = Type$g;
var HasProperty$1 = function HasProperty(O, P) {
  if (Type$3(O) !== "Object") {
    throw new $TypeError$5("Assertion failed: `O` must be an Object");
  }
  if (!IsPropertyKey2(P)) {
    throw new $TypeError$5("Assertion failed: `P` must be a Property Key");
  }
  return P in O;
};
var $floor$1 = Math.floor;
var mod$1 = function mod(number, modulo3) {
  var remain = number % modulo3;
  return $floor$1(remain >= 0 ? remain : remain + modulo3);
};
var mod2 = mod$1;
var modulo$1 = function modulo(x2, y2) {
  return mod2(x2, y2);
};
var isPrimitive$2 = function isPrimitive2(value) {
  return value === null || typeof value !== "function" && typeof value !== "object";
};
var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
  try {
    getDay.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr$1 = Object.prototype.toString;
var dateClass = "[object Date]";
var hasToStringTag$1 = shams();
var isDateObject = function isDateObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  return hasToStringTag$1 ? tryDateObject(value) : toStr$1.call(value) === dateClass;
};
var isSymbol$3 = { exports: {} };
var toStr = Object.prototype.toString;
var hasSymbols$1 = hasSymbols$5();
if (hasSymbols$1) {
  var symToStr = Symbol.prototype.toString;
  var symStringRegex = /^Symbol\(.*\)$/;
  var isSymbolObject = function isRealSymbolObject(value) {
    if (typeof value.valueOf() !== "symbol") {
      return false;
    }
    return symStringRegex.test(symToStr.call(value));
  };
  isSymbol$3.exports = function isSymbol2(value) {
    if (typeof value === "symbol") {
      return true;
    }
    if (toStr.call(value) !== "[object Symbol]") {
      return false;
    }
    try {
      return isSymbolObject(value);
    } catch (e2) {
      return false;
    }
  };
} else {
  isSymbol$3.exports = function isSymbol2(value) {
    return false;
  };
}
var hasSymbols2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol";
var isPrimitive$1 = isPrimitive$2;
var isCallable3 = isCallable$1;
var isDate = isDateObject;
var isSymbol$2 = isSymbol$3.exports;
var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
  if (typeof O === "undefined" || O === null) {
    throw new TypeError("Cannot call method on " + O);
  }
  if (typeof hint !== "string" || hint !== "number" && hint !== "string") {
    throw new TypeError('hint must be "string" or "number"');
  }
  var methodNames = hint === "string" ? ["toString", "valueOf"] : ["valueOf", "toString"];
  var method, result, i;
  for (i = 0; i < methodNames.length; ++i) {
    method = O[methodNames[i]];
    if (isCallable3(method)) {
      result = method.call(O);
      if (isPrimitive$1(result)) {
        return result;
      }
    }
  }
  throw new TypeError("No default value");
};
var GetMethod = function GetMethod2(O, P) {
  var func = O[P];
  if (func !== null && typeof func !== "undefined") {
    if (!isCallable3(func)) {
      throw new TypeError(func + " returned for property " + P + " of object " + O + " is not a function");
    }
    return func;
  }
  return void 0;
};
var es2015 = function ToPrimitive(input) {
  if (isPrimitive$1(input)) {
    return input;
  }
  var hint = "default";
  if (arguments.length > 1) {
    if (arguments[1] === String) {
      hint = "string";
    } else if (arguments[1] === Number) {
      hint = "number";
    }
  }
  var exoticToPrim;
  if (hasSymbols2) {
    if (Symbol.toPrimitive) {
      exoticToPrim = GetMethod(input, Symbol.toPrimitive);
    } else if (isSymbol$2(input)) {
      exoticToPrim = Symbol.prototype.valueOf;
    }
  }
  if (typeof exoticToPrim !== "undefined") {
    var result = exoticToPrim.call(input, hint);
    if (isPrimitive$1(result)) {
      return result;
    }
    throw new TypeError("unable to convert exotic object to primitive");
  }
  if (hint === "default" && (isDate(input) || isSymbol$2(input))) {
    hint = "string";
  }
  return ordinaryToPrimitive(input, hint === "default" ? "number" : hint);
};
var toPrimitive = es2015;
var ToPrimitive$1 = function ToPrimitive2(input) {
  if (arguments.length > 1) {
    return toPrimitive(input, arguments[1]);
  }
  return toPrimitive(input);
};
var callBound$5 = callBound$b;
var hasToStringTag = shams();
var has;
var $exec$1;
var isRegexMarker;
var badStringifier;
if (hasToStringTag) {
  has = callBound$5("Object.prototype.hasOwnProperty");
  $exec$1 = callBound$5("RegExp.prototype.exec");
  isRegexMarker = {};
  var throwRegexMarker = function() {
    throw isRegexMarker;
  };
  badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  if (typeof Symbol.toPrimitive === "symbol") {
    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }
}
var $toString = callBound$5("Object.prototype.toString");
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = "[object RegExp]";
var isRegex$1 = hasToStringTag ? function isRegex(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  var descriptor = gOPD(value, "lastIndex");
  var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
  if (!hasLastIndexDataProperty) {
    return false;
  }
  try {
    $exec$1(value, badStringifier);
  } catch (e2) {
    return e2 === isRegexMarker;
  }
} : function isRegex2(value) {
  if (!value || typeof value !== "object" && typeof value !== "function") {
    return false;
  }
  return $toString(value) === regexClass;
};
var callBound$4 = callBound$b;
var isRegex3 = isRegex$1;
var $exec = callBound$4("RegExp.prototype.exec");
var $TypeError$4 = type;
var safeRegexTest = function regexTester(regex) {
  if (!isRegex3(regex)) {
    throw new $TypeError$4("`regex` must be a RegExp");
  }
  return function test2(s2) {
    return $exec(regex, s2) !== null;
  };
};
var GetIntrinsic$5 = getIntrinsic;
var $String = GetIntrinsic$5("%String%");
var $TypeError$3 = GetIntrinsic$5("%TypeError%");
var ToString$2 = function ToString(argument) {
  if (typeof argument === "symbol") {
    throw new $TypeError$3("Cannot convert a Symbol value to a string");
  }
  return $String(argument);
};
var RequireObjectCoercible$3 = RequireObjectCoercible$4;
var ToString$1 = ToString$2;
var callBound$3 = callBound$b;
var $replace = callBound$3("String.prototype.replace");
var mvsIsWS = /^\s$/.test("\u180E");
var leftWhitespace = mvsIsWS ? /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/ : /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/;
var rightWhitespace = mvsIsWS ? /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/ : /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/;
var implementation$8 = function trim() {
  var S = ToString$1(RequireObjectCoercible$3(this));
  return $replace($replace(S, leftWhitespace, ""), rightWhitespace, "");
};
var implementation$7 = implementation$8;
var zeroWidthSpace = "\u200B";
var mongolianVowelSeparator = "\u180E";
var polyfill$3 = function getPolyfill() {
  if (String.prototype.trim && zeroWidthSpace.trim() === zeroWidthSpace && mongolianVowelSeparator.trim() === mongolianVowelSeparator && ("_" + mongolianVowelSeparator).trim() === "_" + mongolianVowelSeparator && (mongolianVowelSeparator + "_").trim() === mongolianVowelSeparator + "_") {
    return String.prototype.trim;
  }
  return implementation$7;
};
var define$5 = defineProperties_1;
var getPolyfill$5 = polyfill$3;
var shim$5 = function shimStringTrim() {
  var polyfill2 = getPolyfill$5();
  define$5(String.prototype, { trim: polyfill2 }, {
    trim: function testTrim() {
      return String.prototype.trim !== polyfill2;
    }
  });
  return polyfill2;
};
var callBind$2 = callBind$5.exports;
var define$4 = defineProperties_1;
var RequireObjectCoercible$2 = RequireObjectCoercible$4;
var implementation$6 = implementation$8;
var getPolyfill$4 = polyfill$3;
var shim$4 = shim$5;
var bound$1 = callBind$2(getPolyfill$4());
var boundMethod = function trim2(receiver) {
  RequireObjectCoercible$2(receiver);
  return bound$1(receiver);
};
define$4(boundMethod, {
  getPolyfill: getPolyfill$4,
  implementation: implementation$6,
  shim: shim$4
});
var string_prototype_trim = boundMethod;
var GetIntrinsic$4 = getIntrinsic;
var $Number$1 = GetIntrinsic$4("%Number%");
var $RegExp = GetIntrinsic$4("%RegExp%");
var $TypeError$2 = GetIntrinsic$4("%TypeError%");
var $parseInteger = GetIntrinsic$4("%parseInt%");
var callBound$2 = callBound$b;
var regexTester2 = safeRegexTest;
var $strSlice = callBound$2("String.prototype.slice");
var isBinary = regexTester2(/^0b[01]+$/i);
var isOctal = regexTester2(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester2(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ["\x85", "\u200B", "\uFFFE"].join("");
var nonWSregex = new $RegExp("[" + nonWS + "]", "g");
var hasNonWS = regexTester2(nonWSregex);
var $trim = string_prototype_trim;
var Type$2 = Type$g;
var StringToNumber$1 = function StringToNumber(argument) {
  if (Type$2(argument) !== "String") {
    throw new $TypeError$2("Assertion failed: `argument` is not a String");
  }
  if (isBinary(argument)) {
    return $Number$1($parseInteger($strSlice(argument, 2), 2));
  }
  if (isOctal(argument)) {
    return $Number$1($parseInteger($strSlice(argument, 2), 8));
  }
  if (hasNonWS(argument) || isInvalidHexLiteral(argument)) {
    return NaN;
  }
  var trimmed = $trim(argument);
  if (trimmed !== argument) {
    return StringToNumber(trimmed);
  }
  return $Number$1(argument);
};
var GetIntrinsic$3 = getIntrinsic;
var $TypeError$1 = GetIntrinsic$3("%TypeError%");
var $Number = GetIntrinsic$3("%Number%");
var isPrimitive3 = isPrimitive$4;
var ToPrimitive3 = ToPrimitive$1;
var StringToNumber2 = StringToNumber$1;
var ToNumber$1 = function ToNumber(argument) {
  var value = isPrimitive3(argument) ? argument : ToPrimitive3(argument, $Number);
  if (typeof value === "symbol") {
    throw new $TypeError$1("Cannot convert a Symbol value to a number");
  }
  if (typeof value === "bigint") {
    throw new $TypeError$1("Conversion from 'BigInt' to 'number' is not allowed.");
  }
  if (typeof value === "string") {
    return StringToNumber2(value);
  }
  return $Number(value);
};
var Type$1 = Type$g;
var $floor = Math.floor;
var floor$1 = function floor(x2) {
  if (Type$1(x2) === "BigInt") {
    return x2;
  }
  return $floor(x2);
};
var GetIntrinsic$2 = getIntrinsic;
var floor2 = floor$1;
var $TypeError = GetIntrinsic$2("%TypeError%");
var truncate$1 = function truncate(x2) {
  if (typeof x2 !== "number" && typeof x2 !== "bigint") {
    throw new $TypeError("argument must be a Number or a BigInt");
  }
  var result = x2 < 0 ? -floor2(-x2) : floor2(x2);
  return result === 0 ? 0 : result;
};
var modulo2 = modulo$1;
var ToNumber2 = ToNumber$1;
var truncate2 = truncate$1;
var isFinite$1 = _isFinite;
var two32 = 4294967296;
var ToUint32$1 = function ToUint32(argument) {
  var number = ToNumber2(argument);
  if (!isFinite$1(number) || number === 0) {
    return 0;
  }
  var int = truncate2(number);
  var int32bit = modulo2(int, two32);
  return int32bit === 0 ? 0 : int32bit;
};
var GetIntrinsic$1 = getIntrinsic;
var $Object = GetIntrinsic$1("%Object%");
var RequireObjectCoercible$1 = RequireObjectCoercible$4;
var ToObject$1 = function ToObject(value) {
  RequireObjectCoercible$1(value);
  return $Object(value);
};
var ArraySpeciesCreate2 = ArraySpeciesCreate$1;
var Call2 = Call$1;
var CreateDataPropertyOrThrow2 = CreateDataPropertyOrThrow$1;
var Get2 = Get$2;
var HasProperty2 = HasProperty$1;
var IsCallable = IsCallable$2;
var ToUint322 = ToUint32$1;
var ToObject2 = ToObject$1;
var ToString2 = ToString$2;
var callBound$1 = callBound$b;
var isString2 = isString$2;
var boxedString = Object("a");
var splitString = boxedString[0] !== "a" || !(0 in boxedString);
var strSplit = callBound$1("String.prototype.split");
var implementation$5 = function map(callbackfn) {
  var O = ToObject2(this);
  var self2 = splitString && isString2(O) ? strSplit(O, "") : O;
  var len = ToUint322(self2.length);
  if (!IsCallable(callbackfn)) {
    throw new TypeError("Array.prototype.map callback must be a function");
  }
  var T;
  if (arguments.length > 1) {
    T = arguments[1];
  }
  var A = ArraySpeciesCreate2(O, len);
  var k2 = 0;
  while (k2 < len) {
    var Pk = ToString2(k2);
    var kPresent = HasProperty2(O, Pk);
    if (kPresent) {
      var kValue = Get2(O, Pk);
      var mappedValue = Call2(callbackfn, T, [kValue, k2, O]);
      CreateDataPropertyOrThrow2(A, Pk, mappedValue);
    }
    k2 += 1;
  }
  return A;
};
var esArrayMethodBoxesProperly = function properlyBoxed(method) {
  var properlyBoxesNonStrict = true;
  var properlyBoxesStrict = true;
  var threwException = false;
  if (typeof method === "function") {
    try {
      method.call("f", function(_, __, O) {
        if (typeof O !== "object") {
          properlyBoxesNonStrict = false;
        }
      });
      method.call(
        [null],
        function() {
          "use strict";
          properlyBoxesStrict = typeof this === "string";
        },
        "x"
      );
    } catch (e2) {
      threwException = true;
    }
    return !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
  }
  return false;
};
var arrayMethodBoxesProperly = esArrayMethodBoxesProperly;
var implementation$4 = implementation$5;
var polyfill$2 = function getPolyfill2() {
  var method = Array.prototype.map;
  return arrayMethodBoxesProperly(method) ? method : implementation$4;
};
var define$3 = defineProperties_1;
var getPolyfill$3 = polyfill$2;
var shim$3 = function shimArrayPrototypeMap() {
  var polyfill2 = getPolyfill$3();
  define$3(
    Array.prototype,
    { map: polyfill2 },
    { map: function() {
      return Array.prototype.map !== polyfill2;
    } }
  );
  return polyfill2;
};
var define$2 = defineProperties_1;
var RequireObjectCoercible = RequireObjectCoercible$4;
var callBound = callBound$b;
var implementation$3 = implementation$5;
var getPolyfill$2 = polyfill$2;
var polyfill$1 = getPolyfill$2();
var shim$2 = shim$3;
var $slice = callBound("Array.prototype.slice");
var boundMapShim = function map2(array, callbackfn) {
  RequireObjectCoercible(array);
  return polyfill$1.apply(array, $slice(arguments, 1));
};
define$2(boundMapShim, {
  getPolyfill: getPolyfill$2,
  implementation: implementation$3,
  shim: shim$2
});
var array_prototype_map = boundMapShim;
var requirePromise$3 = requirePromise$4;
requirePromise$3();
var PromiseResolve2 = PromiseResolve$1;
var Type3 = Type$g;
var iterate = iterateValue;
var map3 = array_prototype_map;
var GetIntrinsic2 = getIntrinsic;
var callBind$1 = callBind$5.exports;
var all = callBind$1(GetIntrinsic2("%Promise.all%"));
var reject = callBind$1(GetIntrinsic2("%Promise.reject%"));
var implementation$2 = function allSettled2(iterable) {
  var C = this;
  if (Type3(C) !== "Object") {
    throw new TypeError("`this` value must be an object");
  }
  var values = iterate(iterable);
  return all(C, map3(values, function(item) {
    var onFulfill = function(value) {
      return { status: "fulfilled", value };
    };
    var onReject = function(reason) {
      return { status: "rejected", reason };
    };
    var itemPromise = PromiseResolve2(C, item);
    try {
      return itemPromise.then(onFulfill, onReject);
    } catch (e2) {
      return reject(C, e2);
    }
  }));
};
var requirePromise$2 = requirePromise$4;
var implementation$1 = implementation$2;
var polyfill = function getPolyfill3() {
  requirePromise$2();
  return typeof Promise.allSettled === "function" ? Promise.allSettled : implementation$1;
};
var requirePromise$1 = requirePromise$4;
var getPolyfill$1 = polyfill;
var define$1 = defineProperties_1;
var shim$1 = function shimAllSettled() {
  requirePromise$1();
  var polyfill2 = getPolyfill$1();
  define$1(Promise, { allSettled: polyfill2 }, {
    allSettled: function testAllSettled() {
      return Promise.allSettled !== polyfill2;
    }
  });
  return polyfill2;
};
var callBind = callBind$5.exports;
var define = defineProperties_1;
var requirePromise2 = requirePromise$4;
var implementation = implementation$2;
var getPolyfill4 = polyfill;
var shim = shim$1;
requirePromise2();
var bound = callBind(getPolyfill4());
var rebindable = function allSettled3(iterable) {
  return bound(typeof this === "undefined" ? Promise : this, iterable);
};
define(rebindable, {
  getPolyfill: getPolyfill4,
  implementation,
  shim
});
var promise_allsettled = rebindable;
class LoaderPixi {
  constructor({ optimize }) {
    this.optimize = optimize;
    this.loader = new Loader();
    this.resolveLoaderComplete = null;
    this.onLoaderComplete = new Promise(
      (resolve2) => this.resolveLoaderComplete = resolve2
    );
    this.fonts = [];
    this.customFonts = null;
    this.jsons = [];
    this.jsonMap = /* @__PURE__ */ new Map();
    this.spritesheets = [];
    this.callback = null;
  }
  addManifest(manifests) {
    manifests.forEach((file) => {
      const isSpritesheet = file.src.includes("json");
      if (isSpritesheet) {
        let imageName = file.src.replace(".json", ".png");
        this.jsons.push(file.src);
        this.loader.add(imageName, imageName);
        this.spritesheets.push(imageName);
      } else {
        this.loader.add(file.src, file.src);
      }
    });
  }
  addOthers(others) {
    others.map((asset2) => {
      console.log(asset2.id || asset2.src, asset2.src);
      this.loader.add(asset2.id || asset2.src, asset2.src);
    });
  }
  addFonts(fonts) {
    this.fonts.push(...fonts);
  }
  addCustomFonts(customFonts) {
    this.customFonts = customFonts;
  }
  loadFonts() {
    return new Promise((resolve2) => {
      let fontLoadingPromises = [];
      let fontLoadingHandlers = {};
      const onAllLoading = async () => {
        promise_allsettled(fontLoadingPromises).then(() => {
          resolve2();
        });
      };
      const config = {
        loading: () => {
          onAllLoading();
        },
        fontloading: (familyName) => {
          fontLoadingPromises.push(
            new Promise((resolve3, reject2) => {
              fontLoadingHandlers[familyName] = { resolve: resolve3, reject: reject2 };
            })
          );
        },
        fontactive: (familyName) => {
          fontLoadingHandlers[familyName].resolve();
        },
        fontinactive: (familyName) => {
          console.error(`font ${familyName} failed to load`);
          fontLoadingHandlers[familyName].reject();
        }
      };
      if (this.fonts.length) {
        config.google = {
          families: this.fonts
        };
      }
      if (this.customFonts) {
        config.custom = this.customFonts;
      }
      WebFont.load(config);
    });
  }
  load(cb) {
    this.callback = cb;
    this.loadFonts().then(() => {
      this.loader.load(this.onComplete.bind(this));
    });
  }
  async onComplete(loader, r2) {
    await this.loadJsons();
    this.resizeTextures(r2);
    this.createSpritesheets(r2);
    this.resolveLoaderComplete();
  }
  async loadJsons() {
    for (let i = 0; i < this.jsons.length; i++) {
      const url2 = this.jsons[i];
      let imageName = url2.replace(".json", ".png");
      const response = await fetch(url2);
      const json = await response.json();
      this.jsonMap.set(imageName, json);
    }
  }
  resizeTextures(textures) {
    for (const i in textures) {
      const texture = textures[i];
      let id = i;
      if (texture.tags && texture.tags.tps) {
        id = `${id}_image`;
      }
      const baseTexture = BaseTextureCache[id];
      if (baseTexture) {
        if (texture.tags) {
          if (texture.tags.REPEAT) {
            baseTexture.wrapMode = WRAP_MODES.REPEAT;
          }
          if (texture.tags.NEAREST) {
            baseTexture.scaleMode = SCALE_MODES.NEAREST;
          }
        }
        if (this.optimize) {
          if (!texture.tags || texture.tags && !texture.tags.high) {
            baseTexture.type = TYPES.UNSIGNED_SHORT_4_4_4_4;
          }
        }
        renderer.texture.bind(baseTexture);
      }
    }
  }
  createSpritesheets() {
    let promises = [];
    this.spritesheets.forEach((imageName) => {
      promises.push(
        new Promise((resolve2) => {
          const sprites = new Spritesheet(
            TextureCache[imageName].baseTexture,
            this.jsonMap.get(imageName)
          );
          sprites.parse(() => {
            resolve2();
          });
        })
      );
    });
    Promise.all(promises).then((results) => {
      this.callback && this.callback();
    }).catch((e2) => {
      console.log("AssetsLoader", e2.message, e2);
    });
  }
}
class AbstractScene {
  constructor(config = {}, thumbnailAt) {
    this.view = new Container();
  }
  resize(w2, h2) {
    this.w = app.screen.width;
    this.h = app.screen.height;
    this.isPortrait = this.w < this.h;
    this.onResize(this.w, this.h);
  }
  update() {
  }
  pause() {
    this.paused = true;
    this.onPause();
  }
  resume() {
    this.paused = false;
    this.onResume();
  }
  show() {
    this.onShow();
  }
  hide() {
    this.onHide();
  }
  onShow() {
  }
  onPause() {
  }
  onResume() {
  }
  onResize(w2, h2) {
  }
  onHide() {
  }
}
var encode_decode = `

bool isPowerOfTwo(float x) {
    // Check if x is greater than 0 and is a power of two
    return x > 0.0 && (x == exp2(floor(log2(x))));
}

float shiftRight (float v, float amt) {
    v = floor(v) + 0.5;
    return floor(v / exp2(amt));
  }
  float shiftLeft (float v, float amt) {
      return floor(v * exp2(amt) + 0.5);
  }
  float maskLast (float v, float bits) {
      return mod(v, shiftLeft(1.0, bits));
  }
  float extractBits (float num, float from, float to) {
      from = floor(from + 0.5); to = floor(to + 0.5);
      return maskLast(shiftRight(num, from), to - from);
  }
  vec4 encode_float(float texelFloat, bool littleEndian) {

      if (texelFloat == 0.0) return vec4(0, 0, 0, 0);

      if (isPowerOfTwo(texelFloat)) {
        texelFloat += 0.001;
      }
      float sign = texelFloat > 0.0 ? 0.0 : 1.0;
      texelFloat = abs(texelFloat);
      float exponent = floor(log2(texelFloat));
      float biased_exponent = exponent + 127.0;
      float fraction = ((texelFloat / exp2(exponent)) - 1.0) * 8388608.0;
      float t = biased_exponent / 2.0;
      float last_bit_of_biased_exponent = fract(t) * 2.0;
      float remaining_bits_of_biased_exponent = floor(t);
      float byte4 = extractBits(fraction, 0.0, 8.0) / 255.0;
      float byte3 = extractBits(fraction, 8.0, 16.0) / 255.0;
      float byte2 = (last_bit_of_biased_exponent * 128.0 + extractBits(fraction, 16.0, 23.0)) / 255.0;
      float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;
      return (
        littleEndian
        ? vec4(byte4, byte3, byte2, byte1)
        : vec4(byte1, byte2, byte3, byte4)
      );
  }

  float decode_float(vec4 v) {
  vec4 bits = v * 255.0;
  float sign = mix(-1.0, 1.0, step(bits[3], 128.0));
  float expo = floor(mod(bits[3] + 0.1, 128.0)) * 2.0 +
               floor((bits[2] + 0.1) / 128.0) - 127.0;
  float sig = bits[0] +
              bits[1] * 256.0 +
              floor(mod(bits[2] + 0.1, 128.0)) * 256.0 * 256.0;
  return sign * (1.0 + sig / 8388607.0) * pow(2.0, expo);
}





`;
var frag$4 = `
// precision mediump float;

varying float vParticlePos;


${encode_decode}


void main()
{
    // float value = vParticlePos.x;
    float value = vParticlePos;
    value = floor(value * 100.) / 100. + 0.01;
    vec4 encoded = encode_float(value, true);


    gl_FragColor = encoded; // Store the encoded values
    // gl_FragColor.a = 1.;
}
`;
var vert$4 = `
// precision mediump float;
attribute float aParticlePos;
attribute vec2 aVertexPosition;


uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
varying float vParticlePos;

void main(void)
{
  vParticlePos = aParticlePos;
    
  
  gl_Position=vec4(aVertexPosition, 0., 1.);

  gl_PointSize = 1.;
}
`;
class PositionShader {
  constructor() {
    this.material = Shader.from(vert$4, frag$4, {});
    this.geometry = new Geometry();
    this.mesh = new Mesh(
      this.geometry,
      this.material,
      void 0,
      DRAW_MODES.POINTS
    );
    this.geometry.addAttribute("aVertexPosition", [0, 0], 2).addAttribute("aParticlePos", [0], 1).addIndex([0]);
  }
  draw(particles, cols, rows) {
    const positions = [];
    const particlePositions = [];
    const indices3 = [];
    let count = 0;
    let pX, pY;
    const totalParticles = particles.length;
    for (let j2 = 0; j2 < rows; j2++) {
      for (let i = 0; i < cols; i++) {
        let particle = particles[count];
        if (count >= totalParticles) {
          break;
        }
        particlePositions.push(particle);
        pX = i / cols * 2 - 1 + 0.5 / cols;
        pY = j2 / rows * 2 - 1 + 0.5 / rows;
        positions.push(pX, pY);
        indices3.push(count);
        count++;
      }
    }
    this.geometry.getBuffer("aVertexPosition").update(new Float32Array(positions));
    this.geometry.getBuffer("aParticlePos").update(new Float32Array(particlePositions));
    this.geometry.getIndex().update(new Uint16Array(indices3));
  }
}
var frag$3 = `
uniform sampler2D uMap;
uniform sampler2D texturePositions;
varying vec2 vTextureCoord;


void main () {

  vec2 uv = vec2(vTextureCoord.x, vTextureCoord.y);
  vec4 ownColor = texture2D(uMap, uv);

  float alpha = ownColor.a;
  gl_FragColor = vec4(ownColor.rgb, alpha);
  gl_FragColor *= alpha;

}
`;
var vert$3 = `
attribute float aScale;
attribute vec3 aExtra;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec2 aTextureCoordPosition;

uniform float uTime;
uniform float uAngle;
uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform float uPointSize;
varying vec2 vTextureCoord;

uniform float uSize;
uniform sampler2D texturePositions;


vec2 getBaseTextureCoordinates (float index) {
    return (
        vec2(floor(mod(index + 0.5, uSize)), 
        floor((index + 0.5) / uSize)
    ) + 0.5) / uSize;
}

${encode_decode}



#define PI 3.141592653589793

vec2 rotate(vec2 v, float a) {
	float s = sin(a);
	float c = cos(a);
	mat2 m = mat2(c, -s, s, c);
	return m * v;
}

void main(void)
{

  vTextureCoord = aTextureCoord;

  vec2 uvX = getBaseTextureCoordinates(aTextureCoordPosition.x);
  vec2 uvY = getBaseTextureCoordinates(aTextureCoordPosition.y);
  vec4 centerEncodedX = texture2D(texturePositions, uvX);
  vec4 centerEncodedY = texture2D(texturePositions, uvY);
  
  
  float centerValueX = decode_float(centerEncodedX);
  float centerValueY = decode_float(centerEncodedY);

  vec2 position = aVertexPosition.xy;

  float angle = cos(uTime / 20. + aExtra.x / 40.) * 0.2 * uAngle;
  position -= vec2(0.5);
  position = rotate(position, angle);
  position += vec2(0.5);

  float size = uPointSize * aScale;
  gl_Position= vec4(
    (
      projectionMatrix*translationMatrix*
      vec3(
        vec2(centerValueX, centerValueY) 
        + position * size, 
        1.
      )
    ).xy,
    0.,
    1.
  );

}
`;
const formatText = (text) => {
  text = text || "";
  return text.replaceAll("\\n", "\n");
};
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal || freeSelf || Function("return this")();
var _root = root$1;
var root = _root;
var Symbol$4 = root.Symbol;
var _Symbol = Symbol$4;
function arrayMap$1(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var _arrayMap = arrayMap$1;
var isArray$3 = Array.isArray;
var isArray_1 = isArray$3;
var Symbol$3 = _Symbol;
var objectProto$1 = Object.prototype;
var hasOwnProperty = objectProto$1.hasOwnProperty;
var nativeObjectToString$1 = objectProto$1.toString;
var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto = Object.prototype;
var nativeObjectToString = objectProto.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag$3(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$3;
function isObjectLike$2(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$2;
var baseGetTag$2 = _baseGetTag, isObjectLike$1 = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike$1(value) && baseGetTag$2(value) == symbolTag;
}
var isSymbol_1 = isSymbol$1;
var Symbol$1 = _Symbol, arrayMap = _arrayMap, isArray$2 = isArray_1, isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$2(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$2(value)) {
    return arrayMap(value, baseToString$2) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _baseToString = baseToString$2;
function baseSlice$1(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
var _baseSlice = baseSlice$1;
var baseSlice = _baseSlice;
function castSlice$1(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice(array, start, end);
}
var _castSlice = castSlice$1;
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode$2(string) {
  return reHasUnicode.test(string);
}
var _hasUnicode = hasUnicode$2;
function eq$1(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$1;
function isObject$3(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var isObject_1 = isObject$3;
var baseGetTag$1 = _baseGetTag, isObject$2 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject$2(value)) {
    return false;
  }
  var tag = baseGetTag$1(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$1;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$1(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$1;
var isFunction = isFunction_1, isLength = isLength_1;
function isArrayLike$1(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
var isArrayLike_1 = isArrayLike$1;
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value, length) {
  var type2 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$1;
var eq = eq_1, isArrayLike = isArrayLike_1, isIndex = _isIndex, isObject$1 = isObject_1;
function isIterateeCall$1(value, index, object) {
  if (!isObject$1(object)) {
    return false;
  }
  var type2 = typeof index;
  if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
    return eq(object[index], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$1;
var baseGetTag = _baseGetTag, isObjectLike = isObjectLike_1;
var regexpTag = "[object RegExp]";
function baseIsRegExp$1(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}
var _baseIsRegExp = baseIsRegExp$1;
function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsRegExp = _baseIsRegExp, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
var isRegExp$1 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
var isRegExp_1 = isRegExp$1;
function asciiToArray$1(string) {
  return string.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray$1(string) {
  return string.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray, hasUnicode$1 = _hasUnicode, unicodeToArray = _unicodeToArray;
function stringToArray$1(string) {
  return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);
}
var _stringToArray = stringToArray$1;
var baseToString$1 = _baseToString;
function toString$1(value) {
  return value == null ? "" : baseToString$1(value);
}
var toString_1 = toString$1;
var baseToString = _baseToString, castSlice = _castSlice, hasUnicode = _hasUnicode, isIterateeCall = _isIterateeCall, isRegExp2 = isRegExp_1, stringToArray = _stringToArray, toString = toString_1;
var MAX_ARRAY_LENGTH = 4294967295;
function split(string, separator, limit) {
  if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
    separator = limit = void 0;
  }
  limit = limit === void 0 ? MAX_ARRAY_LENGTH : limit >>> 0;
  if (!limit) {
    return [];
  }
  string = toString(string);
  if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
    separator = baseToString(separator);
    if (!separator && hasUnicode(string)) {
      return castSlice(stringToArray(string), 0, limit);
    }
  }
  return string.split(separator, limit);
}
var split_1 = split;
const segmenter = (Intl == null ? void 0 : Intl.Segmenter) && new Intl.Segmenter();
const segmentText = (text) => {
  return split_1 ? split_1(text, "") : segmenter ? [...segmenter.segment(text)].map((x2) => x2.segment) : Array.from ? Array.from(text) : text.split("");
};
const a = {
  points: [
    [
      [
        -51,
        54.33
      ],
      [
        -51,
        54.33
      ],
      [
        -51,
        43.33
      ],
      [
        -51,
        32.33
      ],
      [
        -51,
        21.33
      ],
      [
        -51,
        10.33
      ],
      [
        -51,
        -0.67
      ],
      [
        -51,
        -0.67
      ],
      [
        -51,
        -0.67
      ],
      [
        -49.99,
        -10.14
      ],
      [
        -48.98,
        -19.61
      ],
      [
        -47.96,
        -29.08
      ],
      [
        -47.96,
        -29.08
      ],
      [
        -43.88,
        -36.65
      ],
      [
        -39.79,
        -44.21
      ],
      [
        -39.79,
        -44.21
      ],
      [
        -31.7,
        -48.66
      ],
      [
        -23.6,
        -53.1
      ],
      [
        -11.67,
        -54.34
      ],
      [
        -11.67,
        -54.34
      ],
      [
        -11.67,
        -54.34
      ],
      [
        -5.63,
        -53.74
      ],
      [
        0.4,
        -53.14
      ],
      [
        0.4,
        -53.14
      ],
      [
        8.95,
        -48.86
      ],
      [
        17.5,
        -44.58
      ],
      [
        17.5,
        -44.58
      ],
      [
        22.2,
        -37.29
      ],
      [
        26.9,
        -30.01
      ],
      [
        26.9,
        -30.01
      ],
      [
        28.26,
        -20.89
      ],
      [
        29.63,
        -11.78
      ],
      [
        31,
        -2.67
      ],
      [
        31,
        -2.67
      ],
      [
        31,
        8.73
      ],
      [
        31,
        20.13
      ],
      [
        31,
        31.53
      ],
      [
        31,
        42.93
      ],
      [
        31,
        54.33
      ]
    ],
    [
      [
        -47.01,
        12.33
      ],
      [
        -47.01,
        12.33
      ],
      [
        -36.12,
        12.33
      ],
      [
        -25.23,
        12.33
      ],
      [
        -14.34,
        12.33
      ],
      [
        -3.45,
        12.33
      ],
      [
        7.44,
        12.33
      ],
      [
        18.33,
        12.33
      ],
      [
        29.22,
        12.33
      ],
      [
        40.11,
        12.33
      ],
      [
        50.99,
        12.33
      ]
    ]
  ],
  meta: {
    width: 101.9998,
    height: 108.66659999999999
  }
};
const b = {
  points: [
    [
      [
        -36,
        61.52
      ],
      [
        -36,
        61.52
      ],
      [
        -36,
        50.34
      ],
      [
        -36,
        39.16
      ],
      [
        -36,
        27.98
      ],
      [
        -36,
        16.8
      ],
      [
        -36,
        5.62
      ],
      [
        -36,
        -5.57
      ],
      [
        -36,
        -16.75
      ],
      [
        -36,
        -27.93
      ],
      [
        -36,
        -39.11
      ],
      [
        -36,
        -50.29
      ],
      [
        -36,
        -61.48
      ],
      [
        -36,
        -61.48
      ],
      [
        -36,
        -61.48
      ],
      [
        -27.17,
        -61.5
      ],
      [
        -18.33,
        -61.51
      ],
      [
        -9.49,
        -61.53
      ],
      [
        -9.49,
        -61.53
      ],
      [
        -1.35,
        -59.68
      ],
      [
        6.79,
        -57.82
      ],
      [
        6.79,
        -57.82
      ],
      [
        12.94,
        -53.26
      ],
      [
        19.09,
        -48.71
      ],
      [
        23,
        -41.48
      ],
      [
        23,
        -41.48
      ],
      [
        23,
        -41.48
      ],
      [
        23.71,
        -33.41
      ],
      [
        24.42,
        -25.34
      ],
      [
        24.42,
        -25.34
      ],
      [
        20.77,
        -18.34
      ],
      [
        17.12,
        -11.35
      ],
      [
        17.12,
        -11.35
      ],
      [
        9.44,
        -6.51
      ],
      [
        1.76,
        -1.68
      ],
      [
        1.76,
        -1.68
      ],
      [
        -9.62,
        -0.08
      ],
      [
        -21,
        1.52
      ],
      [
        -21,
        1.52
      ],
      [
        -21,
        1.52
      ],
      [
        -12.06,
        2.33
      ],
      [
        -3.12,
        3.14
      ],
      [
        5.82,
        3.95
      ],
      [
        5.82,
        3.95
      ],
      [
        14.53,
        6.79
      ],
      [
        23.23,
        9.63
      ],
      [
        23.23,
        9.63
      ],
      [
        28.8,
        14.86
      ],
      [
        34.37,
        20.09
      ],
      [
        36,
        27.52
      ],
      [
        36,
        27.52
      ],
      [
        36,
        27.52
      ],
      [
        33.96,
        35.66
      ],
      [
        31.93,
        43.81
      ],
      [
        31.93,
        43.81
      ],
      [
        25.96,
        49.04
      ],
      [
        20,
        54.27
      ],
      [
        20,
        54.27
      ],
      [
        10.28,
        57.07
      ],
      [
        0.56,
        59.87
      ],
      [
        0.56,
        59.87
      ],
      [
        -8.3,
        60.42
      ],
      [
        -17.15,
        60.97
      ],
      [
        -26,
        61.52
      ]
    ]
  ],
  meta: {
    width: 72,
    height: 123.0586072265625
  }
};
const c$1 = {
  points: [
    [
      [
        40.5,
        -35.5
      ],
      [
        40.5,
        -35.5
      ],
      [
        40.5,
        -35.5
      ],
      [
        34.66,
        -42.3
      ],
      [
        28.83,
        -49.09
      ],
      [
        23,
        -55.88
      ],
      [
        23,
        -55.88
      ],
      [
        11.25,
        -58.19
      ],
      [
        -0.5,
        -60.5
      ],
      [
        -0.5,
        -60.5
      ],
      [
        -0.5,
        -60.5
      ],
      [
        -7.07,
        -59.62
      ],
      [
        -13.64,
        -58.74
      ],
      [
        -13.64,
        -58.74
      ],
      [
        -22.76,
        -52.69
      ],
      [
        -31.88,
        -46.64
      ],
      [
        -31.88,
        -46.64
      ],
      [
        -36.72,
        -37.09
      ],
      [
        -41.55,
        -27.55
      ],
      [
        -41.55,
        -27.55
      ],
      [
        -42.87,
        -17.53
      ],
      [
        -44.19,
        -7.52
      ],
      [
        -45.5,
        2.5
      ],
      [
        -45.5,
        2.5
      ],
      [
        -45.5,
        2.5
      ],
      [
        -43.91,
        11.98
      ],
      [
        -42.31,
        21.47
      ],
      [
        -40.71,
        30.95
      ],
      [
        -40.71,
        30.95
      ],
      [
        -35.51,
        39.58
      ],
      [
        -30.32,
        48.21
      ],
      [
        -30.32,
        48.21
      ],
      [
        -21.21,
        53.58
      ],
      [
        -12.1,
        58.95
      ],
      [
        -12.1,
        58.95
      ],
      [
        -5.8,
        59.72
      ],
      [
        0.5,
        60.5
      ],
      [
        0.5,
        60.5
      ],
      [
        0.5,
        60.5
      ],
      [
        9.28,
        59.35
      ],
      [
        18.07,
        58.21
      ],
      [
        18.07,
        58.21
      ],
      [
        24.47,
        54.73
      ],
      [
        30.87,
        51.25
      ],
      [
        30.87,
        51.25
      ],
      [
        35.3,
        45.32
      ],
      [
        39.73,
        39.4
      ],
      [
        39.73,
        39.4
      ],
      [
        42.61,
        30.95
      ],
      [
        45.5,
        22.5
      ]
    ]
  ],
  meta: {
    width: 91,
    height: 121
  }
};
const d = {
  points: [
    [
      [
        -41,
        61.5
      ],
      [
        -41,
        61.5
      ],
      [
        -41,
        50.31
      ],
      [
        -41,
        39.13
      ],
      [
        -41,
        27.95
      ],
      [
        -41,
        16.77
      ],
      [
        -41,
        5.59
      ],
      [
        -41,
        -5.6
      ],
      [
        -41,
        -16.78
      ],
      [
        -41,
        -27.96
      ],
      [
        -41,
        -39.14
      ],
      [
        -41,
        -50.32
      ],
      [
        -41,
        -61.5
      ],
      [
        -41,
        -61.5
      ],
      [
        -41,
        -61.5
      ],
      [
        -32.04,
        -59.79
      ],
      [
        -23.07,
        -58.07
      ],
      [
        -14.1,
        -56.35
      ],
      [
        -5.13,
        -54.63
      ],
      [
        -5.13,
        -54.63
      ],
      [
        4.91,
        -48.25
      ],
      [
        14.95,
        -41.88
      ],
      [
        25,
        -35.5
      ],
      [
        25,
        -35.5
      ],
      [
        25,
        -35.5
      ],
      [
        30.16,
        -27.46
      ],
      [
        35.33,
        -19.42
      ],
      [
        40.5,
        -11.38
      ],
      [
        40.5,
        -11.38
      ],
      [
        40.66,
        -0.09
      ],
      [
        40.83,
        11.2
      ],
      [
        41,
        22.5
      ],
      [
        41,
        22.5
      ],
      [
        41,
        22.5
      ],
      [
        37.61,
        30.94
      ],
      [
        34.22,
        39.39
      ],
      [
        34.22,
        39.39
      ],
      [
        27.5,
        45.49
      ],
      [
        20.78,
        51.59
      ],
      [
        20.78,
        51.59
      ],
      [
        10.74,
        55.3
      ],
      [
        0.7,
        59
      ],
      [
        0.7,
        59
      ],
      [
        -8.2,
        59.83
      ],
      [
        -17.1,
        60.66
      ],
      [
        -26,
        61.5
      ]
    ]
  ],
  meta: {
    width: 82,
    height: 123
  }
};
const e = {
  points: [
    [
      [
        41,
        -54.34
      ],
      [
        41,
        -54.34
      ],
      [
        41,
        -54.34
      ],
      [
        30.61,
        -54.42
      ],
      [
        20.23,
        -54.5
      ],
      [
        9.85,
        -54.59
      ],
      [
        -0.53,
        -54.67
      ],
      [
        -0.53,
        -54.67
      ],
      [
        -9.12,
        -52.23
      ],
      [
        -17.71,
        -49.78
      ],
      [
        -26.31,
        -47.34
      ],
      [
        -34.1,
        -39.52
      ],
      [
        -34.1,
        -39.52
      ],
      [
        -36.51,
        -33.88
      ],
      [
        -38.93,
        -28.25
      ],
      [
        -38.93,
        -28.25
      ],
      [
        -39.62,
        -16.61
      ],
      [
        -40.31,
        -4.97
      ],
      [
        -41,
        6.66
      ],
      [
        -41,
        6.66
      ],
      [
        -41,
        6.66
      ],
      [
        -39.48,
        15.2
      ],
      [
        -37.96,
        23.73
      ],
      [
        -36.44,
        32.26
      ],
      [
        -36.44,
        32.26
      ],
      [
        -31.42,
        39.58
      ],
      [
        -26.4,
        46.9
      ],
      [
        -26.4,
        46.9
      ],
      [
        -15.83,
        50.7
      ],
      [
        -5.25,
        54.51
      ],
      [
        -5.25,
        54.51
      ],
      [
        6.31,
        54.55
      ],
      [
        17.87,
        54.59
      ],
      [
        29.43,
        54.63
      ],
      [
        41,
        54.66
      ]
    ],
    [
      [
        38,
        1.66
      ],
      [
        38,
        1.66
      ],
      [
        26,
        1.66
      ],
      [
        14,
        1.66
      ],
      [
        2,
        1.66
      ],
      [
        -10,
        1.66
      ],
      [
        -22,
        1.66
      ]
    ]
  ],
  meta: {
    width: 82,
    height: 109.33997812499999
  }
};
const f = {
  points: [
    [
      [
        40.34,
        -56.4
      ],
      [
        40.34,
        -56.4
      ],
      [
        40.34,
        -56.4
      ],
      [
        29.87,
        -56.44
      ],
      [
        19.41,
        -56.48
      ],
      [
        8.94,
        -56.53
      ],
      [
        -1.53,
        -56.57
      ],
      [
        -12,
        -56.61
      ],
      [
        -12,
        -56.61
      ],
      [
        -21.75,
        -51.82
      ],
      [
        -31.5,
        -47.03
      ],
      [
        -31.5,
        -47.03
      ],
      [
        -34.64,
        -40.88
      ],
      [
        -37.78,
        -34.72
      ],
      [
        -37.78,
        -34.72
      ],
      [
        -39.07,
        -25.79
      ],
      [
        -40.35,
        -16.86
      ],
      [
        -40.35,
        -16.86
      ],
      [
        -40.3,
        -6.37
      ],
      [
        -40.25,
        4.12
      ],
      [
        -40.2,
        14.62
      ],
      [
        -40.14,
        25.11
      ],
      [
        -40.09,
        35.61
      ],
      [
        -40.04,
        46.1
      ],
      [
        -39.99,
        56.6
      ]
    ],
    [
      [
        37.34,
        -0.4
      ],
      [
        37.34,
        -0.4
      ],
      [
        25.34,
        -0.4
      ],
      [
        13.34,
        -0.4
      ],
      [
        1.34,
        -0.4
      ],
      [
        -10.66,
        -0.4
      ],
      [
        -22.66,
        -0.4
      ]
    ]
  ],
  meta: {
    width: 80.69834716796868,
    height: 113.20304062499999
  }
};
const g = {
  points: [
    [
      [
        34.5,
        -40.84
      ],
      [
        34.5,
        -40.84
      ],
      [
        34.5,
        -40.84
      ],
      [
        27.27,
        -45.68
      ],
      [
        20.04,
        -50.51
      ],
      [
        12.82,
        -55.35
      ],
      [
        12.82,
        -55.35
      ],
      [
        5.73,
        -56.26
      ],
      [
        -1.36,
        -57.17
      ],
      [
        -1.36,
        -57.17
      ],
      [
        -8,
        -55.52
      ],
      [
        -14.64,
        -53.86
      ],
      [
        -14.64,
        -53.86
      ],
      [
        -23.11,
        -47.64
      ],
      [
        -31.58,
        -41.42
      ],
      [
        -31.58,
        -41.42
      ],
      [
        -35.81,
        -35.51
      ],
      [
        -40.04,
        -29.59
      ],
      [
        -40.04,
        -29.59
      ],
      [
        -42.53,
        -20.34
      ],
      [
        -45.02,
        -11.09
      ],
      [
        -47.5,
        -1.84
      ],
      [
        -47.5,
        -1.84
      ],
      [
        -47.5,
        -1.84
      ],
      [
        -46.23,
        6.58
      ],
      [
        -44.95,
        14.99
      ],
      [
        -43.68,
        23.41
      ],
      [
        -43.68,
        23.41
      ],
      [
        -38.53,
        32.66
      ],
      [
        -33.38,
        41.91
      ],
      [
        -33.38,
        41.91
      ],
      [
        -25.89,
        47.6
      ],
      [
        -18.4,
        53.29
      ],
      [
        -18.4,
        53.29
      ],
      [
        -9.45,
        55.22
      ],
      [
        -0.5,
        57.16
      ],
      [
        -0.5,
        57.16
      ],
      [
        -0.5,
        57.16
      ],
      [
        8.52,
        55.94
      ],
      [
        17.54,
        54.72
      ],
      [
        17.54,
        54.72
      ],
      [
        24.46,
        51.07
      ],
      [
        31.37,
        47.41
      ],
      [
        31.37,
        47.41
      ],
      [
        36.32,
        41.32
      ],
      [
        41.26,
        35.22
      ],
      [
        41.26,
        35.22
      ],
      [
        44.38,
        26.69
      ],
      [
        47.5,
        18.16
      ],
      [
        47.5,
        18.16
      ],
      [
        36.5,
        14.41
      ],
      [
        25.5,
        10.66
      ],
      [
        14.5,
        6.91
      ],
      [
        3.5,
        3.16
      ]
    ]
  ],
  meta: {
    width: 95,
    height: 114.33322553710937
  }
};
const h = {
  points: [
    [
      [
        30.54,
        -1
      ],
      [
        30.54,
        -1
      ],
      [
        18.54,
        -1
      ],
      [
        6.54,
        -1
      ],
      [
        -5.46,
        -1
      ],
      [
        -17.46,
        -1
      ],
      [
        -29.46,
        -1
      ]
    ],
    [
      [
        -35.52,
        -56
      ],
      [
        -35.52,
        -56
      ],
      [
        -35.52,
        -56
      ],
      [
        -36.14,
        -44.91
      ],
      [
        -36.76,
        -33.81
      ],
      [
        -37.38,
        -22.71
      ],
      [
        -38,
        -11.61
      ],
      [
        -38.62,
        -0.51
      ],
      [
        -38.62,
        -0.51
      ],
      [
        -38,
        10.79
      ],
      [
        -37.38,
        22.09
      ],
      [
        -36.76,
        33.39
      ],
      [
        -36.14,
        44.69
      ],
      [
        -35.52,
        56
      ]
    ],
    [
      [
        34.48,
        -56
      ],
      [
        34.48,
        -56
      ],
      [
        34.48,
        -56
      ],
      [
        35.51,
        -44.61
      ],
      [
        36.54,
        -33.22
      ],
      [
        37.58,
        -21.82
      ],
      [
        38.61,
        -10.43
      ],
      [
        38.61,
        -10.43
      ],
      [
        37.92,
        0.64
      ],
      [
        37.23,
        11.71
      ],
      [
        36.54,
        22.78
      ],
      [
        35.85,
        33.85
      ],
      [
        35.16,
        44.92
      ],
      [
        34.48,
        56
      ]
    ]
  ],
  meta: {
    width: 77.2327070312499,
    height: 112
  }
};
const i$1 = {
  points: [
    [
      [
        -1.39,
        -56
      ],
      [
        -1.39,
        -56
      ],
      [
        -1.39,
        -56
      ],
      [
        -0.84,
        -44.6
      ],
      [
        -0.28,
        -33.2
      ],
      [
        0.27,
        -21.8
      ],
      [
        0.83,
        -10.39
      ],
      [
        1.38,
        1.01
      ],
      [
        1.38,
        1.01
      ],
      [
        0.83,
        12.01
      ],
      [
        0.27,
        23
      ],
      [
        -0.28,
        34
      ],
      [
        -0.84,
        45
      ],
      [
        -1.39,
        56
      ]
    ]
  ],
  meta: {
    width: 2.7667499999997744,
    height: 112
  }
};
const j = {
  points: [
    [
      [
        -37.92,
        19
      ],
      [
        -37.92,
        19
      ],
      [
        -37.92,
        19
      ],
      [
        -34.81,
        27.44
      ],
      [
        -31.71,
        35.88
      ],
      [
        -28.61,
        44.33
      ],
      [
        -28.61,
        44.33
      ],
      [
        -23.13,
        48.39
      ],
      [
        -17.66,
        52.46
      ],
      [
        -17.66,
        52.46
      ],
      [
        -8.18,
        54.23
      ],
      [
        1.3,
        56
      ],
      [
        1.3,
        56
      ],
      [
        1.3,
        56
      ],
      [
        7.49,
        54.63
      ],
      [
        13.69,
        53.26
      ],
      [
        20.86,
        48.24
      ],
      [
        20.86,
        48.24
      ],
      [
        25,
        40.69
      ],
      [
        29.14,
        33.13
      ],
      [
        33.28,
        25.58
      ],
      [
        33.28,
        25.58
      ],
      [
        34.82,
        14.82
      ],
      [
        36.36,
        4.07
      ],
      [
        37.91,
        -6.68
      ],
      [
        37.91,
        -6.68
      ],
      [
        37.45,
        -16.54
      ],
      [
        36.99,
        -26.41
      ],
      [
        36.53,
        -36.27
      ],
      [
        36.07,
        -46.14
      ],
      [
        35.61,
        -56
      ]
    ]
  ],
  meta: {
    width: 75.82000683593787,
    height: 112
  }
};
const k = {
  points: [
    [
      [
        -44,
        -63.5
      ],
      [
        -44,
        -63.5
      ],
      [
        -44,
        -63.5
      ],
      [
        -43.54,
        -53.23
      ],
      [
        -43.08,
        -42.95
      ],
      [
        -42.62,
        -32.67
      ],
      [
        -42.16,
        -22.39
      ],
      [
        -41.7,
        -12.11
      ],
      [
        -41.24,
        -1.83
      ],
      [
        -41.24,
        -1.83
      ],
      [
        -41.7,
        9.05
      ],
      [
        -42.16,
        19.94
      ],
      [
        -42.62,
        30.83
      ],
      [
        -43.08,
        41.72
      ],
      [
        -43.54,
        52.61
      ],
      [
        -44,
        63.5
      ],
      [
        -44,
        63.5
      ],
      [
        -44,
        63.5
      ],
      [
        -37.24,
        54.26
      ],
      [
        -30.47,
        45.03
      ],
      [
        -23.7,
        35.8
      ],
      [
        -16.93,
        26.57
      ],
      [
        -10.16,
        17.34
      ],
      [
        -3.39,
        8.11
      ],
      [
        3.38,
        -1.12
      ],
      [
        10.15,
        -10.35
      ],
      [
        16.92,
        -19.58
      ],
      [
        23.69,
        -28.81
      ],
      [
        30.46,
        -38.04
      ],
      [
        37.23,
        -47.27
      ],
      [
        44,
        -56.5
      ]
    ],
    [
      [
        44,
        63.5
      ],
      [
        44,
        63.5
      ],
      [
        36.59,
        54.5
      ],
      [
        29.19,
        45.5
      ],
      [
        21.8,
        36.5
      ],
      [
        14.4,
        27.5
      ],
      [
        7,
        18.5
      ]
    ]
  ],
  meta: {
    width: 88,
    height: 127
  }
};
const l = {
  points: [
    [
      [
        -34,
        -63.5
      ],
      [
        -34,
        -63.5
      ],
      [
        -34,
        -63.5
      ],
      [
        -33.49,
        -52.41
      ],
      [
        -32.98,
        -41.32
      ],
      [
        -32.47,
        -30.23
      ],
      [
        -31.95,
        -19.14
      ],
      [
        -31.44,
        -8.05
      ],
      [
        -30.93,
        3.05
      ],
      [
        -30.93,
        3.05
      ],
      [
        -31.44,
        13.12
      ],
      [
        -31.95,
        23.2
      ],
      [
        -32.47,
        33.27
      ],
      [
        -32.98,
        43.35
      ],
      [
        -33.49,
        53.42
      ],
      [
        -34,
        63.5
      ],
      [
        -34,
        63.5
      ],
      [
        -34,
        63.5
      ],
      [
        -22.67,
        62.83
      ],
      [
        -11.34,
        62.16
      ],
      [
        0,
        61.5
      ],
      [
        11.33,
        60.83
      ],
      [
        22.66,
        60.16
      ],
      [
        34,
        59.5
      ]
    ]
  ],
  meta: {
    width: 68,
    height: 127
  }
};
const n = {
  points: [
    [
      [
        36.99,
        56
      ],
      [
        36.99,
        56
      ],
      [
        36.99,
        56
      ],
      [
        39,
        46.08
      ],
      [
        41,
        36.16
      ],
      [
        43.01,
        26.24
      ],
      [
        45.01,
        16.32
      ],
      [
        45.01,
        16.32
      ],
      [
        44.55,
        5.67
      ],
      [
        44.09,
        -4.99
      ],
      [
        44.09,
        -4.99
      ],
      [
        41.71,
        -13.68
      ],
      [
        39.33,
        -22.37
      ],
      [
        39.33,
        -22.37
      ],
      [
        35.55,
        -29.17
      ],
      [
        31.76,
        -35.97
      ],
      [
        31.76,
        -35.97
      ],
      [
        24.56,
        -42.79
      ],
      [
        17.35,
        -49.61
      ],
      [
        17.35,
        -49.61
      ],
      [
        7.56,
        -52.81
      ],
      [
        -2.23,
        -56
      ],
      [
        -2.23,
        -56
      ],
      [
        -2.23,
        -56
      ],
      [
        -8.37,
        -55.53
      ],
      [
        -14.52,
        -55.05
      ],
      [
        -14.52,
        -55.05
      ],
      [
        -22.32,
        -52
      ],
      [
        -30.11,
        -48.96
      ],
      [
        -38.01,
        -40.81
      ],
      [
        -38.01,
        -40.81
      ],
      [
        -40.71,
        -34.7
      ],
      [
        -43.41,
        -28.6
      ],
      [
        -43.41,
        -28.6
      ],
      [
        -43.81,
        -18.76
      ],
      [
        -44.22,
        -8.92
      ],
      [
        -44.62,
        0.92
      ],
      [
        -45.02,
        10.75
      ],
      [
        -45.02,
        10.75
      ],
      [
        -42.9,
        22.06
      ],
      [
        -40.78,
        33.37
      ],
      [
        -38.65,
        44.68
      ],
      [
        -36.53,
        56
      ]
    ]
  ],
  meta: {
    width: 90.03807617187476,
    height: 112
  }
};
const o = {
  points: [
    [
      [
        46.5,
        -0.5
      ],
      [
        46.5,
        -0.5
      ],
      [
        46.5,
        -0.5
      ],
      [
        45.17,
        -9.68
      ],
      [
        43.84,
        -18.85
      ],
      [
        42.51,
        -28.02
      ],
      [
        42.51,
        -28.02
      ],
      [
        37.19,
        -37.33
      ],
      [
        31.87,
        -46.63
      ],
      [
        31.87,
        -46.63
      ],
      [
        24.21,
        -51.9
      ],
      [
        16.54,
        -57.18
      ],
      [
        16.54,
        -57.18
      ],
      [
        7.52,
        -58.84
      ],
      [
        -1.5,
        -60.5
      ],
      [
        -1.5,
        -60.5
      ],
      [
        -1.5,
        -60.5
      ],
      [
        -8.07,
        -59.62
      ],
      [
        -14.64,
        -58.74
      ],
      [
        -14.64,
        -58.74
      ],
      [
        -23.76,
        -52.69
      ],
      [
        -32.88,
        -46.64
      ],
      [
        -32.88,
        -46.64
      ],
      [
        -37.72,
        -37.09
      ],
      [
        -42.55,
        -27.55
      ],
      [
        -42.55,
        -27.55
      ],
      [
        -43.87,
        -17.53
      ],
      [
        -45.19,
        -7.52
      ],
      [
        -46.5,
        2.5
      ],
      [
        -46.5,
        2.5
      ],
      [
        -46.5,
        2.5
      ],
      [
        -44.91,
        11.98
      ],
      [
        -43.31,
        21.47
      ],
      [
        -41.71,
        30.95
      ],
      [
        -41.71,
        30.95
      ],
      [
        -36.51,
        39.58
      ],
      [
        -31.32,
        48.21
      ],
      [
        -31.32,
        48.21
      ],
      [
        -22.21,
        53.58
      ],
      [
        -13.1,
        58.95
      ],
      [
        -13.1,
        58.95
      ],
      [
        -6.8,
        59.72
      ],
      [
        -0.5,
        60.5
      ],
      [
        -0.5,
        60.5
      ],
      [
        -0.5,
        60.5
      ],
      [
        8.86,
        58.61
      ],
      [
        18.23,
        56.73
      ],
      [
        18.23,
        56.73
      ],
      [
        25.67,
        51.42
      ],
      [
        33.12,
        46.12
      ],
      [
        33.12,
        46.12
      ],
      [
        38.03,
        37.91
      ],
      [
        42.95,
        29.7
      ],
      [
        42.95,
        29.7
      ],
      [
        44.72,
        19.1
      ],
      [
        46.5,
        8.5
      ]
    ]
  ],
  meta: {
    width: 93,
    height: 121
  }
};
const p = {
  points: [
    [
      [
        -35.5,
        61.49
      ],
      [
        -35.5,
        61.49
      ],
      [
        -35.5,
        50.31
      ],
      [
        -35.5,
        39.13
      ],
      [
        -35.5,
        27.95
      ],
      [
        -35.5,
        16.77
      ],
      [
        -35.5,
        5.59
      ],
      [
        -35.5,
        -5.6
      ],
      [
        -35.5,
        -16.78
      ],
      [
        -35.5,
        -27.96
      ],
      [
        -35.5,
        -39.14
      ],
      [
        -35.5,
        -50.32
      ],
      [
        -35.5,
        -61.5
      ],
      [
        -35.5,
        -61.5
      ],
      [
        -35.5,
        -61.5
      ],
      [
        -24.7,
        -60.95
      ],
      [
        -13.89,
        -60.39
      ],
      [
        -3.08,
        -59.84
      ],
      [
        -3.08,
        -59.84
      ],
      [
        7.96,
        -56.2
      ],
      [
        19,
        -52.56
      ],
      [
        19,
        -52.56
      ],
      [
        24.94,
        -47.31
      ],
      [
        30.88,
        -42.07
      ],
      [
        30.88,
        -42.07
      ],
      [
        33.19,
        -34.06
      ],
      [
        35.5,
        -26.05
      ],
      [
        35.5,
        -26.05
      ],
      [
        35.5,
        -26.05
      ],
      [
        33.82,
        -15.53
      ],
      [
        32.14,
        -5.01
      ],
      [
        32.14,
        -5.01
      ],
      [
        27.13,
        1.53
      ],
      [
        22.12,
        8.07
      ],
      [
        22.12,
        8.07
      ],
      [
        13.83,
        11.33
      ],
      [
        5.54,
        14.59
      ],
      [
        5.54,
        14.59
      ],
      [
        -5.98,
        15.27
      ],
      [
        -17.5,
        15.95
      ]
    ]
  ],
  meta: {
    width: 71,
    height: 122.99999999999999
  }
};
const q = {
  points: [
    [
      [
        41.5,
        5.15
      ],
      [
        41.5,
        5.15
      ],
      [
        41.5,
        5.15
      ],
      [
        41.5,
        -4.09
      ],
      [
        41.5,
        -13.33
      ],
      [
        41.51,
        -22.58
      ],
      [
        41.51,
        -22.58
      ],
      [
        37.01,
        -32.74
      ],
      [
        32.52,
        -42.9
      ],
      [
        32.52,
        -42.9
      ],
      [
        25.79,
        -48.21
      ],
      [
        19.05,
        -53.52
      ],
      [
        12.32,
        -58.83
      ],
      [
        0.92,
        -62.16
      ],
      [
        0.92,
        -62.16
      ],
      [
        -9.29,
        -61.01
      ],
      [
        -19.5,
        -59.85
      ],
      [
        -19.5,
        -59.85
      ],
      [
        -29.78,
        -53.82
      ],
      [
        -29.78,
        -53.82
      ],
      [
        -36.52,
        -46.74
      ],
      [
        -43.25,
        -39.65
      ],
      [
        -43.25,
        -39.65
      ],
      [
        -46.4,
        -31.51
      ],
      [
        -49.55,
        -23.37
      ],
      [
        -49.55,
        -23.37
      ],
      [
        -50.2,
        -14.53
      ],
      [
        -50.85,
        -5.69
      ],
      [
        -51.5,
        3.15
      ],
      [
        -51.5,
        3.15
      ],
      [
        -51.5,
        3.15
      ],
      [
        -48.17,
        13.33
      ],
      [
        -44.83,
        23.51
      ],
      [
        -41.49,
        33.68
      ],
      [
        -41.49,
        33.68
      ],
      [
        -33.46,
        42.07
      ],
      [
        -25.43,
        50.45
      ],
      [
        -25.43,
        50.45
      ],
      [
        -17.55,
        53.22
      ],
      [
        -9.67,
        56
      ],
      [
        -9.67,
        56
      ],
      [
        -0.59,
        54.08
      ],
      [
        8.5,
        52.15
      ]
    ],
    [
      [
        8.5,
        12.15
      ],
      [
        8.5,
        12.15
      ],
      [
        15.66,
        20.48
      ],
      [
        22.83,
        28.82
      ],
      [
        30,
        37.15
      ],
      [
        37.16,
        45.48
      ],
      [
        44.33,
        53.82
      ],
      [
        51.5,
        62.15
      ]
    ]
  ],
  meta: {
    width: 103,
    height: 124.31280000000001
  }
};
const r = {
  points: [
    [
      [
        -39,
        61.5
      ],
      [
        -39,
        61.5
      ],
      [
        -39,
        50.31
      ],
      [
        -39,
        39.13
      ],
      [
        -39,
        27.95
      ],
      [
        -39,
        16.77
      ],
      [
        -39,
        5.59
      ],
      [
        -39,
        -5.6
      ],
      [
        -39,
        -16.78
      ],
      [
        -39,
        -27.96
      ],
      [
        -39,
        -39.14
      ],
      [
        -39,
        -50.32
      ],
      [
        -39,
        -61.51
      ],
      [
        -39,
        -61.51
      ],
      [
        -39,
        -61.51
      ],
      [
        -27.88,
        -61.02
      ],
      [
        -16.76,
        -60.54
      ],
      [
        -5.63,
        -60.06
      ],
      [
        -5.63,
        -60.06
      ],
      [
        2.1,
        -57.72
      ],
      [
        9.83,
        -55.39
      ],
      [
        17.56,
        -53.05
      ],
      [
        17.56,
        -53.05
      ],
      [
        23.83,
        -47.88
      ],
      [
        30.11,
        -42.71
      ],
      [
        30.11,
        -42.71
      ],
      [
        32.55,
        -34.73
      ],
      [
        35,
        -26.76
      ],
      [
        35,
        -26.76
      ],
      [
        33.85,
        -15.48
      ],
      [
        33.85,
        -15.48
      ],
      [
        29.97,
        -7.9
      ],
      [
        26.08,
        -0.32
      ],
      [
        26.08,
        -0.32
      ],
      [
        16.05,
        5.2
      ],
      [
        6.02,
        10.72
      ],
      [
        -4,
        16.24
      ],
      [
        -4,
        16.24
      ],
      [
        -4.86,
        23.39
      ],
      [
        -4.86,
        23.39
      ],
      [
        -0.49,
        28.73
      ],
      [
        3.89,
        34.07
      ],
      [
        3.89,
        34.07
      ],
      [
        12.66,
        40.93
      ],
      [
        21.44,
        47.78
      ],
      [
        30.22,
        54.64
      ],
      [
        39,
        61.5
      ]
    ]
  ],
  meta: {
    width: 78,
    height: 123.00019999999998
  }
};
const s = {
  points: [
    [
      [
        -30.22,
        53.3
      ],
      [
        -30.22,
        53.3
      ],
      [
        -30.22,
        53.3
      ],
      [
        -19.67,
        55.19
      ],
      [
        -9.11,
        57.08
      ],
      [
        1.44,
        58.96
      ],
      [
        1.44,
        58.96
      ],
      [
        11.7,
        57.92
      ],
      [
        21.95,
        56.88
      ],
      [
        21.95,
        56.88
      ],
      [
        27.13,
        53.38
      ],
      [
        32.3,
        49.87
      ],
      [
        32.3,
        49.87
      ],
      [
        33.76,
        43.24
      ],
      [
        35.21,
        36.62
      ],
      [
        35.21,
        36.62
      ],
      [
        35.21,
        36.62
      ],
      [
        33.11,
        30.76
      ],
      [
        31.01,
        24.9
      ],
      [
        22.29,
        17.08
      ],
      [
        22.29,
        17.08
      ],
      [
        12.49,
        14.17
      ],
      [
        2.68,
        11.25
      ],
      [
        -7.12,
        8.34
      ],
      [
        -16.92,
        5.42
      ],
      [
        -26.72,
        2.51
      ],
      [
        -34.79,
        -2.55
      ],
      [
        -38.08,
        -10.41
      ],
      [
        -38.08,
        -10.41
      ],
      [
        -35.74,
        -20.59
      ],
      [
        -35.74,
        -20.59
      ],
      [
        -32.25,
        -25.91
      ],
      [
        -28.77,
        -31.22
      ],
      [
        -28.77,
        -31.22
      ],
      [
        -21.21,
        -37.48
      ],
      [
        -13.65,
        -43.73
      ],
      [
        -6.1,
        -49.98
      ],
      [
        -6.1,
        -49.98
      ],
      [
        2.48,
        -52.98
      ],
      [
        11.05,
        -55.98
      ],
      [
        19.62,
        -58.97
      ],
      [
        30.4,
        -57.39
      ],
      [
        38.07,
        -50.47
      ]
    ]
  ],
  meta: {
    width: 76.15999999999985,
    height: 117.93349023437499
  }
};
const t = {
  points: [
    [
      [
        1,
        -56
      ],
      [
        1,
        -56
      ],
      [
        1,
        -56
      ],
      [
        1.55,
        -44.6
      ],
      [
        2.1,
        -33.2
      ],
      [
        2.66,
        -21.8
      ],
      [
        3.21,
        -10.39
      ],
      [
        3.76,
        1.01
      ],
      [
        3.76,
        1.01
      ],
      [
        3.21,
        12.01
      ],
      [
        2.66,
        23
      ],
      [
        2.1,
        34
      ],
      [
        1.55,
        45
      ],
      [
        1,
        56
      ]
    ],
    [
      [
        -51,
        -54
      ],
      [
        -51,
        -54
      ],
      [
        -51,
        -54
      ],
      [
        -39.67,
        -54
      ],
      [
        -28.34,
        -54
      ],
      [
        -17,
        -54
      ],
      [
        -5.67,
        -54
      ],
      [
        5.66,
        -54
      ],
      [
        17,
        -54
      ],
      [
        28.33,
        -54
      ],
      [
        39.66,
        -54
      ],
      [
        51,
        -54
      ]
    ]
  ],
  meta: {
    width: 102,
    height: 112
  }
};
const u = {
  points: [
    [
      [
        -37,
        -56
      ],
      [
        -37,
        -56
      ],
      [
        -37,
        -56
      ],
      [
        -39.01,
        -46.09
      ],
      [
        -41.01,
        -36.17
      ],
      [
        -43.02,
        -26.25
      ],
      [
        -45.02,
        -16.33
      ],
      [
        -45.02,
        -16.33
      ],
      [
        -44.56,
        -5.68
      ],
      [
        -44.1,
        4.98
      ],
      [
        -44.1,
        4.98
      ],
      [
        -41.72,
        13.67
      ],
      [
        -39.35,
        22.36
      ],
      [
        -39.35,
        22.36
      ],
      [
        -35.56,
        29.16
      ],
      [
        -31.78,
        35.96
      ],
      [
        -31.78,
        35.96
      ],
      [
        -24.57,
        42.78
      ],
      [
        -17.37,
        49.6
      ],
      [
        -17.37,
        49.6
      ],
      [
        -7.58,
        52.8
      ],
      [
        2.2,
        56
      ],
      [
        2.2,
        56
      ],
      [
        2.2,
        56
      ],
      [
        8.35,
        55.52
      ],
      [
        14.49,
        55.04
      ],
      [
        14.49,
        55.04
      ],
      [
        22.3,
        51.99
      ],
      [
        30.1,
        48.95
      ],
      [
        38,
        40.8
      ],
      [
        38,
        40.8
      ],
      [
        40.7,
        34.69
      ],
      [
        43.4,
        28.59
      ],
      [
        43.4,
        28.59
      ],
      [
        43.8,
        18.75
      ],
      [
        44.21,
        8.91
      ],
      [
        44.61,
        -0.93
      ],
      [
        45.01,
        -10.76
      ],
      [
        45.01,
        -10.76
      ],
      [
        42.89,
        -22.07
      ],
      [
        40.77,
        -33.38
      ],
      [
        38.64,
        -44.69
      ],
      [
        36.52,
        -56
      ]
    ]
  ],
  meta: {
    width: 90.03807617187431,
    height: 112
  }
};
const v = {
  points: [
    [
      [
        -52,
        -51.28
      ],
      [
        -52,
        -51.28
      ],
      [
        -52,
        -51.28
      ],
      [
        -46.44,
        -41.1
      ],
      [
        -40.88,
        -30.93
      ],
      [
        -35.31,
        -20.76
      ],
      [
        -29.75,
        -10.59
      ],
      [
        -24.19,
        -0.41
      ],
      [
        -24.19,
        -0.41
      ],
      [
        -20.12,
        10.67
      ],
      [
        -16.06,
        21.75
      ],
      [
        -11.99,
        32.83
      ],
      [
        -7.93,
        43.91
      ],
      [
        -3.86,
        55
      ],
      [
        -3.86,
        55
      ],
      [
        -3.86,
        55
      ],
      [
        1.21,
        45
      ],
      [
        6.29,
        35
      ],
      [
        11.37,
        25
      ],
      [
        16.45,
        15
      ],
      [
        21.53,
        5
      ],
      [
        26.6,
        -5
      ],
      [
        31.68,
        -15
      ],
      [
        36.76,
        -25
      ],
      [
        41.84,
        -35
      ],
      [
        46.92,
        -45
      ],
      [
        52,
        -55
      ]
    ]
  ],
  meta: {
    width: 104,
    height: 110
  }
};
const w = {
  points: [
    [
      [
        68.24,
        -62.16
      ],
      [
        68.24,
        -62.16
      ],
      [
        68.24,
        -62.16
      ],
      [
        63.63,
        -67.28
      ],
      [
        59.02,
        -72.4
      ],
      [
        59.02,
        -72.4
      ],
      [
        52.14,
        -72.75
      ],
      [
        45.26,
        -73.11
      ],
      [
        45.26,
        -73.11
      ],
      [
        45.26,
        -73.11
      ],
      [
        40.14,
        -68.5
      ],
      [
        35.03,
        -63.89
      ],
      [
        35.03,
        -63.89
      ],
      [
        34.66,
        -57.02
      ],
      [
        34.3,
        -50.14
      ],
      [
        34.3,
        -50.14
      ],
      [
        42.79,
        -53.14
      ],
      [
        51.27,
        -56.15
      ],
      [
        59.76,
        -59.15
      ],
      [
        68.24,
        -62.16
      ]
    ],
    [
      [
        55.86,
        39.14
      ],
      [
        55.86,
        39.14
      ],
      [
        63.89,
        43.2
      ],
      [
        71.92,
        47.25
      ],
      [
        71.92,
        47.25
      ],
      [
        63.89,
        43.2
      ],
      [
        55.86,
        39.14
      ]
    ],
    [
      [
        -0.98,
        -12.17
      ],
      [
        -0.98,
        -12.17
      ],
      [
        7.99,
        -12.99
      ],
      [
        16.96,
        -13.82
      ],
      [
        16.96,
        -13.82
      ],
      [
        16.96,
        -13.82
      ],
      [
        14.14,
        -19.57
      ],
      [
        11.32,
        -25.32
      ],
      [
        11.32,
        -25.32
      ],
      [
        5.39,
        -27.74
      ],
      [
        -0.54,
        -30.16
      ],
      [
        -0.54,
        -30.16
      ],
      [
        -0.54,
        -30.16
      ],
      [
        -6.57,
        -28.03
      ],
      [
        -12.61,
        -25.9
      ],
      [
        -12.61,
        -25.9
      ],
      [
        -15.7,
        -20.3
      ],
      [
        -18.8,
        -14.69
      ],
      [
        -18.8,
        -14.69
      ],
      [
        -9.89,
        -13.43
      ],
      [
        -0.98,
        -12.17
      ]
    ],
    [
      [
        -63.3,
        24.48
      ],
      [
        -63.3,
        24.48
      ],
      [
        -54.36,
        23.41
      ],
      [
        -45.42,
        22.35
      ],
      [
        -45.42,
        22.35
      ],
      [
        -54.36,
        23.41
      ],
      [
        -63.3,
        24.48
      ]
    ],
    [
      [
        -36.42,
        -52.95
      ],
      [
        -36.42,
        -52.95
      ],
      [
        -36.42,
        -52.95
      ],
      [
        -37.88,
        -59.69
      ],
      [
        -39.35,
        -66.42
      ],
      [
        -39.35,
        -66.42
      ],
      [
        -45.14,
        -70.14
      ],
      [
        -50.94,
        -73.86
      ],
      [
        -50.94,
        -73.86
      ],
      [
        -50.94,
        -73.86
      ],
      [
        -57.67,
        -72.4
      ],
      [
        -64.4,
        -70.93
      ],
      [
        -64.4,
        -70.93
      ],
      [
        -68.12,
        -65.14
      ],
      [
        -71.84,
        -59.34
      ],
      [
        -71.84,
        -59.34
      ],
      [
        -60.03,
        -57.21
      ],
      [
        -48.22,
        -55.08
      ],
      [
        -36.42,
        -52.95
      ]
    ],
    [
      [
        34.3,
        -50.14
      ],
      [
        34.3,
        -50.14
      ],
      [
        34.3,
        -50.14
      ],
      [
        36.49,
        -39.91
      ],
      [
        38.67,
        -29.69
      ],
      [
        40.85,
        -19.46
      ],
      [
        43.03,
        -9.23
      ],
      [
        45.22,
        0.99
      ],
      [
        45.22,
        0.99
      ],
      [
        43.41,
        11
      ],
      [
        41.59,
        21.01
      ],
      [
        39.78,
        31.03
      ],
      [
        39.78,
        31.03
      ],
      [
        47.82,
        35.08
      ],
      [
        55.85,
        39.14
      ],
      [
        63.89,
        43.2
      ],
      [
        71.92,
        47.25
      ],
      [
        71.92,
        47.25
      ],
      [
        71.92,
        47.25
      ],
      [
        75.59,
        36.38
      ],
      [
        79.26,
        25.51
      ],
      [
        79.26,
        25.51
      ],
      [
        79.91,
        16.98
      ],
      [
        80.55,
        8.46
      ],
      [
        81.2,
        -0.07
      ],
      [
        81.2,
        -0.07
      ],
      [
        79.99,
        -9.82
      ],
      [
        78.78,
        -19.58
      ],
      [
        77.58,
        -29.33
      ],
      [
        77.58,
        -29.33
      ],
      [
        74.46,
        -40.28
      ],
      [
        71.35,
        -51.22
      ],
      [
        68.24,
        -62.16
      ],
      [
        68.24,
        -62.16
      ],
      [
        59.76,
        -59.15
      ],
      [
        51.27,
        -56.15
      ],
      [
        42.79,
        -53.14
      ],
      [
        34.3,
        -50.14
      ]
    ],
    [
      [
        39.78,
        31.03
      ],
      [
        39.78,
        31.03
      ],
      [
        34.2,
        37.68
      ],
      [
        34.2,
        37.68
      ],
      [
        33.62,
        37.72
      ],
      [
        33.62,
        37.72
      ],
      [
        33.62,
        37.72
      ],
      [
        29.61,
        31.92
      ],
      [
        25.6,
        26.13
      ],
      [
        25.6,
        26.13
      ],
      [
        25.6,
        26.13
      ],
      [
        23.44,
        16.14
      ],
      [
        21.28,
        6.15
      ],
      [
        19.12,
        -3.83
      ],
      [
        16.96,
        -13.82
      ],
      [
        16.96,
        -13.82
      ],
      [
        8,
        -12.99
      ],
      [
        -0.97,
        -12.17
      ],
      [
        -9.93,
        -11.34
      ],
      [
        -18.9,
        -10.52
      ],
      [
        -18.9,
        -10.52
      ],
      [
        -18.9,
        -10.52
      ],
      [
        -17.45,
        -1.02
      ],
      [
        -15.99,
        8.48
      ],
      [
        -14.54,
        17.98
      ],
      [
        -14.54,
        17.98
      ],
      [
        -11,
        29.17
      ],
      [
        -7.46,
        40.37
      ],
      [
        -7.46,
        40.37
      ],
      [
        -7.46,
        40.37
      ],
      [
        -2.43,
        48.94
      ],
      [
        2.59,
        57.51
      ],
      [
        2.59,
        57.51
      ],
      [
        9.52,
        63.43
      ],
      [
        16.44,
        69.36
      ],
      [
        16.44,
        69.36
      ],
      [
        16.44,
        69.36
      ],
      [
        25.08,
        71.6
      ],
      [
        33.71,
        73.85
      ],
      [
        33.71,
        73.85
      ],
      [
        41.97,
        71.89
      ],
      [
        50.22,
        69.92
      ],
      [
        50.22,
        69.92
      ],
      [
        50.22,
        69.92
      ],
      [
        56.58,
        65.1
      ],
      [
        62.94,
        60.28
      ],
      [
        62.94,
        60.28
      ],
      [
        67.43,
        53.77
      ],
      [
        71.92,
        47.25
      ],
      [
        71.92,
        47.25
      ],
      [
        63.89,
        43.2
      ],
      [
        55.85,
        39.14
      ],
      [
        47.82,
        35.08
      ],
      [
        39.78,
        31.03
      ]
    ],
    [
      [
        -18.8,
        -14.69
      ],
      [
        -18.8,
        -14.69
      ],
      [
        -18.8,
        -14.69
      ],
      [
        -21.56,
        -5.72
      ],
      [
        -24.32,
        3.25
      ],
      [
        -27.08,
        12.22
      ],
      [
        -29.84,
        21.19
      ],
      [
        -29.84,
        21.19
      ],
      [
        -29.84,
        21.19
      ],
      [
        -35.48,
        27.43
      ],
      [
        -41.12,
        33.67
      ],
      [
        -41.12,
        33.67
      ],
      [
        -42,
        34
      ],
      [
        -42,
        34
      ],
      [
        -41.36,
        34.19
      ],
      [
        -41.36,
        34.19
      ],
      [
        -41.36,
        34.19
      ],
      [
        -43.39,
        28.27
      ],
      [
        -45.42,
        22.35
      ],
      [
        -45.42,
        22.35
      ],
      [
        -54.36,
        23.41
      ],
      [
        -63.3,
        24.48
      ],
      [
        -72.24,
        25.55
      ],
      [
        -81.18,
        26.61
      ],
      [
        -81.18,
        26.61
      ],
      [
        -81.18,
        26.61
      ],
      [
        -78.49,
        36.6
      ],
      [
        -75.8,
        46.59
      ],
      [
        -75.8,
        46.59
      ],
      [
        -69.88,
        54.4
      ],
      [
        -63.96,
        62.21
      ],
      [
        -63.96,
        62.21
      ],
      [
        -63.96,
        62.21
      ],
      [
        -54.8,
        66.01
      ],
      [
        -45.64,
        69.81
      ],
      [
        -45.64,
        69.81
      ],
      [
        -36.11,
        68.21
      ],
      [
        -26.58,
        66.6
      ],
      [
        -26.58,
        66.6
      ],
      [
        -26.58,
        66.6
      ],
      [
        -18.75,
        61.08
      ],
      [
        -10.92,
        55.57
      ],
      [
        -10.92,
        55.57
      ],
      [
        -4.73,
        47.26
      ],
      [
        1.46,
        38.96
      ],
      [
        1.46,
        38.96
      ],
      [
        1.46,
        38.96
      ],
      [
        6.14,
        28.09
      ],
      [
        10.83,
        17.23
      ],
      [
        10.83,
        17.23
      ],
      [
        12.84,
        8.27
      ],
      [
        14.85,
        -0.69
      ],
      [
        16.86,
        -9.65
      ],
      [
        16.86,
        -9.65
      ],
      [
        7.95,
        -10.91
      ],
      [
        -0.97,
        -12.17
      ],
      [
        -9.88,
        -13.43
      ],
      [
        -18.8,
        -14.69
      ]
    ],
    [
      [
        -45.42,
        22.35
      ],
      [
        -45.42,
        22.35
      ],
      [
        -45.42,
        22.35
      ],
      [
        -45.48,
        12.69
      ],
      [
        -45.55,
        3.03
      ],
      [
        -45.61,
        -6.62
      ],
      [
        -45.68,
        -16.28
      ],
      [
        -45.68,
        -16.28
      ],
      [
        -43.36,
        -25.45
      ],
      [
        -41.05,
        -34.62
      ],
      [
        -38.73,
        -43.79
      ],
      [
        -36.42,
        -52.95
      ],
      [
        -36.42,
        -52.95
      ],
      [
        -48.22,
        -55.08
      ],
      [
        -60.03,
        -57.21
      ],
      [
        -71.84,
        -59.34
      ],
      [
        -71.84,
        -59.34
      ],
      [
        -71.84,
        -59.34
      ],
      [
        -74.18,
        -49.8
      ],
      [
        -76.52,
        -40.25
      ],
      [
        -78.86,
        -30.71
      ],
      [
        -81.21,
        -21.16
      ],
      [
        -81.21,
        -21.16
      ],
      [
        -81.2,
        -9.22
      ],
      [
        -81.19,
        2.73
      ],
      [
        -81.19,
        14.67
      ],
      [
        -81.18,
        26.61
      ],
      [
        -81.18,
        26.61
      ],
      [
        -72.24,
        25.55
      ],
      [
        -63.3,
        24.48
      ],
      [
        -54.36,
        23.41
      ],
      [
        -45.42,
        22.35
      ]
    ]
  ],
  meta: {
    width: 162.4045312499984,
    height: 147.7144
  }
};
const x = {
  points: [
    [
      [
        -46.5,
        -54.65
      ],
      [
        -46.5,
        -54.65
      ],
      [
        -46.5,
        -54.65
      ],
      [
        -39.41,
        -47.09
      ],
      [
        -32.32,
        -39.53
      ],
      [
        -25.23,
        -31.97
      ],
      [
        -18.14,
        -24.4
      ],
      [
        -11.05,
        -16.84
      ],
      [
        -3.95,
        -9.28
      ],
      [
        3.14,
        -1.71
      ],
      [
        3.14,
        -1.71
      ],
      [
        10.36,
        7.68
      ],
      [
        17.59,
        17.07
      ],
      [
        24.82,
        26.47
      ],
      [
        32.04,
        35.86
      ],
      [
        39.27,
        45.25
      ],
      [
        46.5,
        54.64
      ]
    ],
    [
      [
        -38.39,
        52.49
      ],
      [
        -38.39,
        52.49
      ],
      [
        -38.39,
        52.49
      ],
      [
        -31.39,
        43.68
      ],
      [
        -24.39,
        34.87
      ],
      [
        -17.39,
        26.07
      ],
      [
        -10.39,
        17.26
      ],
      [
        -3.39,
        8.45
      ],
      [
        3.6,
        -0.35
      ],
      [
        3.6,
        -0.35
      ],
      [
        10.72,
        -8.14
      ],
      [
        17.84,
        -15.92
      ],
      [
        24.96,
        -23.7
      ],
      [
        32.08,
        -31.49
      ],
      [
        39.2,
        -39.27
      ],
      [
        46.32,
        -47.05
      ]
    ]
  ],
  meta: {
    width: 93,
    height: 109.299
  }
};
const y = {
  points: [
    [
      [
        1.96,
        -1
      ],
      [
        1.96,
        -1
      ],
      [
        1.96,
        11
      ],
      [
        1.96,
        23
      ],
      [
        1.96,
        35
      ],
      [
        1.96,
        47
      ],
      [
        1.96,
        59
      ]
    ],
    [
      [
        -37.76,
        -59
      ],
      [
        -37.76,
        -59
      ],
      [
        -37.76,
        -59
      ],
      [
        -41.81,
        -49.09
      ],
      [
        -45.86,
        -39.17
      ],
      [
        -45.86,
        -39.17
      ],
      [
        -44.4,
        -31.55
      ],
      [
        -42.94,
        -23.93
      ],
      [
        -42.94,
        -23.93
      ],
      [
        -35.43,
        -17.12
      ],
      [
        -27.93,
        -10.31
      ],
      [
        -27.93,
        -10.31
      ],
      [
        -18.02,
        -7.87
      ],
      [
        -8.11,
        -5.44
      ],
      [
        1.8,
        -3
      ],
      [
        1.8,
        -3
      ],
      [
        1.8,
        -3
      ],
      [
        13.46,
        -4.08
      ],
      [
        25.13,
        -5.15
      ],
      [
        25.13,
        -5.15
      ],
      [
        33.04,
        -9.26
      ],
      [
        40.95,
        -13.38
      ],
      [
        40.95,
        -13.38
      ],
      [
        43.4,
        -21.9
      ],
      [
        45.85,
        -30.43
      ],
      [
        45.85,
        -30.43
      ],
      [
        42.7,
        -39.95
      ],
      [
        39.55,
        -49.48
      ],
      [
        36.4,
        -59
      ]
    ]
  ],
  meta: {
    width: 91.70199218749894,
    height: 118
  }
};
const z = {
  points: [
    [
      [
        -37.5,
        -58.5
      ],
      [
        -37.5,
        -58.5
      ],
      [
        -37.5,
        -58.5
      ],
      [
        -26.5,
        -57.93
      ],
      [
        -15.5,
        -57.36
      ],
      [
        -4.5,
        -56.79
      ],
      [
        6.5,
        -56.22
      ],
      [
        17.5,
        -55.65
      ],
      [
        28.5,
        -55.08
      ],
      [
        39.5,
        -54.5
      ],
      [
        39.5,
        -54.5
      ],
      [
        39.5,
        -54.5
      ],
      [
        32.98,
        -46.24
      ],
      [
        26.47,
        -37.98
      ],
      [
        19.96,
        -29.72
      ],
      [
        13.45,
        -21.46
      ],
      [
        6.94,
        -13.2
      ],
      [
        0.43,
        -4.94
      ],
      [
        0.43,
        -4.94
      ],
      [
        -5.27,
        4.12
      ],
      [
        -10.98,
        13.18
      ],
      [
        -16.68,
        22.24
      ],
      [
        -22.39,
        31.31
      ],
      [
        -28.09,
        40.37
      ],
      [
        -33.8,
        49.43
      ],
      [
        -39.5,
        58.5
      ],
      [
        -39.5,
        58.5
      ],
      [
        -28.22,
        57.5
      ],
      [
        -16.93,
        56.5
      ],
      [
        -5.65,
        55.5
      ],
      [
        5.64,
        54.5
      ],
      [
        16.92,
        53.5
      ],
      [
        28.21,
        52.5
      ],
      [
        39.5,
        51.5
      ]
    ]
  ],
  meta: {
    width: 79,
    height: 117
  }
};
const m = {
  points: [
    [
      [
        -68.34,
        56.91
      ],
      [
        -68.34,
        56.91
      ],
      [
        -68.34,
        56.91
      ],
      [
        -63.72,
        62.03
      ],
      [
        -59.11,
        67.15
      ],
      [
        -59.11,
        67.15
      ],
      [
        -52.23,
        67.51
      ],
      [
        -45.36,
        67.87
      ],
      [
        -45.36,
        67.87
      ],
      [
        -45.36,
        67.87
      ],
      [
        -40.23,
        63.26
      ],
      [
        -35.11,
        58.65
      ],
      [
        -35.11,
        58.65
      ],
      [
        -34.75,
        51.77
      ],
      [
        -34.4,
        44.89
      ],
      [
        -34.4,
        44.89
      ],
      [
        -42.88,
        47.89
      ],
      [
        -51.36,
        50.9
      ],
      [
        -59.85,
        53.91
      ],
      [
        -68.34,
        56.91
      ]
    ],
    [
      [
        -55.96,
        -44.39
      ],
      [
        -55.96,
        -44.39
      ],
      [
        -49.9,
        -37.73
      ],
      [
        -43.84,
        -31.07
      ],
      [
        -43.84,
        -31.07
      ],
      [
        -49.9,
        -37.73
      ],
      [
        -55.96,
        -44.39
      ]
    ],
    [
      [
        49.64,
        -39.1
      ],
      [
        49.64,
        -39.1
      ],
      [
        42.74,
        -33.33
      ],
      [
        35.85,
        -27.56
      ],
      [
        35.85,
        -27.56
      ],
      [
        42.74,
        -33.33
      ],
      [
        49.64,
        -39.1
      ]
    ],
    [
      [
        36.75,
        45.93
      ],
      [
        36.75,
        45.93
      ],
      [
        36.75,
        45.93
      ],
      [
        37.52,
        52.78
      ],
      [
        38.3,
        59.62
      ],
      [
        38.3,
        59.62
      ],
      [
        43.69,
        63.91
      ],
      [
        49.08,
        68.2
      ],
      [
        49.08,
        68.2
      ],
      [
        49.08,
        68.2
      ],
      [
        55.93,
        67.42
      ],
      [
        62.76,
        66.65
      ],
      [
        62.76,
        66.65
      ],
      [
        67.06,
        61.26
      ],
      [
        71.35,
        55.87
      ],
      [
        71.35,
        55.87
      ],
      [
        59.81,
        52.56
      ],
      [
        48.28,
        49.24
      ],
      [
        36.75,
        45.93
      ]
    ],
    [
      [
        -34.4,
        44.89
      ],
      [
        -34.4,
        44.89
      ],
      [
        -34.4,
        44.89
      ],
      [
        -37.07,
        34.12
      ],
      [
        -39.76,
        23.35
      ],
      [
        -42.44,
        12.58
      ],
      [
        -45.12,
        1.81
      ],
      [
        -47.8,
        -8.96
      ],
      [
        -47.8,
        -8.96
      ],
      [
        -47.8,
        -8.96
      ],
      [
        -47.39,
        -16.93
      ],
      [
        -46.98,
        -24.9
      ],
      [
        -43.84,
        -31.07
      ],
      [
        -43.84,
        -31.07
      ],
      [
        -49.89,
        -37.73
      ],
      [
        -55.94,
        -44.39
      ],
      [
        -62,
        -51.05
      ],
      [
        -68.05,
        -57.71
      ],
      [
        -68.05,
        -57.71
      ],
      [
        -68.05,
        -57.71
      ],
      [
        -72.47,
        -52.14
      ],
      [
        -76.88,
        -46.57
      ],
      [
        -76.88,
        -46.57
      ],
      [
        -79.39,
        -40.14
      ],
      [
        -81.89,
        -33.71
      ],
      [
        -81.89,
        -33.71
      ],
      [
        -82.49,
        -24.53
      ],
      [
        -83.08,
        -15.35
      ],
      [
        -83.67,
        -6.17
      ],
      [
        -83.67,
        -6.17
      ],
      [
        -83.67,
        -6.17
      ],
      [
        -81.93,
        3.87
      ],
      [
        -80.19,
        13.92
      ],
      [
        -78.45,
        23.96
      ],
      [
        -78.45,
        23.96
      ],
      [
        -75.08,
        34.94
      ],
      [
        -71.71,
        45.93
      ],
      [
        -68.34,
        56.91
      ],
      [
        -68.34,
        56.91
      ],
      [
        -59.85,
        53.91
      ],
      [
        -51.36,
        50.9
      ],
      [
        -42.88,
        47.89
      ],
      [
        -34.4,
        44.89
      ]
    ],
    [
      [
        -43.84,
        -31.07
      ],
      [
        -43.84,
        -31.07
      ],
      [
        -41.86,
        -32.64
      ],
      [
        -41.86,
        -32.64
      ],
      [
        -42.94,
        -32.63
      ],
      [
        -42.94,
        -32.63
      ],
      [
        -42.94,
        -32.63
      ],
      [
        -37.96,
        -26.5
      ],
      [
        -32.98,
        -20.36
      ],
      [
        -32.98,
        -20.36
      ],
      [
        -32.98,
        -20.36
      ],
      [
        -29.34,
        -12.88
      ],
      [
        -25.69,
        -5.4
      ],
      [
        -22.05,
        2.09
      ],
      [
        -22.05,
        2.09
      ],
      [
        -17.69,
        11.67
      ],
      [
        -17.69,
        11.67
      ],
      [
        -14.75,
        16.61
      ],
      [
        -14.75,
        16.61
      ],
      [
        -11.15,
        20.51
      ],
      [
        -11.15,
        20.51
      ],
      [
        -11.15,
        20.51
      ],
      [
        -5.09,
        22.72
      ],
      [
        0.97,
        24.92
      ],
      [
        0.97,
        24.92
      ],
      [
        0.91,
        12.92
      ],
      [
        0.86,
        0.92
      ],
      [
        0.81,
        -11.08
      ],
      [
        0.81,
        -11.08
      ],
      [
        11.93,
        -7.12
      ],
      [
        11.93,
        -7.12
      ],
      [
        14.37,
        -4.54
      ],
      [
        14.37,
        -4.54
      ],
      [
        14.43,
        -4.58
      ],
      [
        14.43,
        -4.58
      ],
      [
        10.93,
        -12.33
      ],
      [
        10.93,
        -12.33
      ],
      [
        10.93,
        -12.33
      ],
      [
        6.63,
        -21.1
      ],
      [
        2.34,
        -29.86
      ],
      [
        -1.96,
        -38.62
      ],
      [
        -1.96,
        -38.62
      ],
      [
        -1.96,
        -38.62
      ],
      [
        -6.82,
        -45.56
      ],
      [
        -11.68,
        -52.5
      ],
      [
        -11.68,
        -52.5
      ],
      [
        -18.78,
        -58.41
      ],
      [
        -25.88,
        -64.33
      ],
      [
        -25.88,
        -64.33
      ],
      [
        -25.88,
        -64.33
      ],
      [
        -36.64,
        -66.27
      ],
      [
        -47.4,
        -68.21
      ],
      [
        -47.4,
        -68.21
      ],
      [
        -47.4,
        -68.21
      ],
      [
        -57.73,
        -62.96
      ],
      [
        -68.05,
        -57.71
      ],
      [
        -68.05,
        -57.71
      ],
      [
        -62,
        -51.05
      ],
      [
        -55.94,
        -44.39
      ],
      [
        -49.89,
        -37.73
      ],
      [
        -43.84,
        -31.07
      ]
    ],
    [
      [
        0.97,
        24.92
      ],
      [
        0.97,
        24.92
      ],
      [
        0.97,
        24.92
      ],
      [
        6.7,
        22.92
      ],
      [
        12.43,
        20.91
      ],
      [
        12.43,
        20.91
      ],
      [
        16.14,
        17.17
      ],
      [
        16.14,
        17.17
      ],
      [
        19.23,
        12.35
      ],
      [
        19.23,
        12.35
      ],
      [
        23.6,
        3.26
      ],
      [
        23.6,
        3.26
      ],
      [
        23.6,
        3.26
      ],
      [
        28.74,
        -7.17
      ],
      [
        33.87,
        -17.59
      ],
      [
        33.87,
        -17.59
      ],
      [
        39.12,
        -25.44
      ],
      [
        39.12,
        -25.44
      ],
      [
        41.7,
        -28.06
      ],
      [
        41.7,
        -28.06
      ],
      [
        36.95,
        -27.63
      ],
      [
        36.95,
        -27.63
      ],
      [
        35.85,
        -27.56
      ],
      [
        35.85,
        -27.56
      ],
      [
        45.05,
        -35.25
      ],
      [
        54.26,
        -42.95
      ],
      [
        63.47,
        -50.64
      ],
      [
        63.47,
        -50.64
      ],
      [
        63.47,
        -50.64
      ],
      [
        54.29,
        -56.67
      ],
      [
        45.12,
        -62.69
      ],
      [
        45.12,
        -62.69
      ],
      [
        33.58,
        -62.95
      ],
      [
        23.97,
        -59.39
      ],
      [
        23.97,
        -59.39
      ],
      [
        23.97,
        -59.39
      ],
      [
        17.62,
        -53.82
      ],
      [
        11.27,
        -48.26
      ],
      [
        11.27,
        -48.26
      ],
      [
        6.99,
        -41.93
      ],
      [
        2.7,
        -35.6
      ],
      [
        2.7,
        -35.6
      ],
      [
        2.7,
        -35.6
      ],
      [
        -1.25,
        -27.63
      ],
      [
        -5.2,
        -19.66
      ],
      [
        -9.15,
        -11.69
      ],
      [
        -9.15,
        -11.69
      ],
      [
        -12.46,
        -4.77
      ],
      [
        -12.46,
        -4.77
      ],
      [
        -12.23,
        -4.98
      ],
      [
        -12.23,
        -4.98
      ],
      [
        -9.67,
        -7.49
      ],
      [
        -9.67,
        -7.49
      ],
      [
        0.81,
        -11.08
      ],
      [
        0.81,
        -11.08
      ],
      [
        0.86,
        0.92
      ],
      [
        0.91,
        12.92
      ],
      [
        0.97,
        24.92
      ]
    ],
    [
      [
        35.85,
        -27.56
      ],
      [
        35.85,
        -27.56
      ],
      [
        35.85,
        -27.56
      ],
      [
        41.35,
        -17.74
      ],
      [
        46.85,
        -7.93
      ],
      [
        46.85,
        -7.93
      ],
      [
        47.4,
        0.41
      ],
      [
        47.95,
        8.75
      ],
      [
        47.95,
        8.75
      ],
      [
        47.95,
        8.75
      ],
      [
        45.69,
        17.59
      ],
      [
        43.43,
        26.43
      ],
      [
        43.43,
        26.43
      ],
      [
        43.43,
        26.43
      ],
      [
        40.08,
        36.18
      ],
      [
        36.75,
        45.93
      ],
      [
        36.75,
        45.93
      ],
      [
        48.28,
        49.24
      ],
      [
        59.81,
        52.56
      ],
      [
        71.35,
        55.87
      ],
      [
        71.35,
        55.87
      ],
      [
        71.35,
        55.87
      ],
      [
        74.41,
        47
      ],
      [
        77.47,
        38.13
      ],
      [
        77.47,
        38.13
      ],
      [
        77.47,
        38.13
      ],
      [
        79.53,
        29.84
      ],
      [
        81.6,
        21.55
      ],
      [
        83.66,
        13.26
      ],
      [
        83.66,
        13.26
      ],
      [
        83.66,
        13.26
      ],
      [
        82.94,
        2.93
      ],
      [
        82.22,
        -7.39
      ],
      [
        81.49,
        -17.72
      ],
      [
        81.49,
        -17.72
      ],
      [
        76.99,
        -25.95
      ],
      [
        72.48,
        -34.18
      ],
      [
        67.97,
        -42.41
      ],
      [
        63.47,
        -50.64
      ],
      [
        63.47,
        -50.64
      ],
      [
        54.26,
        -42.95
      ],
      [
        45.05,
        -35.25
      ],
      [
        35.85,
        -27.56
      ]
    ]
  ],
  meta: {
    width: 167.3399999999997,
    height: 136.41166
  }
};
var furryLetters = {
  a,
  b,
  c: c$1,
  d,
  e,
  f,
  g,
  h,
  i: i$1,
  j,
  k,
  l,
  n,
  o,
  p,
  q,
  r,
  s,
  t,
  u,
  v,
  w,
  x,
  y,
  z,
  m
};
function removeDuplicates(points) {
  let uniquePoints = /* @__PURE__ */ new Set();
  let result = [];
  for (let point of points) {
    let pointString = JSON.stringify(point);
    if (!uniquePoints.has(pointString)) {
      result.push(point);
      uniquePoints.add(pointString);
    }
  }
  return result;
}
const particleSize = 60;
class FurryText {
  constructor() {
    this.points = [];
    this.neighbours = [];
    this.textContent = "";
    this.style = new TextStyle({
      fontFamily: "Arial",
      wordWrapWidth: 520,
      fontWeight: 800,
      wordWrap: true,
      fontSize: 100
    });
  }
  set text(value) {
    this.textContent = value;
    this.createText();
  }
  get text() {
    return this.textContent;
  }
  createText() {
    this.textMetrics = TextMetrics.measureText(
      formatText(this.textContent),
      this.style
    );
    let lines = this.textMetrics.lines.filter((l2) => !!l2.trim());
    this.lines = [...lines];
    console.log("\u{1F680} ~ FurryText ~ createText ~ this.lines:", this.lines);
    this.createPoints();
  }
  createPoints() {
    this.width = 0;
    let lineWidthTotal = 0;
    const undefinedCharacters = [];
    const linesWidths = [];
    const linesHeights = [];
    const linesPoints = [];
    let neighbours = [];
    let indexPoint = 0;
    this.lines.forEach((line, k2) => {
      let currentX = 0;
      let prevWidth = 0;
      let arrayPointsForLine = [];
      linesPoints.push(arrayPointsForLine);
      let newY = 0;
      let widthLine = 0;
      let paddingLetter = 0;
      const chars = segmentText(line).filter((c) => !!c);
      for (let i = 0; i < chars.length; i++) {
        const char = chars[i].toLowerCase();
        const { points: groupPoints, meta } = furryLetters[char] || {
          points: [[]],
          meta: {
            width: 40,
            height: 0
          }
        };
        const { width, height } = meta;
        newY = Math.max(newY, height);
        widthLine += width + particleSize;
        if (i === 0) {
          currentX = -width / 2;
        }
        currentX += prevWidth / 2 + width / 2 + particleSize;
        if (i > 0) {
          currentX += paddingLetter;
        }
        if (!groupPoints[0].length) {
          undefinedCharacters.push([char, currentX + width / 2, k2]);
        }
        groupPoints.forEach((points) => {
          points = removeDuplicates(points);
          points.forEach(([x2, y2], k3) => {
            const ptX = currentX + x2;
            const ptY = y2;
            arrayPointsForLine.push([ptX, ptY, k3 === 0]);
            let neighbourAX = -1;
            let neighbourAY = -1;
            let neighbourBX = -1;
            let neighbourBY = -1;
            if (k3 > 0) {
              neighbourAX = (indexPoint - 1) * 2;
              neighbourAY = (indexPoint - 1) * 2 + 1;
            }
            if (k3 < points.length - 1) {
              neighbourBX = (indexPoint + 1) * 2;
              neighbourBY = (indexPoint + 1) * 2 + 1;
            }
            neighbours.push([
              neighbourAX,
              neighbourAY,
              neighbourBX,
              neighbourBY
            ]);
            indexPoint++;
          });
        });
        prevWidth = width;
      }
      widthLine += paddingLetter * (line.length - 1);
      lineWidthTotal += widthLine - particleSize / 2;
      linesWidths.push(widthLine - particleSize / 2);
      linesHeights.push(newY);
    });
    const averageWidth = lineWidthTotal / this.lines.length;
    this.averageWidth = averageWidth;
    let ptsFinal = [];
    let distances = [];
    let scalePoints = [];
    let lineY = 0;
    const currentLinesScales = [];
    const currentLinesHeights = [];
    const currentLinesY = [];
    linesPoints.forEach((linePts, i) => {
      const widthLine = linesWidths[i];
      const heightLine = linesHeights[i];
      this.lines[i];
      const scale = Math.min(1.75, averageWidth / widthLine);
      const padding = 50;
      currentLinesScales.push(scale);
      currentLinesY.push(lineY + heightLine * 0.5 * scale + padding / 2);
      currentLinesHeights.push(heightLine * scale);
      for (let k2 = 0; k2 < linePts.length; k2++) {
        const ptF = linePts[k2];
        ptF[0] *= scale;
        ptF[1] *= scale;
        ptF[1] += heightLine * 0.5 * scale;
        ptF[1] += lineY;
        ptF[0] = Math.floor(ptF[0] * 100) / 100;
        ptF[1] = Math.floor(ptF[1] * 100) / 100;
        scalePoints.push(scale);
        ptsFinal.push(ptF[0], ptF[1]);
      }
      for (let k2 = 0; k2 < linePts.length; k2++) {
        const ptF = linePts[k2];
        let prevPt = !ptF[2] && linePts[k2 - 1];
        let distanceA = 0;
        if (prevPt) {
          distanceA = Math.sqrt(
            Math.pow(prevPt[1] - ptF[1], 2) + Math.pow(prevPt[0] - ptF[0], 2)
          );
        }
        let nextPt = linePts[k2 + 1];
        let distanceB = 0;
        if (nextPt && !nextPt[2]) {
          distanceB = Math.sqrt(
            Math.pow(nextPt[1] - ptF[1], 2) + Math.pow(nextPt[0] - ptF[0], 2)
          );
        }
        distances.push([distanceA, distanceB]);
      }
      lineY += heightLine * scale;
      if (i < linePts.length) {
        lineY += padding;
      }
      this.width = Math.max(this.width, widthLine * scale);
      this.height = lineY;
    });
    const charactersNotFound = undefinedCharacters.map(
      ([char, x2, lineIndex]) => {
        const lineHeight = currentLinesHeights[lineIndex];
        const lineScale = currentLinesScales[lineIndex];
        const yChar = currentLinesY[lineIndex];
        return {
          char,
          position: [x2 * lineScale, yChar],
          frame: [80, lineHeight]
        };
      }
    );
    console.log(
      "\u{1F680} ~ FurryText ~ createPoints ~ charactersNotFound:",
      charactersNotFound
    );
    this.points = [...ptsFinal];
    this.distances = [...distances];
    this.neighbours = [...neighbours];
    this.scales = [...scalePoints];
    this.charactersNotFound = [...charactersNotFound];
  }
}
function Url() {
  this._protocol = null;
  this._href = "";
  this._port = -1;
  this._query = null;
  this.auth = null;
  this.slashes = null;
  this.host = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
  this._prependSlash = false;
}
var querystring = require$$0;
Url.queryString = querystring;
Url.prototype.parse = function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
  if (typeof str !== "string") {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof str);
  }
  var start = 0;
  var end = str.length - 1;
  while (str.charCodeAt(start) <= 32)
    start++;
  while (str.charCodeAt(end) <= 32)
    end--;
  start = this._parseProtocol(str, start, end);
  if (this._protocol !== "javascript") {
    start = this._parseHost(str, start, end, hostDenotesSlash);
    var proto = this._protocol;
    if (!this.hostname && (this.slashes || proto && !slashProtocols[proto])) {
      this.hostname = this.host = "";
    }
  }
  if (start <= end) {
    var ch = str.charCodeAt(start);
    if (ch === 47 || ch === 92) {
      this._parsePath(str, start, end, disableAutoEscapeChars);
    } else if (ch === 63) {
      this._parseQuery(str, start, end, disableAutoEscapeChars);
    } else if (ch === 35) {
      this._parseHash(str, start, end, disableAutoEscapeChars);
    } else if (this._protocol !== "javascript") {
      this._parsePath(str, start, end, disableAutoEscapeChars);
    } else {
      this.pathname = str.slice(start, end + 1);
    }
  }
  if (!this.pathname && this.hostname && this._slashProtocols[this._protocol]) {
    this.pathname = "/";
  }
  if (parseQueryString) {
    var search = this.search;
    if (search == null) {
      search = this.search = "";
    }
    if (search.charCodeAt(0) === 63) {
      search = search.slice(1);
    }
    this.query = Url.queryString.parse(search);
  }
};
Url.prototype.resolve = function Url$resolve(relative) {
  return this.resolveObject(Url.parse(relative, false, true)).format();
};
Url.prototype.format = function Url$format() {
  var auth = this.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = this.protocol || "";
  var pathname = this.pathname || "";
  var hash = this.hash || "";
  var search = this.search || "";
  var query = "";
  var hostname = this.hostname || "";
  var port = this.port || "";
  var host = false;
  var scheme = "";
  var q2 = this.query;
  if (q2 && typeof q2 === "object") {
    query = Url.queryString.stringify(q2);
  }
  if (!search) {
    search = query ? "?" + query : "";
  }
  if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58)
    protocol += ":";
  if (this.host) {
    host = auth + this.host;
  } else if (hostname) {
    var ip6 = hostname.indexOf(":") > -1;
    if (ip6)
      hostname = "[" + hostname + "]";
    host = auth + hostname + (port ? ":" + port : "");
  }
  var slashes = this.slashes || (!protocol || slashProtocols[protocol]) && host !== false;
  if (protocol)
    scheme = protocol + (slashes ? "//" : "");
  else if (slashes)
    scheme = "//";
  if (slashes && pathname && pathname.charCodeAt(0) !== 47) {
    pathname = "/" + pathname;
  }
  if (search && search.charCodeAt(0) !== 63)
    search = "?" + search;
  if (hash && hash.charCodeAt(0) !== 35)
    hash = "#" + hash;
  pathname = escapePathName(pathname);
  search = escapeSearch(search);
  return scheme + (host === false ? "" : host) + pathname + search + hash;
};
Url.prototype.resolveObject = function Url$resolveObject(relative) {
  if (typeof relative === "string")
    relative = Url.parse(relative, false, true);
  var result = this._clone();
  result.hash = relative.hash;
  if (!relative.href) {
    result._href = "";
    return result;
  }
  if (relative.slashes && !relative._protocol) {
    relative._copyPropsTo(result, true);
    if (slashProtocols[result._protocol] && result.hostname && !result.pathname) {
      result.pathname = "/";
    }
    result._href = "";
    return result;
  }
  if (relative._protocol && relative._protocol !== result._protocol) {
    if (!slashProtocols[relative._protocol]) {
      relative._copyPropsTo(result, false);
      result._href = "";
      return result;
    }
    result._protocol = relative._protocol;
    if (!relative.host && relative._protocol !== "javascript") {
      var relPath = (relative.pathname || "").split("/");
      while (relPath.length && !(relative.host = relPath.shift()))
        ;
      if (!relative.host)
        relative.host = "";
      if (!relative.hostname)
        relative.hostname = "";
      if (relPath[0] !== "")
        relPath.unshift("");
      if (relPath.length < 2)
        relPath.unshift("");
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.host = relative.host || "";
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result._port = relative._port;
    result.slashes = result.slashes || relative.slashes;
    result._href = "";
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charCodeAt(0) === 47;
  var isRelAbs = relative.host || relative.pathname && relative.pathname.charCodeAt(0) === 47;
  var mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;
  var removeAllDots = mustEndAbs;
  var srcPath = result.pathname && result.pathname.split("/") || [];
  var relPath = relative.pathname && relative.pathname.split("/") || [];
  var psychotic = result._protocol && !slashProtocols[result._protocol];
  if (psychotic) {
    result.hostname = "";
    result._port = -1;
    if (result.host) {
      if (srcPath[0] === "")
        srcPath[0] = result.host;
      else
        srcPath.unshift(result.host);
    }
    result.host = "";
    if (relative._protocol) {
      relative.hostname = "";
      relative._port = -1;
      if (relative.host) {
        if (relPath[0] === "")
          relPath[0] = relative.host;
        else
          relPath.unshift(relative.host);
      }
      relative.host = "";
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  if (isRelAbs) {
    result.host = relative.host ? relative.host : result.host;
    result.hostname = relative.hostname ? relative.hostname : result.hostname;
    result.search = relative.search;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath)
      srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
  } else if (relative.search) {
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result._href = "";
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    result._href = "";
    return result;
  }
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host) && (last === "." || last === "..") || last === "";
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === ".") {
      srcPath.splice(i, 1);
    } else if (last === "..") {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charCodeAt(0) !== 47)) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charCodeAt(0) === 47;
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift("");
  }
  result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result._href = "";
  return result;
};
var punycode = punycode$2.exports;
Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
  return punycode.toASCII(hostname);
};
var escapePathName = Url.prototype._escapePathName = function Url$_escapePathName(pathname) {
  if (!containsCharacter2(pathname, 35, 63)) {
    return pathname;
  }
  return _escapePath(pathname);
};
var escapeSearch = Url.prototype._escapeSearch = function Url$_escapeSearch(search) {
  if (!containsCharacter2(search, 35, -1))
    return search;
  return _escapeSearch(search);
};
Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
  var doLowerCase = false;
  var protocolCharacters = this._protocolCharacters;
  for (var i = start; i <= end; ++i) {
    var ch = str.charCodeAt(i);
    if (ch === 58) {
      var protocol = str.slice(start, i);
      if (doLowerCase)
        protocol = protocol.toLowerCase();
      this._protocol = protocol;
      return i + 1;
    } else if (protocolCharacters[ch] === 1) {
      if (ch < 97)
        doLowerCase = true;
    } else {
      return start;
    }
  }
  return start;
};
Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode2) {
  var auth = str.slice(start, end + 1);
  if (decode2) {
    auth = decodeURIComponent(auth);
  }
  this.auth = auth;
};
Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
  var port = 0;
  var hadChars = false;
  var validPort = true;
  for (var i = start; i <= end; ++i) {
    var ch = str.charCodeAt(i);
    if (48 <= ch && ch <= 57) {
      port = 10 * port + (ch - 48);
      hadChars = true;
    } else {
      validPort = false;
      if (ch === 92 || ch === 47) {
        validPort = true;
      }
      break;
    }
  }
  if (port === 0 && !hadChars || !validPort) {
    if (!validPort) {
      this._port = -2;
    }
    return 0;
  }
  this._port = port;
  return i - start;
};
Url.prototype._parseHost = function Url$_parseHost(str, start, end, slashesDenoteHost) {
  var hostEndingCharacters = this._hostEndingCharacters;
  var first = str.charCodeAt(start);
  var second = str.charCodeAt(start + 1);
  if ((first === 47 || first === 92) && (second === 47 || second === 92)) {
    this.slashes = true;
    if (start === 0) {
      if (end < 2)
        return start;
      var hasAuth = containsCharacter(str, 64, 2, hostEndingCharacters);
      if (!hasAuth && !slashesDenoteHost) {
        this.slashes = null;
        return start;
      }
    }
    start += 2;
  } else if (!this._protocol || slashProtocols[this._protocol]) {
    return start;
  }
  var doLowerCase = false;
  var idna = false;
  var hostNameStart = start;
  var hostNameEnd = end;
  var portLength = 0;
  var charsAfterDot = 0;
  var authNeedsDecoding = false;
  var j2 = -1;
  for (var i = start; i <= end; ++i) {
    var ch = str.charCodeAt(i);
    if (ch === 64) {
      j2 = i;
    } else if (ch === 37) {
      authNeedsDecoding = true;
    } else if (hostEndingCharacters[ch] === 1) {
      break;
    }
  }
  if (j2 > -1) {
    this._parseAuth(str, start, j2 - 1, authNeedsDecoding);
    start = hostNameStart = j2 + 1;
  }
  if (str.charCodeAt(start) === 91) {
    for (var i = start + 1; i <= end; ++i) {
      var ch = str.charCodeAt(i);
      if (ch === 93) {
        if (str.charCodeAt(i + 1) === 58) {
          portLength = this._parsePort(str, i + 2, end) + 1;
        }
        var hostname = str.slice(start + 1, i).toLowerCase();
        this.hostname = hostname;
        this.host = this._port > 0 ? "[" + hostname + "]:" + this._port : "[" + hostname + "]";
        this.pathname = "/";
        return i + portLength + 1;
      }
    }
    return start;
  }
  for (var i = start; i <= end; ++i) {
    if (charsAfterDot > 62) {
      this.hostname = this.host = str.slice(start, i);
      return i;
    }
    var ch = str.charCodeAt(i);
    if (ch === 58) {
      portLength = this._parsePort(str, i + 1, end) + 1;
      hostNameEnd = i - 1;
      break;
    } else if (ch < 97) {
      if (ch === 46) {
        charsAfterDot = -1;
      } else if (65 <= ch && ch <= 90) {
        doLowerCase = true;
      } else if (!(ch === 45 || ch === 95 || ch === 43 || 48 <= ch && ch <= 57)) {
        if (hostEndingCharacters[ch] === 0 && this._noPrependSlashHostEnders[ch] === 0) {
          this._prependSlash = true;
        }
        hostNameEnd = i - 1;
        break;
      }
    } else if (ch >= 123) {
      if (ch <= 126) {
        if (this._noPrependSlashHostEnders[ch] === 0) {
          this._prependSlash = true;
        }
        hostNameEnd = i - 1;
        break;
      }
      idna = true;
    }
    charsAfterDot++;
  }
  if (hostNameEnd + 1 !== start && hostNameEnd - hostNameStart <= 256) {
    var hostname = str.slice(hostNameStart, hostNameEnd + 1);
    if (doLowerCase)
      hostname = hostname.toLowerCase();
    if (idna)
      hostname = this._hostIdna(hostname);
    this.hostname = hostname;
    this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
  }
  return hostNameEnd + 1 + portLength;
};
Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
  if (!noProtocol) {
    input._protocol = this._protocol;
  }
  input._href = this._href;
  input._port = this._port;
  input._prependSlash = this._prependSlash;
  input.auth = this.auth;
  input.slashes = this.slashes;
  input.host = this.host;
  input.hostname = this.hostname;
  input.hash = this.hash;
  input.search = this.search;
  input.pathname = this.pathname;
};
Url.prototype._clone = function Url$_clone() {
  var ret = new Url();
  ret._protocol = this._protocol;
  ret._href = this._href;
  ret._port = this._port;
  ret._prependSlash = this._prependSlash;
  ret.auth = this.auth;
  ret.slashes = this.slashes;
  ret.host = this.host;
  ret.hostname = this.hostname;
  ret.hash = this.hash;
  ret.search = this.search;
  ret.pathname = this.pathname;
  return ret;
};
Url.prototype._getComponentEscaped = function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
  var cur = start;
  var i = start;
  var ret = "";
  var autoEscapeMap2 = isAfterQuery ? this._afterQueryAutoEscapeMap : this._autoEscapeMap;
  for (; i <= end; ++i) {
    var ch = str.charCodeAt(i);
    var escaped = autoEscapeMap2[ch];
    if (escaped !== "" && escaped !== void 0) {
      if (cur < i)
        ret += str.slice(cur, i);
      ret += escaped;
      cur = i + 1;
    }
  }
  if (cur < i + 1)
    ret += str.slice(cur, i);
  return ret;
};
Url.prototype._parsePath = function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
  var pathStart = start;
  var pathEnd = end;
  var escape2 = false;
  var autoEscapeCharacters = this._autoEscapeCharacters;
  var prePath = this._port === -2 ? "/:" : "";
  for (var i = start; i <= end; ++i) {
    var ch = str.charCodeAt(i);
    if (ch === 35) {
      this._parseHash(str, i, end, disableAutoEscapeChars);
      pathEnd = i - 1;
      break;
    } else if (ch === 63) {
      this._parseQuery(str, i, end, disableAutoEscapeChars);
      pathEnd = i - 1;
      break;
    } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
      escape2 = true;
    }
  }
  if (pathStart > pathEnd) {
    this.pathname = prePath === "" ? "/" : prePath;
    return;
  }
  var path;
  if (escape2) {
    path = this._getComponentEscaped(str, pathStart, pathEnd, false);
  } else {
    path = str.slice(pathStart, pathEnd + 1);
  }
  this.pathname = prePath === "" ? this._prependSlash ? "/" + path : path : prePath + path;
};
Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
  var queryStart = start;
  var queryEnd = end;
  var escape2 = false;
  var autoEscapeCharacters = this._autoEscapeCharacters;
  for (var i = start; i <= end; ++i) {
    var ch = str.charCodeAt(i);
    if (ch === 35) {
      this._parseHash(str, i, end, disableAutoEscapeChars);
      queryEnd = i - 1;
      break;
    } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
      escape2 = true;
    }
  }
  if (queryStart > queryEnd) {
    this.search = "";
    return;
  }
  var query;
  if (escape2) {
    query = this._getComponentEscaped(str, queryStart, queryEnd, true);
  } else {
    query = str.slice(queryStart, queryEnd + 1);
  }
  this.search = query;
};
Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
  if (start > end) {
    this.hash = "";
    return;
  }
  this.hash = disableAutoEscapeChars ? str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
};
Object.defineProperty(Url.prototype, "port", {
  get: function() {
    if (this._port >= 0) {
      return "" + this._port;
    }
    return null;
  },
  set: function(v2) {
    if (v2 == null) {
      this._port = -1;
    } else {
      this._port = parseInt(v2, 10);
    }
  }
});
Object.defineProperty(Url.prototype, "query", {
  get: function() {
    var query = this._query;
    if (query != null) {
      return query;
    }
    var search = this.search;
    if (search) {
      if (search.charCodeAt(0) === 63) {
        search = search.slice(1);
      }
      if (search !== "") {
        this._query = search;
        return search;
      }
    }
    return search;
  },
  set: function(v2) {
    this._query = v2;
  }
});
Object.defineProperty(Url.prototype, "path", {
  get: function() {
    var p2 = this.pathname || "";
    var s2 = this.search || "";
    if (p2 || s2) {
      return p2 + s2;
    }
    return p2 == null && s2 ? "/" + s2 : null;
  },
  set: function() {
  }
});
Object.defineProperty(Url.prototype, "protocol", {
  get: function() {
    var proto = this._protocol;
    return proto ? proto + ":" : proto;
  },
  set: function(v2) {
    if (typeof v2 === "string") {
      var end = v2.length - 1;
      if (v2.charCodeAt(end) === 58) {
        this._protocol = v2.slice(0, end);
      } else {
        this._protocol = v2;
      }
    } else if (v2 == null) {
      this._protocol = null;
    }
  }
});
Object.defineProperty(Url.prototype, "href", {
  get: function() {
    var href = this._href;
    if (!href) {
      href = this._href = this.format();
    }
    return href;
  },
  set: function(v2) {
    this._href = v2;
  }
});
Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
  if (str instanceof Url)
    return str;
  var ret = new Url();
  ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
  return ret;
};
Url.format = function Url$Format(obj) {
  if (typeof obj === "string") {
    obj = Url.parse(obj);
  }
  if (!(obj instanceof Url)) {
    return Url.prototype.format.call(obj);
  }
  return obj.format();
};
Url.resolve = function Url$Resolve(source, relative) {
  return Url.parse(source, false, true).resolve(relative);
};
Url.resolveObject = function Url$ResolveObject(source, relative) {
  if (!source)
    return relative;
  return Url.parse(source, false, true).resolveObject(relative);
};
function _escapePath(pathname) {
  return pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
}
function _escapeSearch(search) {
  return search.replace(/#/g, function(match) {
    return encodeURIComponent(match);
  });
}
function containsCharacter(string, char1, fromIndex, stopCharacterTable) {
  var len = string.length;
  for (var i = fromIndex; i < len; ++i) {
    var ch = string.charCodeAt(i);
    if (ch === char1) {
      return true;
    } else if (stopCharacterTable[ch] === 1) {
      return false;
    }
  }
  return false;
}
function containsCharacter2(string, char1, char2) {
  for (var i = 0, len = string.length; i < len; ++i) {
    var ch = string.charCodeAt(i);
    if (ch === char1 || ch === char2)
      return true;
  }
  return false;
}
function makeAsciiTable(spec) {
  var ret = new Uint8Array(128);
  spec.forEach(function(item) {
    if (typeof item === "number") {
      ret[item] = 1;
    } else {
      var start = item[0];
      var end = item[1];
      for (var j2 = start; j2 <= end; ++j2) {
        ret[j2] = 1;
      }
    }
  });
  return ret;
}
var autoEscape = [
  "<",
  ">",
  '"',
  "`",
  " ",
  "\r",
  "\n",
  "	",
  "{",
  "}",
  "|",
  "\\",
  "^",
  "`",
  "'"
];
var autoEscapeMap = new Array(128);
for (var i = 0, len = autoEscapeMap.length; i < len; ++i) {
  autoEscapeMap[i] = "";
}
for (var i = 0, len = autoEscape.length; i < len; ++i) {
  var c = autoEscape[i];
  var esc = encodeURIComponent(c);
  if (esc === c) {
    esc = escape(c);
  }
  autoEscapeMap[c.charCodeAt(0)] = esc;
}
var afterQueryAutoEscapeMap = autoEscapeMap.slice();
autoEscapeMap[92] = "/";
var slashProtocols = Url.prototype._slashProtocols = {
  http: true,
  https: true,
  gopher: true,
  file: true,
  ftp: true,
  "http:": true,
  "https:": true,
  "gopher:": true,
  "file:": true,
  "ftp:": true
};
Url.prototype._protocolCharacters = makeAsciiTable([
  [97, 122],
  [65, 90],
  46,
  43,
  45
]);
Url.prototype._hostEndingCharacters = makeAsciiTable([
  35,
  63,
  47,
  92
]);
Url.prototype._autoEscapeCharacters = makeAsciiTable(
  autoEscape.map(function(v2) {
    return v2.charCodeAt(0);
  })
);
Url.prototype._noPrependSlashHostEnders = makeAsciiTable(
  [
    "<",
    ">",
    "'",
    "`",
    " ",
    "\r",
    "\n",
    "	",
    "{",
    "}",
    "|",
    "^",
    "`",
    '"',
    "%",
    ";"
  ].map(function(v2) {
    return v2.charCodeAt(0);
  })
);
Url.prototype._autoEscapeMap = autoEscapeMap;
Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;
var urlparser = Url;
Url.replace = function Url$Replace() {
  require.cache.url = {
    exports: Url
  };
};
var querystringserializer = QueryStringSerializer$1;
var enc = encodeURIComponent;
var ARRAY = [];
var isArray$1 = Array.isArray;
var getProto = Object.getPrototypeOf;
var oProto = getProto({});
function isObject(obj) {
  if (isArray$1(obj)) {
    return true;
  }
  if (obj === null || typeof obj !== "object") {
    return false;
  }
  var proto = getProto(obj);
  return proto === oProto || proto === null;
}
function QueryStringSerializer$1() {
}
QueryStringSerializer$1.prototype.serialize = function QueryStringSerializer$serialize(obj) {
  if (obj === null || typeof obj !== "object") {
    throw new TypeError("the obj to stringify must be an object");
  }
  var keys3 = Object.keys(obj);
  var len = keys3.length;
  var array = ARRAY;
  var stack = [];
  var ret = [];
  var cur = obj;
  var keyPrefix = "";
  for (var i = 0; i < len; ++i) {
    var key = keys3 === array ? i : keys3[i];
    var value = cur[key];
    if (isObject(value)) {
      stack.push(keyPrefix, cur, keys3, len, i);
      if (keyPrefix === "") {
        keyPrefix = key;
      } else {
        keyPrefix = keyPrefix + "[" + enc(key) + "]";
      }
      if (isArray$1(value)) {
        keys3 = array;
        len = value.length;
      } else {
        keys3 = Object.keys(value);
        len = keys3.length;
      }
      i = -1;
      cur = value;
    } else {
      if (typeof value !== "string") {
        value = "" + value;
      }
      var serializedKey = keyPrefix === "" ? enc(key) : keyPrefix + "[" + enc(key) + "]";
      ret.push(serializedKey + "=" + enc(value));
    }
    if (i === len - 1 && stack.length > 0) {
      i = stack.pop();
      len = stack.pop();
      keys3 = stack.pop();
      cur = stack.pop();
      keyPrefix = stack.pop();
    }
  }
  return ret.join("&");
};
var QueryStringSerializer = querystringserializer;
var querystringparser = QueryStringParser;
var rplus = /\+/g;
var rint = /^[0-9]+$/;
var isArray = Array.isArray;
var haveProp = {}.hasOwnProperty;
function QueryStringParser() {
  this.containsSparse = false;
  this.cacheKey = "";
  this.cacheVal = null;
}
QueryStringParser.maxLength = 32768;
QueryStringParser.maxDepth = 4;
QueryStringParser.maxKeys = 256;
QueryStringParser.parse = function QueryStringParser$Parse(str) {
  if (typeof str === "string") {
    var maxLength = QueryStringParser.maxLength;
    if (str.length > maxLength) {
      throw new RangeError(
        "str is too large (QueryStringParser.maxLength=" + maxLength + ")"
      );
    }
    var parser = new QueryStringParser();
    return parser.parseString(str, false);
  } else if (str !== null && typeof str === "object") {
    var parser = new QueryStringParser();
    return parser.parseObject(str);
  }
  return {};
};
QueryStringParser.stringify = function QueryStringParser$Stringify(value) {
  var serializer = new QueryStringSerializer();
  return serializer.serialize(value);
};
QueryStringParser.prototype.decode = function QueryStringParser$decode(str, shouldDecode, containsPlus) {
  if (shouldDecode === false)
    return str;
  if (containsPlus === true)
    str = str.replace(rplus, " ");
  try {
    return decodeURIComponent(str);
  } catch (e2) {
    return str;
  }
};
QueryStringParser.prototype.maybeArrayIndex = function QueryStringParser$maybeArrayIndex(str, arrayLength) {
  var len = str.length;
  if (len === 0) {
    return arrayLength;
  }
  var ch = str.charCodeAt(0);
  if (ch === 48) {
    return len > 1 ? -1 : 0;
  } else if (48 <= ch && ch <= 57) {
    if (len === 1) {
      return ch - 48;
    } else if (rint.test(str)) {
      var v2 = parseInt(str, 10);
      if (0 < v2 && v2 <= 1073741822) {
        return v2;
      }
    }
  }
  return -1;
};
QueryStringParser.prototype.getSlot = function QueryStringParser$getSlot(dictionary, prevKey, curKey) {
  var slot;
  if (!haveProp.call(dictionary, prevKey)) {
    var index = this.maybeArrayIndex(curKey, 0);
    if (index > -1) {
      slot = [];
    } else {
      slot = {};
    }
    dictionary[prevKey] = slot;
  } else {
    slot = dictionary[prevKey];
  }
  return slot;
};
QueryStringParser.prototype.placeNestedValue = function QueryStringParser$placeNestedValue(dictionary, key, value, i, prevKey, curKey) {
  var slot = this.getSlot(dictionary, prevKey, curKey);
  var index = -1;
  if (isArray(slot)) {
    index = this.maybeArrayIndex(curKey, slot.length);
  }
  var len = key.length;
  var depth = 2;
  var maxDepth = QueryStringParser.maxDepth;
  var start = -1;
  for (; i < len; ++i) {
    var ch = key.charCodeAt(i);
    if (ch === 91) {
      start = i + 1;
    } else if (ch === 93 && start > -1) {
      prevKey = curKey;
      curKey = start === i ? "" : key.substring(start, i);
      start = -1;
      depth++;
      if (depth > maxDepth) {
        throw new RangeError("Nesting depth of keys is too large (QueryStringParser.maxDepth=" + maxDepth + ")");
      }
      slot = this.getSlot(slot, prevKey, curKey);
      index = isArray(slot) ? this.maybeArrayIndex(curKey, slot.length) : -1;
    }
  }
  if (index > -1) {
    if (value !== "") {
      if (index === slot.length) {
        slot.push(value);
      } else {
        this.containsSparse = true;
        slot[index] = value;
      }
    }
  } else {
    this.insert(slot, curKey, value);
  }
};
QueryStringParser.prototype.insert = function QueryStringParser$insert(dictionary, key, value) {
  var ret = null;
  if (haveProp.call(dictionary, key)) {
    var prev = dictionary[key];
    if (isArray(prev)) {
      prev.push(value);
      ret = prev;
    } else {
      ret = [prev, value];
      dictionary[key] = ret;
    }
  } else {
    dictionary[key] = value;
  }
  return ret;
};
QueryStringParser.prototype.push = function QueryStringParser$push(dictionary, key, value) {
  var ret = null;
  if (haveProp.call(dictionary, key)) {
    var prev = dictionary[key];
    prev.push(value);
    ret = prev;
  } else {
    ret = [value];
    dictionary[key] = ret;
  }
  return ret;
};
QueryStringParser.prototype.maybePlaceNestedValue = function QueryStringParser$maybePlaceNestedValue(dictionary, key, value) {
  var len = key.length;
  if (key.charCodeAt(len - 1) !== 93) {
    this.placeValue(dictionary, key, value, false);
    return;
  }
  var start = -1;
  var i = 0;
  var curKey;
  var prevKey;
  for (; i < len; ++i) {
    var ch = key.charCodeAt(i);
    if (ch === 91) {
      start = i + 1;
      prevKey = key.slice(0, i);
    } else if (ch === 93) {
      if (start < 0) {
        this.placeValue(dictionary, key, value, false);
        return;
      }
      curKey = start === i ? "" : key.slice(start, i);
      i++;
      break;
    }
  }
  if (curKey === void 0) {
    this.placeValue(dictionary, key, value, false);
    return;
  }
  if (curKey === "" && value !== "" && i === len) {
    if (key === this.cacheKey) {
      this.cacheVal.push(value);
    } else {
      this.cacheKey = key;
      this.cacheVal = this.push(dictionary, prevKey, value);
    }
  } else {
    this.placeNestedValue(dictionary, key, value, i, prevKey, curKey);
  }
};
QueryStringParser.prototype.placeValue = function QueryStringParser$placeValue(dictionary, key, value, possiblyNested) {
  if (possiblyNested === true) {
    this.maybePlaceNestedValue(dictionary, key, value);
    return;
  }
  if (key === this.cacheKey) {
    this.cacheVal.push(value);
    return;
  }
  var cache = this.insert(dictionary, key, value);
  if (cache !== null) {
    this.cacheKey = key;
    this.cacheVal = cache;
  }
};
QueryStringParser.prototype.compact = function QueryStringParser$compact(obj) {
  if (isArray(obj)) {
    var ret = [];
    var keys3 = Object.keys(obj);
    for (var i = 0, len = keys3.length; i < len; ++i) {
      ret.push(obj[keys3[i]]);
    }
    return ret;
  } else if (typeof obj === "object") {
    var keys3 = Object.keys(obj);
    for (var i = 0, len = keys3.length; i < len; ++i) {
      var key = keys3[i];
      obj[key] = this.compact(obj[key]);
    }
  } else {
    return obj;
  }
};
QueryStringParser.prototype.parseObject = function QueryStringParser$parseObject(obj) {
  var keys3 = Object.keys(obj);
  var len = keys3.length;
  if (len === 0) {
    return {};
  }
  len--;
  var ret = "";
  var key;
  for (var i = 0; i < len; ++i) {
    key = keys3[i];
    ret += key + "=" + obj[key] + "&";
  }
  key = keys3[i];
  ret += key + "=" + obj[key];
  return this.parseString(ret, true);
};
QueryStringParser.prototype.parseString = function QueryStringParser$parseString(str, noDecode) {
  var maxKeys = QueryStringParser.maxKeys;
  var keys3 = 0;
  var decodeKey = false;
  var decodeValue = false;
  var possiblyNested = false;
  var len = str.length;
  var i = 0;
  var dictionary = {};
  var keyStart = 0;
  var keyEnd = 0;
  var valueStart = 0;
  var valueEnd = 0;
  var left = 0;
  var lastIndex = len - 1;
  var containsPlus = false;
  for (; i < len; ++i) {
    var ch = str.charCodeAt(i);
    if (ch === 91) {
      left++;
    } else if (left > 0 && ch === 93) {
      possiblyNested = true;
      left--;
    } else if (left === 0 && ch === 61) {
      var j2 = i + 1;
      keyEnd = i - 1;
      valueEnd = valueStart = j2;
      var key = str.slice(keyStart, keyEnd + 1);
      key = this.decode(key, decodeKey, containsPlus);
      decodeKey = false;
      for (; j2 < len; ++j2) {
        ch = str.charCodeAt(j2);
        if ((ch === 43 || ch === 37) && !noDecode) {
          if (ch === 43)
            containsPlus = true;
          decodeValue = true;
        }
        if (ch === 38 || j2 === lastIndex) {
          valueEnd = j2;
          i = j2;
          if (ch === 38) {
            valueEnd--;
          }
          var value = str.slice(valueStart, valueEnd + 1);
          value = this.decode(value, decodeValue, containsPlus);
          this.placeValue(dictionary, key, value, possiblyNested);
          containsPlus = decodeValue = false;
          possiblyNested = false;
          keyStart = j2 + 1;
          keys3++;
          if (keys3 > maxKeys) {
            throw new RangeError("Amount of keys is too large (QueryStringParser.maxKeys=" + maxKeys + ")");
          }
          break;
        }
      }
    } else if ((ch === 43 || ch === 37) && !noDecode) {
      if (ch === 43)
        containsPlus = true;
      decodeKey = true;
    }
  }
  if (keyStart !== len) {
    var value = "";
    var key = str.slice(keyStart, len);
    key = this.decode(key, decodeKey, containsPlus);
    this.placeValue(dictionary, key, value, possiblyNested);
  }
  if (this.containsSparse) {
    this.compact(dictionary);
  }
  return dictionary;
};
var tweakpane = { exports: {} };
/*! Tweakpane 3.1.10 (c) 2016 cocopon, licensed under the MIT license. */
(function(module, exports) {
  (function(global2, factory) {
    factory(exports);
  })(commonjsGlobal, function(exports2) {
    class Semver {
      constructor(text) {
        const [core, prerelease] = text.split("-");
        const coreComps = core.split(".");
        this.major = parseInt(coreComps[0], 10);
        this.minor = parseInt(coreComps[1], 10);
        this.patch = parseInt(coreComps[2], 10);
        this.prerelease = prerelease !== null && prerelease !== void 0 ? prerelease : null;
      }
      toString() {
        const core = [this.major, this.minor, this.patch].join(".");
        return this.prerelease !== null ? [core, this.prerelease].join("-") : core;
      }
    }
    class BladeApi {
      constructor(controller) {
        this.controller_ = controller;
      }
      get element() {
        return this.controller_.view.element;
      }
      get disabled() {
        return this.controller_.viewProps.get("disabled");
      }
      set disabled(disabled) {
        this.controller_.viewProps.set("disabled", disabled);
      }
      get hidden() {
        return this.controller_.viewProps.get("hidden");
      }
      set hidden(hidden) {
        this.controller_.viewProps.set("hidden", hidden);
      }
      dispose() {
        this.controller_.viewProps.set("disposed", true);
      }
    }
    class TpEvent {
      constructor(target) {
        this.target = target;
      }
    }
    class TpChangeEvent extends TpEvent {
      constructor(target, value, presetKey, last) {
        super(target);
        this.value = value;
        this.presetKey = presetKey;
        this.last = last !== null && last !== void 0 ? last : true;
      }
    }
    class TpUpdateEvent extends TpEvent {
      constructor(target, value, presetKey) {
        super(target);
        this.value = value;
        this.presetKey = presetKey;
      }
    }
    class TpFoldEvent extends TpEvent {
      constructor(target, expanded) {
        super(target);
        this.expanded = expanded;
      }
    }
    class TpTabSelectEvent extends TpEvent {
      constructor(target, index) {
        super(target);
        this.index = index;
      }
    }
    function forceCast(v2) {
      return v2;
    }
    function isEmpty(value) {
      return value === null || value === void 0;
    }
    function deepEqualsArray(a1, a2) {
      if (a1.length !== a2.length) {
        return false;
      }
      for (let i = 0; i < a1.length; i++) {
        if (a1[i] !== a2[i]) {
          return false;
        }
      }
      return true;
    }
    function isPropertyWritable(obj, key) {
      let target = obj;
      do {
        const d2 = Object.getOwnPropertyDescriptor(target, key);
        if (d2 && (d2.set !== void 0 || d2.writable === true)) {
          return true;
        }
        target = Object.getPrototypeOf(target);
      } while (target !== null);
      return false;
    }
    const CREATE_MESSAGE_MAP = {
      alreadydisposed: () => "View has been already disposed",
      invalidparams: (context2) => `Invalid parameters for '${context2.name}'`,
      nomatchingcontroller: (context2) => `No matching controller for '${context2.key}'`,
      nomatchingview: (context2) => `No matching view for '${JSON.stringify(context2.params)}'`,
      notbindable: () => `Value is not bindable`,
      propertynotfound: (context2) => `Property '${context2.name}' not found`,
      shouldneverhappen: () => "This error should never happen"
    };
    class TpError {
      static alreadyDisposed() {
        return new TpError({ type: "alreadydisposed" });
      }
      static notBindable() {
        return new TpError({
          type: "notbindable"
        });
      }
      static propertyNotFound(name) {
        return new TpError({
          type: "propertynotfound",
          context: {
            name
          }
        });
      }
      static shouldNeverHappen() {
        return new TpError({ type: "shouldneverhappen" });
      }
      constructor(config) {
        var _a2;
        this.message = (_a2 = CREATE_MESSAGE_MAP[config.type](forceCast(config.context))) !== null && _a2 !== void 0 ? _a2 : "Unexpected error";
        this.name = this.constructor.name;
        this.stack = new Error(this.message).stack;
        this.type = config.type;
      }
    }
    class BindingTarget {
      constructor(obj, key, opt_id) {
        this.obj_ = obj;
        this.key_ = key;
        this.presetKey_ = opt_id !== null && opt_id !== void 0 ? opt_id : key;
      }
      static isBindable(obj) {
        if (obj === null) {
          return false;
        }
        if (typeof obj !== "object" && typeof obj !== "function") {
          return false;
        }
        return true;
      }
      get key() {
        return this.key_;
      }
      get presetKey() {
        return this.presetKey_;
      }
      read() {
        return this.obj_[this.key_];
      }
      write(value) {
        this.obj_[this.key_] = value;
      }
      writeProperty(name, value) {
        const valueObj = this.read();
        if (!BindingTarget.isBindable(valueObj)) {
          throw TpError.notBindable();
        }
        if (!(name in valueObj)) {
          throw TpError.propertyNotFound(name);
        }
        valueObj[name] = value;
      }
    }
    class ButtonApi extends BladeApi {
      get label() {
        return this.controller_.props.get("label");
      }
      set label(label) {
        this.controller_.props.set("label", label);
      }
      get title() {
        var _a2;
        return (_a2 = this.controller_.valueController.props.get("title")) !== null && _a2 !== void 0 ? _a2 : "";
      }
      set title(title) {
        this.controller_.valueController.props.set("title", title);
      }
      on(eventName, handler) {
        const bh = handler.bind(this);
        const emitter = this.controller_.valueController.emitter;
        emitter.on(eventName, () => {
          bh(new TpEvent(this));
        });
        return this;
      }
    }
    class Emitter2 {
      constructor() {
        this.observers_ = {};
      }
      on(eventName, handler) {
        let observers = this.observers_[eventName];
        if (!observers) {
          observers = this.observers_[eventName] = [];
        }
        observers.push({
          handler
        });
        return this;
      }
      off(eventName, handler) {
        const observers = this.observers_[eventName];
        if (observers) {
          this.observers_[eventName] = observers.filter((observer) => {
            return observer.handler !== handler;
          });
        }
        return this;
      }
      emit(eventName, event) {
        const observers = this.observers_[eventName];
        if (!observers) {
          return;
        }
        observers.forEach((observer) => {
          observer.handler(event);
        });
      }
    }
    const PREFIX = "tp";
    function ClassName(viewName) {
      const fn = (opt_elementName, opt_modifier) => {
        return [
          PREFIX,
          "-",
          viewName,
          "v",
          opt_elementName ? `_${opt_elementName}` : "",
          opt_modifier ? `-${opt_modifier}` : ""
        ].join("");
      };
      return fn;
    }
    function compose(h1, h2) {
      return (input) => h2(h1(input));
    }
    function extractValue(ev) {
      return ev.rawValue;
    }
    function bindValue(value, applyValue) {
      value.emitter.on("change", compose(extractValue, applyValue));
      applyValue(value.rawValue);
    }
    function bindValueMap(valueMap, key, applyValue) {
      bindValue(valueMap.value(key), applyValue);
    }
    function applyClass(elem, className2, active) {
      if (active) {
        elem.classList.add(className2);
      } else {
        elem.classList.remove(className2);
      }
    }
    function valueToClassName(elem, className2) {
      return (value) => {
        applyClass(elem, className2, value);
      };
    }
    function bindValueToTextContent(value, elem) {
      bindValue(value, (text) => {
        elem.textContent = text !== null && text !== void 0 ? text : "";
      });
    }
    const className$q = ClassName("btn");
    class ButtonView {
      constructor(doc, config) {
        this.element = doc.createElement("div");
        this.element.classList.add(className$q());
        config.viewProps.bindClassModifiers(this.element);
        const buttonElem = doc.createElement("button");
        buttonElem.classList.add(className$q("b"));
        config.viewProps.bindDisabled(buttonElem);
        this.element.appendChild(buttonElem);
        this.buttonElement = buttonElem;
        const titleElem = doc.createElement("div");
        titleElem.classList.add(className$q("t"));
        bindValueToTextContent(config.props.value("title"), titleElem);
        this.buttonElement.appendChild(titleElem);
      }
    }
    class ButtonController {
      constructor(doc, config) {
        this.emitter = new Emitter2();
        this.onClick_ = this.onClick_.bind(this);
        this.props = config.props;
        this.viewProps = config.viewProps;
        this.view = new ButtonView(doc, {
          props: this.props,
          viewProps: this.viewProps
        });
        this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", {
          sender: this
        });
      }
    }
    class BoundValue {
      constructor(initialValue, config) {
        var _a2;
        this.constraint_ = config === null || config === void 0 ? void 0 : config.constraint;
        this.equals_ = (_a2 = config === null || config === void 0 ? void 0 : config.equals) !== null && _a2 !== void 0 ? _a2 : (v1, v2) => v1 === v2;
        this.emitter = new Emitter2();
        this.rawValue_ = initialValue;
      }
      get constraint() {
        return this.constraint_;
      }
      get rawValue() {
        return this.rawValue_;
      }
      set rawValue(rawValue) {
        this.setRawValue(rawValue, {
          forceEmit: false,
          last: true
        });
      }
      setRawValue(rawValue, options) {
        const opts = options !== null && options !== void 0 ? options : {
          forceEmit: false,
          last: true
        };
        const constrainedValue = this.constraint_ ? this.constraint_.constrain(rawValue) : rawValue;
        const prevValue = this.rawValue_;
        const changed = !this.equals_(prevValue, constrainedValue);
        if (!changed && !opts.forceEmit) {
          return;
        }
        this.emitter.emit("beforechange", {
          sender: this
        });
        this.rawValue_ = constrainedValue;
        this.emitter.emit("change", {
          options: opts,
          previousRawValue: prevValue,
          rawValue: constrainedValue,
          sender: this
        });
      }
    }
    class PrimitiveValue {
      constructor(initialValue) {
        this.emitter = new Emitter2();
        this.value_ = initialValue;
      }
      get rawValue() {
        return this.value_;
      }
      set rawValue(value) {
        this.setRawValue(value, {
          forceEmit: false,
          last: true
        });
      }
      setRawValue(value, options) {
        const opts = options !== null && options !== void 0 ? options : {
          forceEmit: false,
          last: true
        };
        const prevValue = this.value_;
        if (prevValue === value && !opts.forceEmit) {
          return;
        }
        this.emitter.emit("beforechange", {
          sender: this
        });
        this.value_ = value;
        this.emitter.emit("change", {
          options: opts,
          previousRawValue: prevValue,
          rawValue: this.value_,
          sender: this
        });
      }
    }
    function createValue(initialValue, config) {
      const constraint = config === null || config === void 0 ? void 0 : config.constraint;
      const equals2 = config === null || config === void 0 ? void 0 : config.equals;
      if (!constraint && !equals2) {
        return new PrimitiveValue(initialValue);
      }
      return new BoundValue(initialValue, config);
    }
    class ValueMap {
      constructor(valueMap) {
        this.emitter = new Emitter2();
        this.valMap_ = valueMap;
        for (const key in this.valMap_) {
          const v2 = this.valMap_[key];
          v2.emitter.on("change", () => {
            this.emitter.emit("change", {
              key,
              sender: this
            });
          });
        }
      }
      static createCore(initialValue) {
        const keys3 = Object.keys(initialValue);
        return keys3.reduce((o2, key) => {
          return Object.assign(o2, {
            [key]: createValue(initialValue[key])
          });
        }, {});
      }
      static fromObject(initialValue) {
        const core = this.createCore(initialValue);
        return new ValueMap(core);
      }
      get(key) {
        return this.valMap_[key].rawValue;
      }
      set(key, value) {
        this.valMap_[key].rawValue = value;
      }
      value(key) {
        return this.valMap_[key];
      }
    }
    function parseObject2(value, keyToParserMap) {
      const keys3 = Object.keys(keyToParserMap);
      const result = keys3.reduce((tmp, key) => {
        if (tmp === void 0) {
          return void 0;
        }
        const parser = keyToParserMap[key];
        const result2 = parser(value[key]);
        return result2.succeeded ? Object.assign(Object.assign({}, tmp), { [key]: result2.value }) : void 0;
      }, {});
      return forceCast(result);
    }
    function parseArray(value, parseItem) {
      return value.reduce((tmp, item) => {
        if (tmp === void 0) {
          return void 0;
        }
        const result = parseItem(item);
        if (!result.succeeded || result.value === void 0) {
          return void 0;
        }
        return [...tmp, result.value];
      }, []);
    }
    function isObject2(value) {
      if (value === null) {
        return false;
      }
      return typeof value === "object";
    }
    function createParamsParserBuilder(parse2) {
      return (optional) => (v2) => {
        if (!optional && v2 === void 0) {
          return {
            succeeded: false,
            value: void 0
          };
        }
        if (optional && v2 === void 0) {
          return {
            succeeded: true,
            value: void 0
          };
        }
        const result = parse2(v2);
        return result !== void 0 ? {
          succeeded: true,
          value: result
        } : {
          succeeded: false,
          value: void 0
        };
      };
    }
    function createParamsParserBuilders(optional) {
      return {
        custom: (parse2) => createParamsParserBuilder(parse2)(optional),
        boolean: createParamsParserBuilder((v2) => typeof v2 === "boolean" ? v2 : void 0)(optional),
        number: createParamsParserBuilder((v2) => typeof v2 === "number" ? v2 : void 0)(optional),
        string: createParamsParserBuilder((v2) => typeof v2 === "string" ? v2 : void 0)(optional),
        function: createParamsParserBuilder((v2) => typeof v2 === "function" ? v2 : void 0)(optional),
        constant: (value) => createParamsParserBuilder((v2) => v2 === value ? value : void 0)(optional),
        raw: createParamsParserBuilder((v2) => v2)(optional),
        object: (keyToParserMap) => createParamsParserBuilder((v2) => {
          if (!isObject2(v2)) {
            return void 0;
          }
          return parseObject2(v2, keyToParserMap);
        })(optional),
        array: (itemParser) => createParamsParserBuilder((v2) => {
          if (!Array.isArray(v2)) {
            return void 0;
          }
          return parseArray(v2, itemParser);
        })(optional)
      };
    }
    const ParamsParsers = {
      optional: createParamsParserBuilders(true),
      required: createParamsParserBuilders(false)
    };
    function parseParams(value, keyToParserMap) {
      const result = ParamsParsers.required.object(keyToParserMap)(value);
      return result.succeeded ? result.value : void 0;
    }
    function warnMissing(info) {
      console.warn([
        `Missing '${info.key}' of ${info.target} in ${info.place}.`,
        "Please rebuild plugins with the latest core package."
      ].join(" "));
    }
    function disposeElement(elem) {
      if (elem && elem.parentElement) {
        elem.parentElement.removeChild(elem);
      }
      return null;
    }
    class ReadonlyValue {
      constructor(value) {
        this.value_ = value;
      }
      static create(value) {
        return [
          new ReadonlyValue(value),
          (rawValue, options) => {
            value.setRawValue(rawValue, options);
          }
        ];
      }
      get emitter() {
        return this.value_.emitter;
      }
      get rawValue() {
        return this.value_.rawValue;
      }
    }
    const className$p = ClassName("");
    function valueToModifier(elem, modifier) {
      return valueToClassName(elem, className$p(void 0, modifier));
    }
    class ViewProps extends ValueMap {
      constructor(valueMap) {
        var _a2;
        super(valueMap);
        this.onDisabledChange_ = this.onDisabledChange_.bind(this);
        this.onParentChange_ = this.onParentChange_.bind(this);
        this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this);
        [this.globalDisabled_, this.setGlobalDisabled_] = ReadonlyValue.create(createValue(this.getGlobalDisabled_()));
        this.value("disabled").emitter.on("change", this.onDisabledChange_);
        this.value("parent").emitter.on("change", this.onParentChange_);
        (_a2 = this.get("parent")) === null || _a2 === void 0 ? void 0 : _a2.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
      }
      static create(opt_initialValue) {
        var _a2, _b2, _c2;
        const initialValue = opt_initialValue !== null && opt_initialValue !== void 0 ? opt_initialValue : {};
        return new ViewProps(ValueMap.createCore({
          disabled: (_a2 = initialValue.disabled) !== null && _a2 !== void 0 ? _a2 : false,
          disposed: false,
          hidden: (_b2 = initialValue.hidden) !== null && _b2 !== void 0 ? _b2 : false,
          parent: (_c2 = initialValue.parent) !== null && _c2 !== void 0 ? _c2 : null
        }));
      }
      get globalDisabled() {
        return this.globalDisabled_;
      }
      bindClassModifiers(elem) {
        bindValue(this.globalDisabled_, valueToModifier(elem, "disabled"));
        bindValueMap(this, "hidden", valueToModifier(elem, "hidden"));
      }
      bindDisabled(target) {
        bindValue(this.globalDisabled_, (disabled) => {
          target.disabled = disabled;
        });
      }
      bindTabIndex(elem) {
        bindValue(this.globalDisabled_, (disabled) => {
          elem.tabIndex = disabled ? -1 : 0;
        });
      }
      handleDispose(callback) {
        this.value("disposed").emitter.on("change", (disposed) => {
          if (disposed) {
            callback();
          }
        });
      }
      getGlobalDisabled_() {
        const parent = this.get("parent");
        const parentDisabled = parent ? parent.globalDisabled.rawValue : false;
        return parentDisabled || this.get("disabled");
      }
      updateGlobalDisabled_() {
        this.setGlobalDisabled_(this.getGlobalDisabled_());
      }
      onDisabledChange_() {
        this.updateGlobalDisabled_();
      }
      onParentGlobalDisabledChange_() {
        this.updateGlobalDisabled_();
      }
      onParentChange_(ev) {
        var _a2;
        const prevParent = ev.previousRawValue;
        prevParent === null || prevParent === void 0 ? void 0 : prevParent.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_);
        (_a2 = this.get("parent")) === null || _a2 === void 0 ? void 0 : _a2.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
        this.updateGlobalDisabled_();
      }
    }
    function getAllBladePositions() {
      return ["veryfirst", "first", "last", "verylast"];
    }
    const className$o = ClassName("");
    const POS_TO_CLASS_NAME_MAP = {
      veryfirst: "vfst",
      first: "fst",
      last: "lst",
      verylast: "vlst"
    };
    class BladeController {
      constructor(config) {
        this.parent_ = null;
        this.blade = config.blade;
        this.view = config.view;
        this.viewProps = config.viewProps;
        const elem = this.view.element;
        this.blade.value("positions").emitter.on("change", () => {
          getAllBladePositions().forEach((pos) => {
            elem.classList.remove(className$o(void 0, POS_TO_CLASS_NAME_MAP[pos]));
          });
          this.blade.get("positions").forEach((pos) => {
            elem.classList.add(className$o(void 0, POS_TO_CLASS_NAME_MAP[pos]));
          });
        });
        this.viewProps.handleDispose(() => {
          disposeElement(elem);
        });
      }
      get parent() {
        return this.parent_;
      }
      set parent(parent) {
        this.parent_ = parent;
        if (!("parent" in this.viewProps.valMap_)) {
          warnMissing({
            key: "parent",
            target: ViewProps.name,
            place: "BladeController.parent"
          });
          return;
        }
        this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
      }
    }
    const SVG_NS = "http://www.w3.org/2000/svg";
    function forceReflow(element) {
      element.offsetHeight;
    }
    function disableTransitionTemporarily(element, callback) {
      const t2 = element.style.transition;
      element.style.transition = "none";
      callback();
      element.style.transition = t2;
    }
    function supportsTouch(doc) {
      return doc.ontouchstart !== void 0;
    }
    function getGlobalObject() {
      return globalThis;
    }
    function getWindowDocument() {
      const globalObj = forceCast(getGlobalObject());
      return globalObj.document;
    }
    function getCanvasContext(canvasElement) {
      const win = canvasElement.ownerDocument.defaultView;
      if (!win) {
        return null;
      }
      const isBrowser = "document" in win;
      return isBrowser ? canvasElement.getContext("2d", {
        willReadFrequently: true
      }) : null;
    }
    const ICON_ID_TO_INNER_HTML_MAP = {
      check: '<path d="M2 8l4 4l8 -8"/>',
      dropdown: '<path d="M5 7h6l-3 3 z"/>',
      p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
    };
    function createSvgIconElement(document2, iconId) {
      const elem = document2.createElementNS(SVG_NS, "svg");
      elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP[iconId];
      return elem;
    }
    function insertElementAt(parentElement, element, index) {
      parentElement.insertBefore(element, parentElement.children[index]);
    }
    function removeElement(element) {
      if (element.parentElement) {
        element.parentElement.removeChild(element);
      }
    }
    function removeChildElements(element) {
      while (element.children.length > 0) {
        element.removeChild(element.children[0]);
      }
    }
    function removeChildNodes(element) {
      while (element.childNodes.length > 0) {
        element.removeChild(element.childNodes[0]);
      }
    }
    function findNextTarget(ev) {
      if (ev.relatedTarget) {
        return forceCast(ev.relatedTarget);
      }
      if ("explicitOriginalTarget" in ev) {
        return ev.explicitOriginalTarget;
      }
      return null;
    }
    const className$n = ClassName("lbl");
    function createLabelNode(doc, label) {
      const frag2 = doc.createDocumentFragment();
      const lineNodes = label.split("\n").map((line) => {
        return doc.createTextNode(line);
      });
      lineNodes.forEach((lineNode, index) => {
        if (index > 0) {
          frag2.appendChild(doc.createElement("br"));
        }
        frag2.appendChild(lineNode);
      });
      return frag2;
    }
    class LabelView {
      constructor(doc, config) {
        this.element = doc.createElement("div");
        this.element.classList.add(className$n());
        config.viewProps.bindClassModifiers(this.element);
        const labelElem = doc.createElement("div");
        labelElem.classList.add(className$n("l"));
        bindValueMap(config.props, "label", (value) => {
          if (isEmpty(value)) {
            this.element.classList.add(className$n(void 0, "nol"));
          } else {
            this.element.classList.remove(className$n(void 0, "nol"));
            removeChildNodes(labelElem);
            labelElem.appendChild(createLabelNode(doc, value));
          }
        });
        this.element.appendChild(labelElem);
        this.labelElement = labelElem;
        const valueElem = doc.createElement("div");
        valueElem.classList.add(className$n("v"));
        this.element.appendChild(valueElem);
        this.valueElement = valueElem;
      }
    }
    class LabelController extends BladeController {
      constructor(doc, config) {
        const viewProps = config.valueController.viewProps;
        super(Object.assign(Object.assign({}, config), { view: new LabelView(doc, {
          props: config.props,
          viewProps
        }), viewProps }));
        this.props = config.props;
        this.valueController = config.valueController;
        this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    const ButtonBladePlugin = {
      id: "button",
      type: "blade",
      accept(params) {
        const p2 = ParamsParsers;
        const result = parseParams(params, {
          title: p2.required.string,
          view: p2.required.constant("button"),
          label: p2.optional.string
        });
        return result ? { params: result } : null;
      },
      controller(args) {
        return new LabelController(args.document, {
          blade: args.blade,
          props: ValueMap.fromObject({
            label: args.params.label
          }),
          valueController: new ButtonController(args.document, {
            props: ValueMap.fromObject({
              title: args.params.title
            }),
            viewProps: args.viewProps
          })
        });
      },
      api(args) {
        if (!(args.controller instanceof LabelController)) {
          return null;
        }
        if (!(args.controller.valueController instanceof ButtonController)) {
          return null;
        }
        return new ButtonApi(args.controller);
      }
    };
    class ValueBladeController extends BladeController {
      constructor(config) {
        super(config);
        this.value = config.value;
      }
    }
    function createBlade() {
      return new ValueMap({
        positions: createValue([], {
          equals: deepEqualsArray
        })
      });
    }
    class Foldable extends ValueMap {
      constructor(valueMap) {
        super(valueMap);
      }
      static create(expanded) {
        const coreObj = {
          completed: true,
          expanded,
          expandedHeight: null,
          shouldFixHeight: false,
          temporaryExpanded: null
        };
        const core = ValueMap.createCore(coreObj);
        return new Foldable(core);
      }
      get styleExpanded() {
        var _a2;
        return (_a2 = this.get("temporaryExpanded")) !== null && _a2 !== void 0 ? _a2 : this.get("expanded");
      }
      get styleHeight() {
        if (!this.styleExpanded) {
          return "0";
        }
        const exHeight = this.get("expandedHeight");
        if (this.get("shouldFixHeight") && !isEmpty(exHeight)) {
          return `${exHeight}px`;
        }
        return "auto";
      }
      bindExpandedClass(elem, expandedClassName) {
        const onExpand = () => {
          const expanded = this.styleExpanded;
          if (expanded) {
            elem.classList.add(expandedClassName);
          } else {
            elem.classList.remove(expandedClassName);
          }
        };
        bindValueMap(this, "expanded", onExpand);
        bindValueMap(this, "temporaryExpanded", onExpand);
      }
      cleanUpTransition() {
        this.set("shouldFixHeight", false);
        this.set("expandedHeight", null);
        this.set("completed", true);
      }
    }
    function computeExpandedFolderHeight(folder, containerElement) {
      let height = 0;
      disableTransitionTemporarily(containerElement, () => {
        folder.set("expandedHeight", null);
        folder.set("temporaryExpanded", true);
        forceReflow(containerElement);
        height = containerElement.clientHeight;
        folder.set("temporaryExpanded", null);
        forceReflow(containerElement);
      });
      return height;
    }
    function applyHeight(foldable, elem) {
      elem.style.height = foldable.styleHeight;
    }
    function bindFoldable(foldable, elem) {
      foldable.value("expanded").emitter.on("beforechange", () => {
        foldable.set("completed", false);
        if (isEmpty(foldable.get("expandedHeight"))) {
          const h2 = computeExpandedFolderHeight(foldable, elem);
          if (h2 > 0) {
            foldable.set("expandedHeight", h2);
          }
        }
        foldable.set("shouldFixHeight", true);
        forceReflow(elem);
      });
      foldable.emitter.on("change", () => {
        applyHeight(foldable, elem);
      });
      applyHeight(foldable, elem);
      elem.addEventListener("transitionend", (ev) => {
        if (ev.propertyName !== "height") {
          return;
        }
        foldable.cleanUpTransition();
      });
    }
    class RackLikeApi extends BladeApi {
      constructor(controller, rackApi) {
        super(controller);
        this.rackApi_ = rackApi;
      }
    }
    function addButtonAsBlade(api, params) {
      return api.addBlade(Object.assign(Object.assign({}, params), { view: "button" }));
    }
    function addFolderAsBlade(api, params) {
      return api.addBlade(Object.assign(Object.assign({}, params), { view: "folder" }));
    }
    function addSeparatorAsBlade(api, opt_params) {
      const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
      return api.addBlade(Object.assign(Object.assign({}, params), { view: "separator" }));
    }
    function addTabAsBlade(api, params) {
      return api.addBlade(Object.assign(Object.assign({}, params), { view: "tab" }));
    }
    class NestedOrderedSet {
      constructor(extract) {
        this.emitter = new Emitter2();
        this.items_ = [];
        this.cache_ = /* @__PURE__ */ new Set();
        this.onSubListAdd_ = this.onSubListAdd_.bind(this);
        this.onSubListRemove_ = this.onSubListRemove_.bind(this);
        this.extract_ = extract;
      }
      get items() {
        return this.items_;
      }
      allItems() {
        return Array.from(this.cache_);
      }
      find(callback) {
        for (const item of this.allItems()) {
          if (callback(item)) {
            return item;
          }
        }
        return null;
      }
      includes(item) {
        return this.cache_.has(item);
      }
      add(item, opt_index) {
        if (this.includes(item)) {
          throw TpError.shouldNeverHappen();
        }
        const index = opt_index !== void 0 ? opt_index : this.items_.length;
        this.items_.splice(index, 0, item);
        this.cache_.add(item);
        const subList = this.extract_(item);
        if (subList) {
          subList.emitter.on("add", this.onSubListAdd_);
          subList.emitter.on("remove", this.onSubListRemove_);
          subList.allItems().forEach((item2) => {
            this.cache_.add(item2);
          });
        }
        this.emitter.emit("add", {
          index,
          item,
          root: this,
          target: this
        });
      }
      remove(item) {
        const index = this.items_.indexOf(item);
        if (index < 0) {
          return;
        }
        this.items_.splice(index, 1);
        this.cache_.delete(item);
        const subList = this.extract_(item);
        if (subList) {
          subList.emitter.off("add", this.onSubListAdd_);
          subList.emitter.off("remove", this.onSubListRemove_);
        }
        this.emitter.emit("remove", {
          index,
          item,
          root: this,
          target: this
        });
      }
      onSubListAdd_(ev) {
        this.cache_.add(ev.item);
        this.emitter.emit("add", {
          index: ev.index,
          item: ev.item,
          root: this,
          target: ev.target
        });
      }
      onSubListRemove_(ev) {
        this.cache_.delete(ev.item);
        this.emitter.emit("remove", {
          index: ev.index,
          item: ev.item,
          root: this,
          target: ev.target
        });
      }
    }
    class InputBindingApi extends BladeApi {
      constructor(controller) {
        super(controller);
        this.onBindingChange_ = this.onBindingChange_.bind(this);
        this.emitter_ = new Emitter2();
        this.controller_.binding.emitter.on("change", this.onBindingChange_);
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(label) {
        this.controller_.props.set("label", label);
      }
      on(eventName, handler) {
        const bh = handler.bind(this);
        this.emitter_.on(eventName, (ev) => {
          bh(ev.event);
        });
        return this;
      }
      refresh() {
        this.controller_.binding.read();
      }
      onBindingChange_(ev) {
        const value = ev.sender.target.read();
        this.emitter_.emit("change", {
          event: new TpChangeEvent(this, forceCast(value), this.controller_.binding.target.presetKey, ev.options.last)
        });
      }
    }
    class InputBindingController extends LabelController {
      constructor(doc, config) {
        super(doc, config);
        this.binding = config.binding;
      }
    }
    class MonitorBindingApi extends BladeApi {
      constructor(controller) {
        super(controller);
        this.onBindingUpdate_ = this.onBindingUpdate_.bind(this);
        this.emitter_ = new Emitter2();
        this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(label) {
        this.controller_.props.set("label", label);
      }
      on(eventName, handler) {
        const bh = handler.bind(this);
        this.emitter_.on(eventName, (ev) => {
          bh(ev.event);
        });
        return this;
      }
      refresh() {
        this.controller_.binding.read();
      }
      onBindingUpdate_(ev) {
        const value = ev.sender.target.read();
        this.emitter_.emit("update", {
          event: new TpUpdateEvent(this, forceCast(value), this.controller_.binding.target.presetKey)
        });
      }
    }
    class MonitorBindingController extends LabelController {
      constructor(doc, config) {
        super(doc, config);
        this.binding = config.binding;
        this.viewProps.bindDisabled(this.binding.ticker);
        this.viewProps.handleDispose(() => {
          this.binding.dispose();
        });
      }
    }
    function findSubBladeApiSet(api) {
      if (api instanceof RackApi) {
        return api["apiSet_"];
      }
      if (api instanceof RackLikeApi) {
        return api["rackApi_"]["apiSet_"];
      }
      return null;
    }
    function getApiByController(apiSet, controller) {
      const api = apiSet.find((api2) => api2.controller_ === controller);
      if (!api) {
        throw TpError.shouldNeverHappen();
      }
      return api;
    }
    function createBindingTarget(obj, key, opt_id) {
      if (!BindingTarget.isBindable(obj)) {
        throw TpError.notBindable();
      }
      return new BindingTarget(obj, key, opt_id);
    }
    class RackApi extends BladeApi {
      constructor(controller, pool) {
        super(controller);
        this.onRackAdd_ = this.onRackAdd_.bind(this);
        this.onRackRemove_ = this.onRackRemove_.bind(this);
        this.onRackInputChange_ = this.onRackInputChange_.bind(this);
        this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this);
        this.emitter_ = new Emitter2();
        this.apiSet_ = new NestedOrderedSet(findSubBladeApiSet);
        this.pool_ = pool;
        const rack = this.controller_.rack;
        rack.emitter.on("add", this.onRackAdd_);
        rack.emitter.on("remove", this.onRackRemove_);
        rack.emitter.on("inputchange", this.onRackInputChange_);
        rack.emitter.on("monitorupdate", this.onRackMonitorUpdate_);
        rack.children.forEach((bc) => {
          this.setUpApi_(bc);
        });
      }
      get children() {
        return this.controller_.rack.children.map((bc) => getApiByController(this.apiSet_, bc));
      }
      addInput(object, key, opt_params) {
        const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
        const doc = this.controller_.view.element.ownerDocument;
        const bc = this.pool_.createInput(doc, createBindingTarget(object, key, params.presetKey), params);
        const api = new InputBindingApi(bc);
        return this.add(api, params.index);
      }
      addMonitor(object, key, opt_params) {
        const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
        const doc = this.controller_.view.element.ownerDocument;
        const bc = this.pool_.createMonitor(doc, createBindingTarget(object, key), params);
        const api = new MonitorBindingApi(bc);
        return forceCast(this.add(api, params.index));
      }
      addFolder(params) {
        return addFolderAsBlade(this, params);
      }
      addButton(params) {
        return addButtonAsBlade(this, params);
      }
      addSeparator(opt_params) {
        return addSeparatorAsBlade(this, opt_params);
      }
      addTab(params) {
        return addTabAsBlade(this, params);
      }
      add(api, opt_index) {
        this.controller_.rack.add(api.controller_, opt_index);
        const gapi = this.apiSet_.find((a2) => a2.controller_ === api.controller_);
        if (gapi) {
          this.apiSet_.remove(gapi);
        }
        this.apiSet_.add(api);
        return api;
      }
      remove(api) {
        this.controller_.rack.remove(api.controller_);
      }
      addBlade(params) {
        const doc = this.controller_.view.element.ownerDocument;
        const bc = this.pool_.createBlade(doc, params);
        const api = this.pool_.createBladeApi(bc);
        return this.add(api, params.index);
      }
      on(eventName, handler) {
        const bh = handler.bind(this);
        this.emitter_.on(eventName, (ev) => {
          bh(ev.event);
        });
        return this;
      }
      setUpApi_(bc) {
        const api = this.apiSet_.find((api2) => api2.controller_ === bc);
        if (!api) {
          this.apiSet_.add(this.pool_.createBladeApi(bc));
        }
      }
      onRackAdd_(ev) {
        this.setUpApi_(ev.bladeController);
      }
      onRackRemove_(ev) {
        if (ev.isRoot) {
          const api = getApiByController(this.apiSet_, ev.bladeController);
          this.apiSet_.remove(api);
        }
      }
      onRackInputChange_(ev) {
        const bc = ev.bladeController;
        if (bc instanceof InputBindingController) {
          const api = getApiByController(this.apiSet_, bc);
          const binding = bc.binding;
          this.emitter_.emit("change", {
            event: new TpChangeEvent(api, forceCast(binding.target.read()), binding.target.presetKey, ev.options.last)
          });
        } else if (bc instanceof ValueBladeController) {
          const api = getApiByController(this.apiSet_, bc);
          this.emitter_.emit("change", {
            event: new TpChangeEvent(api, bc.value.rawValue, void 0, ev.options.last)
          });
        }
      }
      onRackMonitorUpdate_(ev) {
        if (!(ev.bladeController instanceof MonitorBindingController)) {
          throw TpError.shouldNeverHappen();
        }
        const api = getApiByController(this.apiSet_, ev.bladeController);
        const binding = ev.bladeController.binding;
        this.emitter_.emit("update", {
          event: new TpUpdateEvent(api, forceCast(binding.target.read()), binding.target.presetKey)
        });
      }
    }
    class FolderApi extends RackLikeApi {
      constructor(controller, pool) {
        super(controller, new RackApi(controller.rackController, pool));
        this.emitter_ = new Emitter2();
        this.controller_.foldable.value("expanded").emitter.on("change", (ev) => {
          this.emitter_.emit("fold", {
            event: new TpFoldEvent(this, ev.sender.rawValue)
          });
        });
        this.rackApi_.on("change", (ev) => {
          this.emitter_.emit("change", {
            event: ev
          });
        });
        this.rackApi_.on("update", (ev) => {
          this.emitter_.emit("update", {
            event: ev
          });
        });
      }
      get expanded() {
        return this.controller_.foldable.get("expanded");
      }
      set expanded(expanded) {
        this.controller_.foldable.set("expanded", expanded);
      }
      get title() {
        return this.controller_.props.get("title");
      }
      set title(title) {
        this.controller_.props.set("title", title);
      }
      get children() {
        return this.rackApi_.children;
      }
      addInput(object, key, opt_params) {
        return this.rackApi_.addInput(object, key, opt_params);
      }
      addMonitor(object, key, opt_params) {
        return this.rackApi_.addMonitor(object, key, opt_params);
      }
      addFolder(params) {
        return this.rackApi_.addFolder(params);
      }
      addButton(params) {
        return this.rackApi_.addButton(params);
      }
      addSeparator(opt_params) {
        return this.rackApi_.addSeparator(opt_params);
      }
      addTab(params) {
        return this.rackApi_.addTab(params);
      }
      add(api, opt_index) {
        return this.rackApi_.add(api, opt_index);
      }
      remove(api) {
        this.rackApi_.remove(api);
      }
      addBlade(params) {
        return this.rackApi_.addBlade(params);
      }
      on(eventName, handler) {
        const bh = handler.bind(this);
        this.emitter_.on(eventName, (ev) => {
          bh(ev.event);
        });
        return this;
      }
    }
    class RackLikeController extends BladeController {
      constructor(config) {
        super({
          blade: config.blade,
          view: config.view,
          viewProps: config.rackController.viewProps
        });
        this.rackController = config.rackController;
      }
    }
    class PlainView {
      constructor(doc, config) {
        const className2 = ClassName(config.viewName);
        this.element = doc.createElement("div");
        this.element.classList.add(className2());
        config.viewProps.bindClassModifiers(this.element);
      }
    }
    function findInputBindingController(bcs, b2) {
      for (let i = 0; i < bcs.length; i++) {
        const bc = bcs[i];
        if (bc instanceof InputBindingController && bc.binding === b2) {
          return bc;
        }
      }
      return null;
    }
    function findMonitorBindingController(bcs, b2) {
      for (let i = 0; i < bcs.length; i++) {
        const bc = bcs[i];
        if (bc instanceof MonitorBindingController && bc.binding === b2) {
          return bc;
        }
      }
      return null;
    }
    function findValueBladeController(bcs, v2) {
      for (let i = 0; i < bcs.length; i++) {
        const bc = bcs[i];
        if (bc instanceof ValueBladeController && bc.value === v2) {
          return bc;
        }
      }
      return null;
    }
    function findSubRack(bc) {
      if (bc instanceof RackController) {
        return bc.rack;
      }
      if (bc instanceof RackLikeController) {
        return bc.rackController.rack;
      }
      return null;
    }
    function findSubBladeControllerSet(bc) {
      const rack = findSubRack(bc);
      return rack ? rack["bcSet_"] : null;
    }
    class BladeRack {
      constructor(config) {
        var _a2, _b2;
        this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
        this.onSetAdd_ = this.onSetAdd_.bind(this);
        this.onSetRemove_ = this.onSetRemove_.bind(this);
        this.onChildDispose_ = this.onChildDispose_.bind(this);
        this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
        this.onChildInputChange_ = this.onChildInputChange_.bind(this);
        this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this);
        this.onChildValueChange_ = this.onChildValueChange_.bind(this);
        this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
        this.onDescendantLayout_ = this.onDescendantLayout_.bind(this);
        this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this);
        this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this);
        this.emitter = new Emitter2();
        this.blade_ = (_a2 = config.blade) !== null && _a2 !== void 0 ? _a2 : null;
        (_b2 = this.blade_) === null || _b2 === void 0 ? void 0 : _b2.value("positions").emitter.on("change", this.onBladePositionsChange_);
        this.viewProps = config.viewProps;
        this.bcSet_ = new NestedOrderedSet(findSubBladeControllerSet);
        this.bcSet_.emitter.on("add", this.onSetAdd_);
        this.bcSet_.emitter.on("remove", this.onSetRemove_);
      }
      get children() {
        return this.bcSet_.items;
      }
      add(bc, opt_index) {
        var _a2;
        (_a2 = bc.parent) === null || _a2 === void 0 ? void 0 : _a2.remove(bc);
        if (isPropertyWritable(bc, "parent")) {
          bc.parent = this;
        } else {
          bc["parent_"] = this;
          warnMissing({
            key: "parent",
            target: "BladeController",
            place: "BladeRack.add"
          });
        }
        this.bcSet_.add(bc, opt_index);
      }
      remove(bc) {
        if (isPropertyWritable(bc, "parent")) {
          bc.parent = null;
        } else {
          bc["parent_"] = null;
          warnMissing({
            key: "parent",
            target: "BladeController",
            place: "BladeRack.remove"
          });
        }
        this.bcSet_.remove(bc);
      }
      find(controllerClass) {
        return forceCast(this.bcSet_.allItems().filter((bc) => {
          return bc instanceof controllerClass;
        }));
      }
      onSetAdd_(ev) {
        this.updatePositions_();
        const isRoot = ev.target === ev.root;
        this.emitter.emit("add", {
          bladeController: ev.item,
          index: ev.index,
          isRoot,
          sender: this
        });
        if (!isRoot) {
          return;
        }
        const bc = ev.item;
        bc.viewProps.emitter.on("change", this.onChildViewPropsChange_);
        bc.blade.value("positions").emitter.on("change", this.onChildPositionsChange_);
        bc.viewProps.handleDispose(this.onChildDispose_);
        if (bc instanceof InputBindingController) {
          bc.binding.emitter.on("change", this.onChildInputChange_);
        } else if (bc instanceof MonitorBindingController) {
          bc.binding.emitter.on("update", this.onChildMonitorUpdate_);
        } else if (bc instanceof ValueBladeController) {
          bc.value.emitter.on("change", this.onChildValueChange_);
        } else {
          const rack = findSubRack(bc);
          if (rack) {
            const emitter = rack.emitter;
            emitter.on("layout", this.onDescendantLayout_);
            emitter.on("inputchange", this.onDescendantInputChange_);
            emitter.on("monitorupdate", this.onDescendantMonitorUpdate_);
          }
        }
      }
      onSetRemove_(ev) {
        this.updatePositions_();
        const isRoot = ev.target === ev.root;
        this.emitter.emit("remove", {
          bladeController: ev.item,
          isRoot,
          sender: this
        });
        if (!isRoot) {
          return;
        }
        const bc = ev.item;
        if (bc instanceof InputBindingController) {
          bc.binding.emitter.off("change", this.onChildInputChange_);
        } else if (bc instanceof MonitorBindingController) {
          bc.binding.emitter.off("update", this.onChildMonitorUpdate_);
        } else if (bc instanceof ValueBladeController) {
          bc.value.emitter.off("change", this.onChildValueChange_);
        } else {
          const rack = findSubRack(bc);
          if (rack) {
            const emitter = rack.emitter;
            emitter.off("layout", this.onDescendantLayout_);
            emitter.off("inputchange", this.onDescendantInputChange_);
            emitter.off("monitorupdate", this.onDescendantMonitorUpdate_);
          }
        }
      }
      updatePositions_() {
        const visibleItems = this.bcSet_.items.filter((bc) => !bc.viewProps.get("hidden"));
        const firstVisibleItem = visibleItems[0];
        const lastVisibleItem = visibleItems[visibleItems.length - 1];
        this.bcSet_.items.forEach((bc) => {
          const ps = [];
          if (bc === firstVisibleItem) {
            ps.push("first");
            if (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) {
              ps.push("veryfirst");
            }
          }
          if (bc === lastVisibleItem) {
            ps.push("last");
            if (!this.blade_ || this.blade_.get("positions").includes("verylast")) {
              ps.push("verylast");
            }
          }
          bc.blade.set("positions", ps);
        });
      }
      onChildPositionsChange_() {
        this.updatePositions_();
        this.emitter.emit("layout", {
          sender: this
        });
      }
      onChildViewPropsChange_(_ev) {
        this.updatePositions_();
        this.emitter.emit("layout", {
          sender: this
        });
      }
      onChildDispose_() {
        const disposedUcs = this.bcSet_.items.filter((bc) => {
          return bc.viewProps.get("disposed");
        });
        disposedUcs.forEach((bc) => {
          this.bcSet_.remove(bc);
        });
      }
      onChildInputChange_(ev) {
        const bc = findInputBindingController(this.find(InputBindingController), ev.sender);
        if (!bc) {
          throw TpError.alreadyDisposed();
        }
        this.emitter.emit("inputchange", {
          bladeController: bc,
          options: ev.options,
          sender: this
        });
      }
      onChildMonitorUpdate_(ev) {
        const bc = findMonitorBindingController(this.find(MonitorBindingController), ev.sender);
        if (!bc) {
          throw TpError.alreadyDisposed();
        }
        this.emitter.emit("monitorupdate", {
          bladeController: bc,
          sender: this
        });
      }
      onChildValueChange_(ev) {
        const bc = findValueBladeController(this.find(ValueBladeController), ev.sender);
        if (!bc) {
          throw TpError.alreadyDisposed();
        }
        this.emitter.emit("inputchange", {
          bladeController: bc,
          options: ev.options,
          sender: this
        });
      }
      onDescendantLayout_(_) {
        this.updatePositions_();
        this.emitter.emit("layout", {
          sender: this
        });
      }
      onDescendantInputChange_(ev) {
        this.emitter.emit("inputchange", {
          bladeController: ev.bladeController,
          options: ev.options,
          sender: this
        });
      }
      onDescendantMonitorUpdate_(ev) {
        this.emitter.emit("monitorupdate", {
          bladeController: ev.bladeController,
          sender: this
        });
      }
      onBladePositionsChange_() {
        this.updatePositions_();
      }
    }
    class RackController extends BladeController {
      constructor(doc, config) {
        super(Object.assign(Object.assign({}, config), { view: new PlainView(doc, {
          viewName: "brk",
          viewProps: config.viewProps
        }) }));
        this.onRackAdd_ = this.onRackAdd_.bind(this);
        this.onRackRemove_ = this.onRackRemove_.bind(this);
        const rack = new BladeRack({
          blade: config.root ? void 0 : config.blade,
          viewProps: config.viewProps
        });
        rack.emitter.on("add", this.onRackAdd_);
        rack.emitter.on("remove", this.onRackRemove_);
        this.rack = rack;
        this.viewProps.handleDispose(() => {
          for (let i = this.rack.children.length - 1; i >= 0; i--) {
            const bc = this.rack.children[i];
            bc.viewProps.set("disposed", true);
          }
        });
      }
      onRackAdd_(ev) {
        if (!ev.isRoot) {
          return;
        }
        insertElementAt(this.view.element, ev.bladeController.view.element, ev.index);
      }
      onRackRemove_(ev) {
        if (!ev.isRoot) {
          return;
        }
        removeElement(ev.bladeController.view.element);
      }
    }
    const bladeContainerClassName = ClassName("cnt");
    class FolderView {
      constructor(doc, config) {
        var _a2;
        this.className_ = ClassName((_a2 = config.viewName) !== null && _a2 !== void 0 ? _a2 : "fld");
        this.element = doc.createElement("div");
        this.element.classList.add(this.className_(), bladeContainerClassName());
        config.viewProps.bindClassModifiers(this.element);
        this.foldable_ = config.foldable;
        this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded"));
        bindValueMap(this.foldable_, "completed", valueToClassName(this.element, this.className_(void 0, "cpl")));
        const buttonElem = doc.createElement("button");
        buttonElem.classList.add(this.className_("b"));
        bindValueMap(config.props, "title", (title) => {
          if (isEmpty(title)) {
            this.element.classList.add(this.className_(void 0, "not"));
          } else {
            this.element.classList.remove(this.className_(void 0, "not"));
          }
        });
        config.viewProps.bindDisabled(buttonElem);
        this.element.appendChild(buttonElem);
        this.buttonElement = buttonElem;
        const indentElem = doc.createElement("div");
        indentElem.classList.add(this.className_("i"));
        this.element.appendChild(indentElem);
        const titleElem = doc.createElement("div");
        titleElem.classList.add(this.className_("t"));
        bindValueToTextContent(config.props.value("title"), titleElem);
        this.buttonElement.appendChild(titleElem);
        this.titleElement = titleElem;
        const markElem = doc.createElement("div");
        markElem.classList.add(this.className_("m"));
        this.buttonElement.appendChild(markElem);
        const containerElem = config.containerElement;
        containerElem.classList.add(this.className_("c"));
        this.element.appendChild(containerElem);
        this.containerElement = containerElem;
      }
    }
    class FolderController extends RackLikeController {
      constructor(doc, config) {
        var _a2;
        const foldable = Foldable.create((_a2 = config.expanded) !== null && _a2 !== void 0 ? _a2 : true);
        const rc = new RackController(doc, {
          blade: config.blade,
          root: config.root,
          viewProps: config.viewProps
        });
        super(Object.assign(Object.assign({}, config), { rackController: rc, view: new FolderView(doc, {
          containerElement: rc.view.element,
          foldable,
          props: config.props,
          viewName: config.root ? "rot" : void 0,
          viewProps: config.viewProps
        }) }));
        this.onTitleClick_ = this.onTitleClick_.bind(this);
        this.props = config.props;
        this.foldable = foldable;
        bindFoldable(this.foldable, this.view.containerElement);
        this.rackController.rack.emitter.on("add", () => {
          this.foldable.cleanUpTransition();
        });
        this.rackController.rack.emitter.on("remove", () => {
          this.foldable.cleanUpTransition();
        });
        this.view.buttonElement.addEventListener("click", this.onTitleClick_);
      }
      get document() {
        return this.view.element.ownerDocument;
      }
      onTitleClick_() {
        this.foldable.set("expanded", !this.foldable.get("expanded"));
      }
    }
    const FolderBladePlugin = {
      id: "folder",
      type: "blade",
      accept(params) {
        const p2 = ParamsParsers;
        const result = parseParams(params, {
          title: p2.required.string,
          view: p2.required.constant("folder"),
          expanded: p2.optional.boolean
        });
        return result ? { params: result } : null;
      },
      controller(args) {
        return new FolderController(args.document, {
          blade: args.blade,
          expanded: args.params.expanded,
          props: ValueMap.fromObject({
            title: args.params.title
          }),
          viewProps: args.viewProps
        });
      },
      api(args) {
        if (!(args.controller instanceof FolderController)) {
          return null;
        }
        return new FolderApi(args.controller, args.pool);
      }
    };
    class LabeledValueController extends ValueBladeController {
      constructor(doc, config) {
        const viewProps = config.valueController.viewProps;
        super(Object.assign(Object.assign({}, config), { value: config.valueController.value, view: new LabelView(doc, {
          props: config.props,
          viewProps
        }), viewProps }));
        this.props = config.props;
        this.valueController = config.valueController;
        this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    class SeparatorApi extends BladeApi {
    }
    const className$m = ClassName("spr");
    class SeparatorView {
      constructor(doc, config) {
        this.element = doc.createElement("div");
        this.element.classList.add(className$m());
        config.viewProps.bindClassModifiers(this.element);
        const hrElem = doc.createElement("hr");
        hrElem.classList.add(className$m("r"));
        this.element.appendChild(hrElem);
      }
    }
    class SeparatorController extends BladeController {
      constructor(doc, config) {
        super(Object.assign(Object.assign({}, config), { view: new SeparatorView(doc, {
          viewProps: config.viewProps
        }) }));
      }
    }
    const SeparatorBladePlugin = {
      id: "separator",
      type: "blade",
      accept(params) {
        const p2 = ParamsParsers;
        const result = parseParams(params, {
          view: p2.required.constant("separator")
        });
        return result ? { params: result } : null;
      },
      controller(args) {
        return new SeparatorController(args.document, {
          blade: args.blade,
          viewProps: args.viewProps
        });
      },
      api(args) {
        if (!(args.controller instanceof SeparatorController)) {
          return null;
        }
        return new SeparatorApi(args.controller);
      }
    };
    const className$l = ClassName("tbi");
    class TabItemView {
      constructor(doc, config) {
        this.element = doc.createElement("div");
        this.element.classList.add(className$l());
        config.viewProps.bindClassModifiers(this.element);
        bindValueMap(config.props, "selected", (selected) => {
          if (selected) {
            this.element.classList.add(className$l(void 0, "sel"));
          } else {
            this.element.classList.remove(className$l(void 0, "sel"));
          }
        });
        const buttonElem = doc.createElement("button");
        buttonElem.classList.add(className$l("b"));
        config.viewProps.bindDisabled(buttonElem);
        this.element.appendChild(buttonElem);
        this.buttonElement = buttonElem;
        const titleElem = doc.createElement("div");
        titleElem.classList.add(className$l("t"));
        bindValueToTextContent(config.props.value("title"), titleElem);
        this.buttonElement.appendChild(titleElem);
        this.titleElement = titleElem;
      }
    }
    class TabItemController {
      constructor(doc, config) {
        this.emitter = new Emitter2();
        this.onClick_ = this.onClick_.bind(this);
        this.props = config.props;
        this.viewProps = config.viewProps;
        this.view = new TabItemView(doc, {
          props: config.props,
          viewProps: config.viewProps
        });
        this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", {
          sender: this
        });
      }
    }
    class TabPageController {
      constructor(doc, config) {
        this.onItemClick_ = this.onItemClick_.bind(this);
        this.ic_ = new TabItemController(doc, {
          props: config.itemProps,
          viewProps: ViewProps.create()
        });
        this.ic_.emitter.on("click", this.onItemClick_);
        this.cc_ = new RackController(doc, {
          blade: createBlade(),
          viewProps: ViewProps.create()
        });
        this.props = config.props;
        bindValueMap(this.props, "selected", (selected) => {
          this.itemController.props.set("selected", selected);
          this.contentController.viewProps.set("hidden", !selected);
        });
      }
      get itemController() {
        return this.ic_;
      }
      get contentController() {
        return this.cc_;
      }
      onItemClick_() {
        this.props.set("selected", true);
      }
    }
    class TabPageApi {
      constructor(controller, contentRackApi) {
        this.controller_ = controller;
        this.rackApi_ = contentRackApi;
      }
      get title() {
        var _a2;
        return (_a2 = this.controller_.itemController.props.get("title")) !== null && _a2 !== void 0 ? _a2 : "";
      }
      set title(title) {
        this.controller_.itemController.props.set("title", title);
      }
      get selected() {
        return this.controller_.props.get("selected");
      }
      set selected(selected) {
        this.controller_.props.set("selected", selected);
      }
      get children() {
        return this.rackApi_.children;
      }
      addButton(params) {
        return this.rackApi_.addButton(params);
      }
      addFolder(params) {
        return this.rackApi_.addFolder(params);
      }
      addSeparator(opt_params) {
        return this.rackApi_.addSeparator(opt_params);
      }
      addTab(params) {
        return this.rackApi_.addTab(params);
      }
      add(api, opt_index) {
        this.rackApi_.add(api, opt_index);
      }
      remove(api) {
        this.rackApi_.remove(api);
      }
      addInput(object, key, opt_params) {
        return this.rackApi_.addInput(object, key, opt_params);
      }
      addMonitor(object, key, opt_params) {
        return this.rackApi_.addMonitor(object, key, opt_params);
      }
      addBlade(params) {
        return this.rackApi_.addBlade(params);
      }
    }
    class TabApi extends RackLikeApi {
      constructor(controller, pool) {
        super(controller, new RackApi(controller.rackController, pool));
        this.onPageAdd_ = this.onPageAdd_.bind(this);
        this.onPageRemove_ = this.onPageRemove_.bind(this);
        this.onSelect_ = this.onSelect_.bind(this);
        this.emitter_ = new Emitter2();
        this.pageApiMap_ = /* @__PURE__ */ new Map();
        this.rackApi_.on("change", (ev) => {
          this.emitter_.emit("change", {
            event: ev
          });
        });
        this.rackApi_.on("update", (ev) => {
          this.emitter_.emit("update", {
            event: ev
          });
        });
        this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_);
        this.controller_.pageSet.emitter.on("add", this.onPageAdd_);
        this.controller_.pageSet.emitter.on("remove", this.onPageRemove_);
        this.controller_.pageSet.items.forEach((pc) => {
          this.setUpPageApi_(pc);
        });
      }
      get pages() {
        return this.controller_.pageSet.items.map((pc) => {
          const api = this.pageApiMap_.get(pc);
          if (!api) {
            throw TpError.shouldNeverHappen();
          }
          return api;
        });
      }
      addPage(params) {
        const doc = this.controller_.view.element.ownerDocument;
        const pc = new TabPageController(doc, {
          itemProps: ValueMap.fromObject({
            selected: false,
            title: params.title
          }),
          props: ValueMap.fromObject({
            selected: false
          })
        });
        this.controller_.add(pc, params.index);
        const api = this.pageApiMap_.get(pc);
        if (!api) {
          throw TpError.shouldNeverHappen();
        }
        return api;
      }
      removePage(index) {
        this.controller_.remove(index);
      }
      on(eventName, handler) {
        const bh = handler.bind(this);
        this.emitter_.on(eventName, (ev) => {
          bh(ev.event);
        });
        return this;
      }
      setUpPageApi_(pc) {
        const rackApi = this.rackApi_["apiSet_"].find((api2) => api2.controller_ === pc.contentController);
        if (!rackApi) {
          throw TpError.shouldNeverHappen();
        }
        const api = new TabPageApi(pc, rackApi);
        this.pageApiMap_.set(pc, api);
      }
      onPageAdd_(ev) {
        this.setUpPageApi_(ev.item);
      }
      onPageRemove_(ev) {
        const api = this.pageApiMap_.get(ev.item);
        if (!api) {
          throw TpError.shouldNeverHappen();
        }
        this.pageApiMap_.delete(ev.item);
      }
      onSelect_(ev) {
        this.emitter_.emit("select", {
          event: new TpTabSelectEvent(this, ev.rawValue)
        });
      }
    }
    const INDEX_NOT_SELECTED = -1;
    class Tab {
      constructor() {
        this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
        this.empty = createValue(true);
        this.selectedIndex = createValue(INDEX_NOT_SELECTED);
        this.items_ = [];
      }
      add(item, opt_index) {
        const index = opt_index !== null && opt_index !== void 0 ? opt_index : this.items_.length;
        this.items_.splice(index, 0, item);
        item.emitter.on("change", this.onItemSelectedChange_);
        this.keepSelection_();
      }
      remove(item) {
        const index = this.items_.indexOf(item);
        if (index < 0) {
          return;
        }
        this.items_.splice(index, 1);
        item.emitter.off("change", this.onItemSelectedChange_);
        this.keepSelection_();
      }
      keepSelection_() {
        if (this.items_.length === 0) {
          this.selectedIndex.rawValue = INDEX_NOT_SELECTED;
          this.empty.rawValue = true;
          return;
        }
        const firstSelIndex = this.items_.findIndex((s2) => s2.rawValue);
        if (firstSelIndex < 0) {
          this.items_.forEach((s2, i) => {
            s2.rawValue = i === 0;
          });
          this.selectedIndex.rawValue = 0;
        } else {
          this.items_.forEach((s2, i) => {
            s2.rawValue = i === firstSelIndex;
          });
          this.selectedIndex.rawValue = firstSelIndex;
        }
        this.empty.rawValue = false;
      }
      onItemSelectedChange_(ev) {
        if (ev.rawValue) {
          const index = this.items_.findIndex((s2) => s2 === ev.sender);
          this.items_.forEach((s2, i) => {
            s2.rawValue = i === index;
          });
          this.selectedIndex.rawValue = index;
        } else {
          this.keepSelection_();
        }
      }
    }
    const className$k = ClassName("tab");
    class TabView {
      constructor(doc, config) {
        this.element = doc.createElement("div");
        this.element.classList.add(className$k(), bladeContainerClassName());
        config.viewProps.bindClassModifiers(this.element);
        bindValue(config.empty, valueToClassName(this.element, className$k(void 0, "nop")));
        const titleElem = doc.createElement("div");
        titleElem.classList.add(className$k("t"));
        this.element.appendChild(titleElem);
        this.itemsElement = titleElem;
        const indentElem = doc.createElement("div");
        indentElem.classList.add(className$k("i"));
        this.element.appendChild(indentElem);
        const contentsElem = config.contentsElement;
        contentsElem.classList.add(className$k("c"));
        this.element.appendChild(contentsElem);
        this.contentsElement = contentsElem;
      }
    }
    class TabController extends RackLikeController {
      constructor(doc, config) {
        const cr = new RackController(doc, {
          blade: config.blade,
          viewProps: config.viewProps
        });
        const tab = new Tab();
        super({
          blade: config.blade,
          rackController: cr,
          view: new TabView(doc, {
            contentsElement: cr.view.element,
            empty: tab.empty,
            viewProps: config.viewProps
          })
        });
        this.onPageAdd_ = this.onPageAdd_.bind(this);
        this.onPageRemove_ = this.onPageRemove_.bind(this);
        this.pageSet_ = new NestedOrderedSet(() => null);
        this.pageSet_.emitter.on("add", this.onPageAdd_);
        this.pageSet_.emitter.on("remove", this.onPageRemove_);
        this.tab = tab;
      }
      get pageSet() {
        return this.pageSet_;
      }
      add(pc, opt_index) {
        this.pageSet_.add(pc, opt_index);
      }
      remove(index) {
        this.pageSet_.remove(this.pageSet_.items[index]);
      }
      onPageAdd_(ev) {
        const pc = ev.item;
        insertElementAt(this.view.itemsElement, pc.itemController.view.element, ev.index);
        pc.itemController.viewProps.set("parent", this.viewProps);
        this.rackController.rack.add(pc.contentController, ev.index);
        this.tab.add(pc.props.value("selected"));
      }
      onPageRemove_(ev) {
        const pc = ev.item;
        removeElement(pc.itemController.view.element);
        pc.itemController.viewProps.set("parent", null);
        this.rackController.rack.remove(pc.contentController);
        this.tab.remove(pc.props.value("selected"));
      }
    }
    const TabBladePlugin = {
      id: "tab",
      type: "blade",
      accept(params) {
        const p2 = ParamsParsers;
        const result = parseParams(params, {
          pages: p2.required.array(p2.required.object({ title: p2.required.string })),
          view: p2.required.constant("tab")
        });
        if (!result || result.pages.length === 0) {
          return null;
        }
        return { params: result };
      },
      controller(args) {
        const c = new TabController(args.document, {
          blade: args.blade,
          viewProps: args.viewProps
        });
        args.params.pages.forEach((p2) => {
          const pc = new TabPageController(args.document, {
            itemProps: ValueMap.fromObject({
              selected: false,
              title: p2.title
            }),
            props: ValueMap.fromObject({
              selected: false
            })
          });
          c.add(pc);
        });
        return c;
      },
      api(args) {
        if (!(args.controller instanceof TabController)) {
          return null;
        }
        return new TabApi(args.controller, args.pool);
      }
    };
    function createBladeController(plugin, args) {
      const ac = plugin.accept(args.params);
      if (!ac) {
        return null;
      }
      const disabled = ParamsParsers.optional.boolean(args.params["disabled"]).value;
      const hidden = ParamsParsers.optional.boolean(args.params["hidden"]).value;
      return plugin.controller({
        blade: createBlade(),
        document: args.document,
        params: forceCast(Object.assign(Object.assign({}, ac.params), { disabled, hidden })),
        viewProps: ViewProps.create({
          disabled,
          hidden
        })
      });
    }
    class ManualTicker {
      constructor() {
        this.disabled = false;
        this.emitter = new Emitter2();
      }
      dispose() {
      }
      tick() {
        if (this.disabled) {
          return;
        }
        this.emitter.emit("tick", {
          sender: this
        });
      }
    }
    class IntervalTicker {
      constructor(doc, interval) {
        this.disabled_ = false;
        this.timerId_ = null;
        this.onTick_ = this.onTick_.bind(this);
        this.doc_ = doc;
        this.emitter = new Emitter2();
        this.interval_ = interval;
        this.setTimer_();
      }
      get disabled() {
        return this.disabled_;
      }
      set disabled(inactive) {
        this.disabled_ = inactive;
        if (this.disabled_) {
          this.clearTimer_();
        } else {
          this.setTimer_();
        }
      }
      dispose() {
        this.clearTimer_();
      }
      clearTimer_() {
        if (this.timerId_ === null) {
          return;
        }
        const win = this.doc_.defaultView;
        if (win) {
          win.clearInterval(this.timerId_);
        }
        this.timerId_ = null;
      }
      setTimer_() {
        this.clearTimer_();
        if (this.interval_ <= 0) {
          return;
        }
        const win = this.doc_.defaultView;
        if (win) {
          this.timerId_ = win.setInterval(this.onTick_, this.interval_);
        }
      }
      onTick_() {
        if (this.disabled_) {
          return;
        }
        this.emitter.emit("tick", {
          sender: this
        });
      }
    }
    class InputBinding {
      constructor(config) {
        this.onValueChange_ = this.onValueChange_.bind(this);
        this.reader = config.reader;
        this.writer = config.writer;
        this.emitter = new Emitter2();
        this.value = config.value;
        this.value.emitter.on("change", this.onValueChange_);
        this.target = config.target;
        this.read();
      }
      read() {
        const targetValue = this.target.read();
        if (targetValue !== void 0) {
          this.value.rawValue = this.reader(targetValue);
        }
      }
      write_(rawValue) {
        this.writer(this.target, rawValue);
      }
      onValueChange_(ev) {
        this.write_(ev.rawValue);
        this.emitter.emit("change", {
          options: ev.options,
          rawValue: ev.rawValue,
          sender: this
        });
      }
    }
    function fillBuffer(buffer, bufferSize) {
      while (buffer.length < bufferSize) {
        buffer.push(void 0);
      }
    }
    function initializeBuffer(bufferSize) {
      const buffer = [];
      fillBuffer(buffer, bufferSize);
      return createValue(buffer);
    }
    function createTrimmedBuffer(buffer) {
      const index = buffer.indexOf(void 0);
      return forceCast(index < 0 ? buffer : buffer.slice(0, index));
    }
    function createPushedBuffer(buffer, newValue) {
      const newBuffer = [...createTrimmedBuffer(buffer), newValue];
      if (newBuffer.length > buffer.length) {
        newBuffer.splice(0, newBuffer.length - buffer.length);
      } else {
        fillBuffer(newBuffer, buffer.length);
      }
      return newBuffer;
    }
    class MonitorBinding {
      constructor(config) {
        this.onTick_ = this.onTick_.bind(this);
        this.reader_ = config.reader;
        this.target = config.target;
        this.emitter = new Emitter2();
        this.value = config.value;
        this.ticker = config.ticker;
        this.ticker.emitter.on("tick", this.onTick_);
        this.read();
      }
      dispose() {
        this.ticker.dispose();
      }
      read() {
        const targetValue = this.target.read();
        if (targetValue === void 0) {
          return;
        }
        const buffer = this.value.rawValue;
        const newValue = this.reader_(targetValue);
        this.value.rawValue = createPushedBuffer(buffer, newValue);
        this.emitter.emit("update", {
          rawValue: newValue,
          sender: this
        });
      }
      onTick_(_) {
        this.read();
      }
    }
    class CompositeConstraint {
      constructor(constraints) {
        this.constraints = constraints;
      }
      constrain(value) {
        return this.constraints.reduce((result, c) => {
          return c.constrain(result);
        }, value);
      }
    }
    function findConstraint(c, constraintClass) {
      if (c instanceof constraintClass) {
        return c;
      }
      if (c instanceof CompositeConstraint) {
        const result = c.constraints.reduce((tmpResult, sc) => {
          if (tmpResult) {
            return tmpResult;
          }
          return sc instanceof constraintClass ? sc : null;
        }, null);
        if (result) {
          return result;
        }
      }
      return null;
    }
    class DefiniteRangeConstraint {
      constructor(config) {
        this.values = ValueMap.fromObject({
          max: config.max,
          min: config.min
        });
      }
      constrain(value) {
        const max2 = this.values.get("max");
        const min = this.values.get("min");
        return Math.min(Math.max(value, min), max2);
      }
    }
    class ListConstraint {
      constructor(options) {
        this.values = ValueMap.fromObject({
          options
        });
      }
      get options() {
        return this.values.get("options");
      }
      constrain(value) {
        const opts = this.values.get("options");
        if (opts.length === 0) {
          return value;
        }
        const matched = opts.filter((item) => {
          return item.value === value;
        }).length > 0;
        return matched ? value : opts[0].value;
      }
    }
    class RangeConstraint {
      constructor(config) {
        this.values = ValueMap.fromObject({
          max: config.max,
          min: config.min
        });
      }
      get maxValue() {
        return this.values.get("max");
      }
      get minValue() {
        return this.values.get("min");
      }
      constrain(value) {
        const max2 = this.values.get("max");
        const min = this.values.get("min");
        let result = value;
        if (!isEmpty(min)) {
          result = Math.max(result, min);
        }
        if (!isEmpty(max2)) {
          result = Math.min(result, max2);
        }
        return result;
      }
    }
    class StepConstraint {
      constructor(step, origin = 0) {
        this.step = step;
        this.origin = origin;
      }
      constrain(value) {
        const o2 = this.origin % this.step;
        const r2 = Math.round((value - o2) / this.step);
        return o2 + r2 * this.step;
      }
    }
    const className$j = ClassName("lst");
    class ListView {
      constructor(doc, config) {
        this.onValueChange_ = this.onValueChange_.bind(this);
        this.props_ = config.props;
        this.element = doc.createElement("div");
        this.element.classList.add(className$j());
        config.viewProps.bindClassModifiers(this.element);
        const selectElem = doc.createElement("select");
        selectElem.classList.add(className$j("s"));
        config.viewProps.bindDisabled(selectElem);
        this.element.appendChild(selectElem);
        this.selectElement = selectElem;
        const markElem = doc.createElement("div");
        markElem.classList.add(className$j("m"));
        markElem.appendChild(createSvgIconElement(doc, "dropdown"));
        this.element.appendChild(markElem);
        config.value.emitter.on("change", this.onValueChange_);
        this.value_ = config.value;
        bindValueMap(this.props_, "options", (opts) => {
          removeChildElements(this.selectElement);
          opts.forEach((item) => {
            const optionElem = doc.createElement("option");
            optionElem.textContent = item.text;
            this.selectElement.appendChild(optionElem);
          });
          this.update_();
        });
      }
      update_() {
        const values = this.props_.get("options").map((o2) => o2.value);
        this.selectElement.selectedIndex = values.indexOf(this.value_.rawValue);
      }
      onValueChange_() {
        this.update_();
      }
    }
    class ListController {
      constructor(doc, config) {
        this.onSelectChange_ = this.onSelectChange_.bind(this);
        this.props = config.props;
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.view = new ListView(doc, {
          props: this.props,
          value: this.value,
          viewProps: this.viewProps
        });
        this.view.selectElement.addEventListener("change", this.onSelectChange_);
      }
      onSelectChange_(e2) {
        const selectElem = forceCast(e2.currentTarget);
        this.value.rawValue = this.props.get("options")[selectElem.selectedIndex].value;
      }
    }
    const className$i = ClassName("pop");
    class PopupView {
      constructor(doc, config) {
        this.element = doc.createElement("div");
        this.element.classList.add(className$i());
        config.viewProps.bindClassModifiers(this.element);
        bindValue(config.shows, valueToClassName(this.element, className$i(void 0, "v")));
      }
    }
    class PopupController {
      constructor(doc, config) {
        this.shows = createValue(false);
        this.viewProps = config.viewProps;
        this.view = new PopupView(doc, {
          shows: this.shows,
          viewProps: this.viewProps
        });
      }
    }
    const className$h = ClassName("txt");
    class TextView {
      constructor(doc, config) {
        this.onChange_ = this.onChange_.bind(this);
        this.element = doc.createElement("div");
        this.element.classList.add(className$h());
        config.viewProps.bindClassModifiers(this.element);
        this.props_ = config.props;
        this.props_.emitter.on("change", this.onChange_);
        const inputElem = doc.createElement("input");
        inputElem.classList.add(className$h("i"));
        inputElem.type = "text";
        config.viewProps.bindDisabled(inputElem);
        this.element.appendChild(inputElem);
        this.inputElement = inputElem;
        config.value.emitter.on("change", this.onChange_);
        this.value_ = config.value;
        this.refresh();
      }
      refresh() {
        const formatter = this.props_.get("formatter");
        this.inputElement.value = formatter(this.value_.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class TextController {
      constructor(doc, config) {
        this.onInputChange_ = this.onInputChange_.bind(this);
        this.parser_ = config.parser;
        this.props = config.props;
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.view = new TextView(doc, {
          props: config.props,
          value: this.value,
          viewProps: this.viewProps
        });
        this.view.inputElement.addEventListener("change", this.onInputChange_);
      }
      onInputChange_(e2) {
        const inputElem = forceCast(e2.currentTarget);
        const value = inputElem.value;
        const parsedValue = this.parser_(value);
        if (!isEmpty(parsedValue)) {
          this.value.rawValue = parsedValue;
        }
        this.view.refresh();
      }
    }
    function boolToString(value) {
      return String(value);
    }
    function boolFromUnknown(value) {
      if (value === "false") {
        return false;
      }
      return !!value;
    }
    function BooleanFormatter(value) {
      return boolToString(value);
    }
    class NumberLiteralNode {
      constructor(text) {
        this.text = text;
      }
      evaluate() {
        return Number(this.text);
      }
      toString() {
        return this.text;
      }
    }
    const BINARY_OPERATION_MAP = {
      "**": (v1, v2) => Math.pow(v1, v2),
      "*": (v1, v2) => v1 * v2,
      "/": (v1, v2) => v1 / v2,
      "%": (v1, v2) => v1 % v2,
      "+": (v1, v2) => v1 + v2,
      "-": (v1, v2) => v1 - v2,
      "<<": (v1, v2) => v1 << v2,
      ">>": (v1, v2) => v1 >> v2,
      ">>>": (v1, v2) => v1 >>> v2,
      "&": (v1, v2) => v1 & v2,
      "^": (v1, v2) => v1 ^ v2,
      "|": (v1, v2) => v1 | v2
    };
    class BinaryOperationNode {
      constructor(operator, left, right) {
        this.left = left;
        this.operator = operator;
        this.right = right;
      }
      evaluate() {
        const op = BINARY_OPERATION_MAP[this.operator];
        if (!op) {
          throw new Error(`unexpected binary operator: '${this.operator}`);
        }
        return op(this.left.evaluate(), this.right.evaluate());
      }
      toString() {
        return [
          "b(",
          this.left.toString(),
          this.operator,
          this.right.toString(),
          ")"
        ].join(" ");
      }
    }
    const UNARY_OPERATION_MAP = {
      "+": (v2) => v2,
      "-": (v2) => -v2,
      "~": (v2) => ~v2
    };
    class UnaryOperationNode {
      constructor(operator, expr) {
        this.operator = operator;
        this.expression = expr;
      }
      evaluate() {
        const op = UNARY_OPERATION_MAP[this.operator];
        if (!op) {
          throw new Error(`unexpected unary operator: '${this.operator}`);
        }
        return op(this.expression.evaluate());
      }
      toString() {
        return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
      }
    }
    function combineReader(parsers) {
      return (text, cursor) => {
        for (let i = 0; i < parsers.length; i++) {
          const result = parsers[i](text, cursor);
          if (result !== "") {
            return result;
          }
        }
        return "";
      };
    }
    function readWhitespace(text, cursor) {
      var _a2;
      const m2 = text.substr(cursor).match(/^\s+/);
      return (_a2 = m2 && m2[0]) !== null && _a2 !== void 0 ? _a2 : "";
    }
    function readNonZeroDigit(text, cursor) {
      const ch = text.substr(cursor, 1);
      return ch.match(/^[1-9]$/) ? ch : "";
    }
    function readDecimalDigits(text, cursor) {
      var _a2;
      const m2 = text.substr(cursor).match(/^[0-9]+/);
      return (_a2 = m2 && m2[0]) !== null && _a2 !== void 0 ? _a2 : "";
    }
    function readSignedInteger(text, cursor) {
      const ds = readDecimalDigits(text, cursor);
      if (ds !== "") {
        return ds;
      }
      const sign2 = text.substr(cursor, 1);
      cursor += 1;
      if (sign2 !== "-" && sign2 !== "+") {
        return "";
      }
      const sds = readDecimalDigits(text, cursor);
      if (sds === "") {
        return "";
      }
      return sign2 + sds;
    }
    function readExponentPart(text, cursor) {
      const e2 = text.substr(cursor, 1);
      cursor += 1;
      if (e2.toLowerCase() !== "e") {
        return "";
      }
      const si = readSignedInteger(text, cursor);
      if (si === "") {
        return "";
      }
      return e2 + si;
    }
    function readDecimalIntegerLiteral(text, cursor) {
      const ch = text.substr(cursor, 1);
      if (ch === "0") {
        return ch;
      }
      const nzd = readNonZeroDigit(text, cursor);
      cursor += nzd.length;
      if (nzd === "") {
        return "";
      }
      return nzd + readDecimalDigits(text, cursor);
    }
    function readDecimalLiteral1(text, cursor) {
      const dil = readDecimalIntegerLiteral(text, cursor);
      cursor += dil.length;
      if (dil === "") {
        return "";
      }
      const dot = text.substr(cursor, 1);
      cursor += dot.length;
      if (dot !== ".") {
        return "";
      }
      const dds = readDecimalDigits(text, cursor);
      cursor += dds.length;
      return dil + dot + dds + readExponentPart(text, cursor);
    }
    function readDecimalLiteral2(text, cursor) {
      const dot = text.substr(cursor, 1);
      cursor += dot.length;
      if (dot !== ".") {
        return "";
      }
      const dds = readDecimalDigits(text, cursor);
      cursor += dds.length;
      if (dds === "") {
        return "";
      }
      return dot + dds + readExponentPart(text, cursor);
    }
    function readDecimalLiteral3(text, cursor) {
      const dil = readDecimalIntegerLiteral(text, cursor);
      cursor += dil.length;
      if (dil === "") {
        return "";
      }
      return dil + readExponentPart(text, cursor);
    }
    const readDecimalLiteral = combineReader([
      readDecimalLiteral1,
      readDecimalLiteral2,
      readDecimalLiteral3
    ]);
    function parseBinaryDigits(text, cursor) {
      var _a2;
      const m2 = text.substr(cursor).match(/^[01]+/);
      return (_a2 = m2 && m2[0]) !== null && _a2 !== void 0 ? _a2 : "";
    }
    function readBinaryIntegerLiteral(text, cursor) {
      const prefix = text.substr(cursor, 2);
      cursor += prefix.length;
      if (prefix.toLowerCase() !== "0b") {
        return "";
      }
      const bds = parseBinaryDigits(text, cursor);
      if (bds === "") {
        return "";
      }
      return prefix + bds;
    }
    function readOctalDigits(text, cursor) {
      var _a2;
      const m2 = text.substr(cursor).match(/^[0-7]+/);
      return (_a2 = m2 && m2[0]) !== null && _a2 !== void 0 ? _a2 : "";
    }
    function readOctalIntegerLiteral(text, cursor) {
      const prefix = text.substr(cursor, 2);
      cursor += prefix.length;
      if (prefix.toLowerCase() !== "0o") {
        return "";
      }
      const ods = readOctalDigits(text, cursor);
      if (ods === "") {
        return "";
      }
      return prefix + ods;
    }
    function readHexDigits(text, cursor) {
      var _a2;
      const m2 = text.substr(cursor).match(/^[0-9a-f]+/i);
      return (_a2 = m2 && m2[0]) !== null && _a2 !== void 0 ? _a2 : "";
    }
    function readHexIntegerLiteral(text, cursor) {
      const prefix = text.substr(cursor, 2);
      cursor += prefix.length;
      if (prefix.toLowerCase() !== "0x") {
        return "";
      }
      const hds = readHexDigits(text, cursor);
      if (hds === "") {
        return "";
      }
      return prefix + hds;
    }
    const readNonDecimalIntegerLiteral = combineReader([
      readBinaryIntegerLiteral,
      readOctalIntegerLiteral,
      readHexIntegerLiteral
    ]);
    const readNumericLiteral = combineReader([
      readNonDecimalIntegerLiteral,
      readDecimalLiteral
    ]);
    function parseLiteral(text, cursor) {
      const num = readNumericLiteral(text, cursor);
      cursor += num.length;
      if (num === "") {
        return null;
      }
      return {
        evaluable: new NumberLiteralNode(num),
        cursor
      };
    }
    function parseParenthesizedExpression(text, cursor) {
      const op = text.substr(cursor, 1);
      cursor += op.length;
      if (op !== "(") {
        return null;
      }
      const expr = parseExpression(text, cursor);
      if (!expr) {
        return null;
      }
      cursor = expr.cursor;
      cursor += readWhitespace(text, cursor).length;
      const cl = text.substr(cursor, 1);
      cursor += cl.length;
      if (cl !== ")") {
        return null;
      }
      return {
        evaluable: expr.evaluable,
        cursor
      };
    }
    function parsePrimaryExpression(text, cursor) {
      var _a2;
      return (_a2 = parseLiteral(text, cursor)) !== null && _a2 !== void 0 ? _a2 : parseParenthesizedExpression(text, cursor);
    }
    function parseUnaryExpression(text, cursor) {
      const expr = parsePrimaryExpression(text, cursor);
      if (expr) {
        return expr;
      }
      const op = text.substr(cursor, 1);
      cursor += op.length;
      if (op !== "+" && op !== "-" && op !== "~") {
        return null;
      }
      const num = parseUnaryExpression(text, cursor);
      if (!num) {
        return null;
      }
      cursor = num.cursor;
      return {
        cursor,
        evaluable: new UnaryOperationNode(op, num.evaluable)
      };
    }
    function readBinaryOperator(ops, text, cursor) {
      cursor += readWhitespace(text, cursor).length;
      const op = ops.filter((op2) => text.startsWith(op2, cursor))[0];
      if (!op) {
        return null;
      }
      cursor += op.length;
      cursor += readWhitespace(text, cursor).length;
      return {
        cursor,
        operator: op
      };
    }
    function createBinaryOperationExpressionParser(exprParser, ops) {
      return (text, cursor) => {
        const firstExpr = exprParser(text, cursor);
        if (!firstExpr) {
          return null;
        }
        cursor = firstExpr.cursor;
        let expr = firstExpr.evaluable;
        for (; ; ) {
          const op = readBinaryOperator(ops, text, cursor);
          if (!op) {
            break;
          }
          cursor = op.cursor;
          const nextExpr = exprParser(text, cursor);
          if (!nextExpr) {
            return null;
          }
          cursor = nextExpr.cursor;
          expr = new BinaryOperationNode(op.operator, expr, nextExpr.evaluable);
        }
        return expr ? {
          cursor,
          evaluable: expr
        } : null;
      };
    }
    const parseBinaryOperationExpression = [
      ["**"],
      ["*", "/", "%"],
      ["+", "-"],
      ["<<", ">>>", ">>"],
      ["&"],
      ["^"],
      ["|"]
    ].reduce((parser, ops) => {
      return createBinaryOperationExpressionParser(parser, ops);
    }, parseUnaryExpression);
    function parseExpression(text, cursor) {
      cursor += readWhitespace(text, cursor).length;
      return parseBinaryOperationExpression(text, cursor);
    }
    function parseEcmaNumberExpression(text) {
      const expr = parseExpression(text, 0);
      if (!expr) {
        return null;
      }
      const cursor = expr.cursor + readWhitespace(text, expr.cursor).length;
      if (cursor !== text.length) {
        return null;
      }
      return expr.evaluable;
    }
    function parseNumber(text) {
      var _a2;
      const r2 = parseEcmaNumberExpression(text);
      return (_a2 = r2 === null || r2 === void 0 ? void 0 : r2.evaluate()) !== null && _a2 !== void 0 ? _a2 : null;
    }
    function numberFromUnknown(value) {
      if (typeof value === "number") {
        return value;
      }
      if (typeof value === "string") {
        const pv = parseNumber(value);
        if (!isEmpty(pv)) {
          return pv;
        }
      }
      return 0;
    }
    function numberToString(value) {
      return String(value);
    }
    function createNumberFormatter(digits) {
      return (value) => {
        return value.toFixed(Math.max(Math.min(digits, 20), 0));
      };
    }
    const innerFormatter = createNumberFormatter(0);
    function formatPercentage(value) {
      return innerFormatter(value) + "%";
    }
    function stringFromUnknown(value) {
      return String(value);
    }
    function formatString(value) {
      return value;
    }
    function connectValues({ primary, secondary, forward, backward }) {
      let changing = false;
      function preventFeedback(callback) {
        if (changing) {
          return;
        }
        changing = true;
        callback();
        changing = false;
      }
      primary.emitter.on("change", (ev) => {
        preventFeedback(() => {
          secondary.setRawValue(forward(primary, secondary), ev.options);
        });
      });
      secondary.emitter.on("change", (ev) => {
        preventFeedback(() => {
          primary.setRawValue(backward(primary, secondary), ev.options);
        });
        preventFeedback(() => {
          secondary.setRawValue(forward(primary, secondary), ev.options);
        });
      });
      preventFeedback(() => {
        secondary.setRawValue(forward(primary, secondary), {
          forceEmit: false,
          last: true
        });
      });
    }
    function getStepForKey(baseStep, keys3) {
      const step = baseStep * (keys3.altKey ? 0.1 : 1) * (keys3.shiftKey ? 10 : 1);
      if (keys3.upKey) {
        return +step;
      } else if (keys3.downKey) {
        return -step;
      }
      return 0;
    }
    function getVerticalStepKeys(ev) {
      return {
        altKey: ev.altKey,
        downKey: ev.key === "ArrowDown",
        shiftKey: ev.shiftKey,
        upKey: ev.key === "ArrowUp"
      };
    }
    function getHorizontalStepKeys(ev) {
      return {
        altKey: ev.altKey,
        downKey: ev.key === "ArrowLeft",
        shiftKey: ev.shiftKey,
        upKey: ev.key === "ArrowRight"
      };
    }
    function isVerticalArrowKey(key) {
      return key === "ArrowUp" || key === "ArrowDown";
    }
    function isArrowKey(key) {
      return isVerticalArrowKey(key) || key === "ArrowLeft" || key === "ArrowRight";
    }
    function computeOffset$1(ev, elem) {
      var _a2, _b2;
      const win = elem.ownerDocument.defaultView;
      const rect = elem.getBoundingClientRect();
      return {
        x: ev.pageX - (((_a2 = win && win.scrollX) !== null && _a2 !== void 0 ? _a2 : 0) + rect.left),
        y: ev.pageY - (((_b2 = win && win.scrollY) !== null && _b2 !== void 0 ? _b2 : 0) + rect.top)
      };
    }
    class PointerHandler {
      constructor(element) {
        this.lastTouch_ = null;
        this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
        this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
        this.onMouseDown_ = this.onMouseDown_.bind(this);
        this.onTouchEnd_ = this.onTouchEnd_.bind(this);
        this.onTouchMove_ = this.onTouchMove_.bind(this);
        this.onTouchStart_ = this.onTouchStart_.bind(this);
        this.elem_ = element;
        this.emitter = new Emitter2();
        element.addEventListener("touchstart", this.onTouchStart_, {
          passive: false
        });
        element.addEventListener("touchmove", this.onTouchMove_, {
          passive: true
        });
        element.addEventListener("touchend", this.onTouchEnd_);
        element.addEventListener("mousedown", this.onMouseDown_);
      }
      computePosition_(offset) {
        const rect = this.elem_.getBoundingClientRect();
        return {
          bounds: {
            width: rect.width,
            height: rect.height
          },
          point: offset ? {
            x: offset.x,
            y: offset.y
          } : null
        };
      }
      onMouseDown_(ev) {
        var _a2;
        ev.preventDefault();
        (_a2 = ev.currentTarget) === null || _a2 === void 0 ? void 0 : _a2.focus();
        const doc = this.elem_.ownerDocument;
        doc.addEventListener("mousemove", this.onDocumentMouseMove_);
        doc.addEventListener("mouseup", this.onDocumentMouseUp_);
        this.emitter.emit("down", {
          altKey: ev.altKey,
          data: this.computePosition_(computeOffset$1(ev, this.elem_)),
          sender: this,
          shiftKey: ev.shiftKey
        });
      }
      onDocumentMouseMove_(ev) {
        this.emitter.emit("move", {
          altKey: ev.altKey,
          data: this.computePosition_(computeOffset$1(ev, this.elem_)),
          sender: this,
          shiftKey: ev.shiftKey
        });
      }
      onDocumentMouseUp_(ev) {
        const doc = this.elem_.ownerDocument;
        doc.removeEventListener("mousemove", this.onDocumentMouseMove_);
        doc.removeEventListener("mouseup", this.onDocumentMouseUp_);
        this.emitter.emit("up", {
          altKey: ev.altKey,
          data: this.computePosition_(computeOffset$1(ev, this.elem_)),
          sender: this,
          shiftKey: ev.shiftKey
        });
      }
      onTouchStart_(ev) {
        ev.preventDefault();
        const touch = ev.targetTouches.item(0);
        const rect = this.elem_.getBoundingClientRect();
        this.emitter.emit("down", {
          altKey: ev.altKey,
          data: this.computePosition_(touch ? {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top
          } : void 0),
          sender: this,
          shiftKey: ev.shiftKey
        });
        this.lastTouch_ = touch;
      }
      onTouchMove_(ev) {
        const touch = ev.targetTouches.item(0);
        const rect = this.elem_.getBoundingClientRect();
        this.emitter.emit("move", {
          altKey: ev.altKey,
          data: this.computePosition_(touch ? {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top
          } : void 0),
          sender: this,
          shiftKey: ev.shiftKey
        });
        this.lastTouch_ = touch;
      }
      onTouchEnd_(ev) {
        var _a2;
        const touch = (_a2 = ev.targetTouches.item(0)) !== null && _a2 !== void 0 ? _a2 : this.lastTouch_;
        const rect = this.elem_.getBoundingClientRect();
        this.emitter.emit("up", {
          altKey: ev.altKey,
          data: this.computePosition_(touch ? {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top
          } : void 0),
          sender: this,
          shiftKey: ev.shiftKey
        });
      }
    }
    function mapRange(value, start1, end1, start2, end2) {
      const p2 = (value - start1) / (end1 - start1);
      return start2 + p2 * (end2 - start2);
    }
    function getDecimalDigits(value) {
      const text = String(value.toFixed(10));
      const frac = text.split(".")[1];
      return frac.replace(/0+$/, "").length;
    }
    function constrainRange(value, min, max2) {
      return Math.min(Math.max(value, min), max2);
    }
    function loopRange(value, max2) {
      return (value % max2 + max2) % max2;
    }
    const className$g = ClassName("txt");
    class NumberTextView {
      constructor(doc, config) {
        this.onChange_ = this.onChange_.bind(this);
        this.props_ = config.props;
        this.props_.emitter.on("change", this.onChange_);
        this.element = doc.createElement("div");
        this.element.classList.add(className$g(), className$g(void 0, "num"));
        if (config.arrayPosition) {
          this.element.classList.add(className$g(void 0, config.arrayPosition));
        }
        config.viewProps.bindClassModifiers(this.element);
        const inputElem = doc.createElement("input");
        inputElem.classList.add(className$g("i"));
        inputElem.type = "text";
        config.viewProps.bindDisabled(inputElem);
        this.element.appendChild(inputElem);
        this.inputElement = inputElem;
        this.onDraggingChange_ = this.onDraggingChange_.bind(this);
        this.dragging_ = config.dragging;
        this.dragging_.emitter.on("change", this.onDraggingChange_);
        this.element.classList.add(className$g());
        this.inputElement.classList.add(className$g("i"));
        const knobElem = doc.createElement("div");
        knobElem.classList.add(className$g("k"));
        this.element.appendChild(knobElem);
        this.knobElement = knobElem;
        const guideElem = doc.createElementNS(SVG_NS, "svg");
        guideElem.classList.add(className$g("g"));
        this.knobElement.appendChild(guideElem);
        const bodyElem = doc.createElementNS(SVG_NS, "path");
        bodyElem.classList.add(className$g("gb"));
        guideElem.appendChild(bodyElem);
        this.guideBodyElem_ = bodyElem;
        const headElem = doc.createElementNS(SVG_NS, "path");
        headElem.classList.add(className$g("gh"));
        guideElem.appendChild(headElem);
        this.guideHeadElem_ = headElem;
        const tooltipElem = doc.createElement("div");
        tooltipElem.classList.add(ClassName("tt")());
        this.knobElement.appendChild(tooltipElem);
        this.tooltipElem_ = tooltipElem;
        config.value.emitter.on("change", this.onChange_);
        this.value = config.value;
        this.refresh();
      }
      onDraggingChange_(ev) {
        if (ev.rawValue === null) {
          this.element.classList.remove(className$g(void 0, "drg"));
          return;
        }
        this.element.classList.add(className$g(void 0, "drg"));
        const x2 = ev.rawValue / this.props_.get("draggingScale");
        const aox = x2 + (x2 > 0 ? -1 : x2 < 0 ? 1 : 0);
        const adx = constrainRange(-aox, -4, 4);
        this.guideHeadElem_.setAttributeNS(null, "d", [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x2},-1 L${x2},9`].join(" "));
        this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${x2},4`);
        const formatter = this.props_.get("formatter");
        this.tooltipElem_.textContent = formatter(this.value.rawValue);
        this.tooltipElem_.style.left = `${x2}px`;
      }
      refresh() {
        const formatter = this.props_.get("formatter");
        this.inputElement.value = formatter(this.value.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class NumberTextController {
      constructor(doc, config) {
        var _a2;
        this.originRawValue_ = 0;
        this.onInputChange_ = this.onInputChange_.bind(this);
        this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
        this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
        this.onPointerDown_ = this.onPointerDown_.bind(this);
        this.onPointerMove_ = this.onPointerMove_.bind(this);
        this.onPointerUp_ = this.onPointerUp_.bind(this);
        this.baseStep_ = config.baseStep;
        this.parser_ = config.parser;
        this.props = config.props;
        this.sliderProps_ = (_a2 = config.sliderProps) !== null && _a2 !== void 0 ? _a2 : null;
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.dragging_ = createValue(null);
        this.view = new NumberTextView(doc, {
          arrayPosition: config.arrayPosition,
          dragging: this.dragging_,
          props: this.props,
          value: this.value,
          viewProps: this.viewProps
        });
        this.view.inputElement.addEventListener("change", this.onInputChange_);
        this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_);
        this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
        const ph = new PointerHandler(this.view.knobElement);
        ph.emitter.on("down", this.onPointerDown_);
        ph.emitter.on("move", this.onPointerMove_);
        ph.emitter.on("up", this.onPointerUp_);
      }
      constrainValue_(value) {
        var _a2, _b2;
        const min = (_a2 = this.sliderProps_) === null || _a2 === void 0 ? void 0 : _a2.get("minValue");
        const max2 = (_b2 = this.sliderProps_) === null || _b2 === void 0 ? void 0 : _b2.get("maxValue");
        let v2 = value;
        if (min !== void 0) {
          v2 = Math.max(v2, min);
        }
        if (max2 !== void 0) {
          v2 = Math.min(v2, max2);
        }
        return v2;
      }
      onInputChange_(e2) {
        const inputElem = forceCast(e2.currentTarget);
        const value = inputElem.value;
        const parsedValue = this.parser_(value);
        if (!isEmpty(parsedValue)) {
          this.value.rawValue = this.constrainValue_(parsedValue);
        }
        this.view.refresh();
      }
      onInputKeyDown_(ev) {
        const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
        if (step === 0) {
          return;
        }
        this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
          forceEmit: false,
          last: false
        });
      }
      onInputKeyUp_(ev) {
        const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
        if (step === 0) {
          return;
        }
        this.value.setRawValue(this.value.rawValue, {
          forceEmit: true,
          last: true
        });
      }
      onPointerDown_() {
        this.originRawValue_ = this.value.rawValue;
        this.dragging_.rawValue = 0;
      }
      computeDraggingValue_(data) {
        if (!data.point) {
          return null;
        }
        const dx = data.point.x - data.bounds.width / 2;
        return this.constrainValue_(this.originRawValue_ + dx * this.props.get("draggingScale"));
      }
      onPointerMove_(ev) {
        const v2 = this.computeDraggingValue_(ev.data);
        if (v2 === null) {
          return;
        }
        this.value.setRawValue(v2, {
          forceEmit: false,
          last: false
        });
        this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
      }
      onPointerUp_(ev) {
        const v2 = this.computeDraggingValue_(ev.data);
        if (v2 === null) {
          return;
        }
        this.value.setRawValue(v2, {
          forceEmit: true,
          last: true
        });
        this.dragging_.rawValue = null;
      }
    }
    const className$f = ClassName("sld");
    class SliderView {
      constructor(doc, config) {
        this.onChange_ = this.onChange_.bind(this);
        this.props_ = config.props;
        this.props_.emitter.on("change", this.onChange_);
        this.element = doc.createElement("div");
        this.element.classList.add(className$f());
        config.viewProps.bindClassModifiers(this.element);
        const trackElem = doc.createElement("div");
        trackElem.classList.add(className$f("t"));
        config.viewProps.bindTabIndex(trackElem);
        this.element.appendChild(trackElem);
        this.trackElement = trackElem;
        const knobElem = doc.createElement("div");
        knobElem.classList.add(className$f("k"));
        this.trackElement.appendChild(knobElem);
        this.knobElement = knobElem;
        config.value.emitter.on("change", this.onChange_);
        this.value = config.value;
        this.update_();
      }
      update_() {
        const p2 = constrainRange(mapRange(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
        this.knobElement.style.width = `${p2}%`;
      }
      onChange_() {
        this.update_();
      }
    }
    class SliderController {
      constructor(doc, config) {
        this.onKeyDown_ = this.onKeyDown_.bind(this);
        this.onKeyUp_ = this.onKeyUp_.bind(this);
        this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
        this.onPointerUp_ = this.onPointerUp_.bind(this);
        this.baseStep_ = config.baseStep;
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.props = config.props;
        this.view = new SliderView(doc, {
          props: this.props,
          value: this.value,
          viewProps: this.viewProps
        });
        this.ptHandler_ = new PointerHandler(this.view.trackElement);
        this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_);
        this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_);
        this.ptHandler_.emitter.on("up", this.onPointerUp_);
        this.view.trackElement.addEventListener("keydown", this.onKeyDown_);
        this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(d2, opts) {
        if (!d2.point) {
          return;
        }
        this.value.setRawValue(mapRange(constrainRange(d2.point.x, 0, d2.bounds.width), 0, d2.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), opts);
      }
      onPointerDownOrMove_(ev) {
        this.handlePointerEvent_(ev.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerUp_(ev) {
        this.handlePointerEvent_(ev.data, {
          forceEmit: true,
          last: true
        });
      }
      onKeyDown_(ev) {
        const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
        if (step === 0) {
          return;
        }
        this.value.setRawValue(this.value.rawValue + step, {
          forceEmit: false,
          last: false
        });
      }
      onKeyUp_(ev) {
        const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
        if (step === 0) {
          return;
        }
        this.value.setRawValue(this.value.rawValue, {
          forceEmit: true,
          last: true
        });
      }
    }
    const className$e = ClassName("sldtxt");
    class SliderTextView {
      constructor(doc, config) {
        this.element = doc.createElement("div");
        this.element.classList.add(className$e());
        const sliderElem = doc.createElement("div");
        sliderElem.classList.add(className$e("s"));
        this.sliderView_ = config.sliderView;
        sliderElem.appendChild(this.sliderView_.element);
        this.element.appendChild(sliderElem);
        const textElem = doc.createElement("div");
        textElem.classList.add(className$e("t"));
        this.textView_ = config.textView;
        textElem.appendChild(this.textView_.element);
        this.element.appendChild(textElem);
      }
    }
    class SliderTextController {
      constructor(doc, config) {
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.sliderC_ = new SliderController(doc, {
          baseStep: config.baseStep,
          props: config.sliderProps,
          value: config.value,
          viewProps: this.viewProps
        });
        this.textC_ = new NumberTextController(doc, {
          baseStep: config.baseStep,
          parser: config.parser,
          props: config.textProps,
          sliderProps: config.sliderProps,
          value: config.value,
          viewProps: config.viewProps
        });
        this.view = new SliderTextView(doc, {
          sliderView: this.sliderC_.view,
          textView: this.textC_.view
        });
      }
      get sliderController() {
        return this.sliderC_;
      }
      get textController() {
        return this.textC_;
      }
    }
    function writePrimitive(target, value) {
      target.write(value);
    }
    function parseListOptions(value) {
      const p2 = ParamsParsers;
      if (Array.isArray(value)) {
        return p2.required.array(p2.required.object({
          text: p2.required.string,
          value: p2.required.raw
        }))(value).value;
      }
      if (typeof value === "object") {
        return p2.required.raw(value).value;
      }
      return void 0;
    }
    function parsePickerLayout(value) {
      if (value === "inline" || value === "popup") {
        return value;
      }
      return void 0;
    }
    function parsePointDimensionParams(value) {
      const p2 = ParamsParsers;
      return p2.required.object({
        max: p2.optional.number,
        min: p2.optional.number,
        step: p2.optional.number
      })(value).value;
    }
    function normalizeListOptions(options) {
      if (Array.isArray(options)) {
        return options;
      }
      const items = [];
      Object.keys(options).forEach((text) => {
        items.push({ text, value: options[text] });
      });
      return items;
    }
    function createListConstraint(options) {
      return !isEmpty(options) ? new ListConstraint(normalizeListOptions(forceCast(options))) : null;
    }
    function findStep(constraint) {
      const c = constraint ? findConstraint(constraint, StepConstraint) : null;
      if (!c) {
        return null;
      }
      return c.step;
    }
    function getSuitableDecimalDigits(constraint, rawValue) {
      const sc = constraint && findConstraint(constraint, StepConstraint);
      if (sc) {
        return getDecimalDigits(sc.step);
      }
      return Math.max(getDecimalDigits(rawValue), 2);
    }
    function getBaseStep(constraint) {
      const step = findStep(constraint);
      return step !== null && step !== void 0 ? step : 1;
    }
    function getSuitableDraggingScale(constraint, rawValue) {
      var _a2;
      const sc = constraint && findConstraint(constraint, StepConstraint);
      const base = Math.abs((_a2 = sc === null || sc === void 0 ? void 0 : sc.step) !== null && _a2 !== void 0 ? _a2 : rawValue);
      return base === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base)) - 1);
    }
    const className$d = ClassName("ckb");
    class CheckboxView {
      constructor(doc, config) {
        this.onValueChange_ = this.onValueChange_.bind(this);
        this.element = doc.createElement("div");
        this.element.classList.add(className$d());
        config.viewProps.bindClassModifiers(this.element);
        const labelElem = doc.createElement("label");
        labelElem.classList.add(className$d("l"));
        this.element.appendChild(labelElem);
        const inputElem = doc.createElement("input");
        inputElem.classList.add(className$d("i"));
        inputElem.type = "checkbox";
        labelElem.appendChild(inputElem);
        this.inputElement = inputElem;
        config.viewProps.bindDisabled(this.inputElement);
        const wrapperElem = doc.createElement("div");
        wrapperElem.classList.add(className$d("w"));
        labelElem.appendChild(wrapperElem);
        const markElem = createSvgIconElement(doc, "check");
        wrapperElem.appendChild(markElem);
        config.value.emitter.on("change", this.onValueChange_);
        this.value = config.value;
        this.update_();
      }
      update_() {
        this.inputElement.checked = this.value.rawValue;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class CheckboxController {
      constructor(doc, config) {
        this.onInputChange_ = this.onInputChange_.bind(this);
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.view = new CheckboxView(doc, {
          value: this.value,
          viewProps: this.viewProps
        });
        this.view.inputElement.addEventListener("change", this.onInputChange_);
      }
      onInputChange_(e2) {
        const inputElem = forceCast(e2.currentTarget);
        this.value.rawValue = inputElem.checked;
      }
    }
    function createConstraint$6(params) {
      const constraints = [];
      const lc = createListConstraint(params.options);
      if (lc) {
        constraints.push(lc);
      }
      return new CompositeConstraint(constraints);
    }
    const BooleanInputPlugin = {
      id: "input-bool",
      type: "input",
      accept: (value, params) => {
        if (typeof value !== "boolean") {
          return null;
        }
        const p2 = ParamsParsers;
        const result = parseParams(params, {
          options: p2.optional.custom(parseListOptions)
        });
        return result ? {
          initialValue: value,
          params: result
        } : null;
      },
      binding: {
        reader: (_args) => boolFromUnknown,
        constraint: (args) => createConstraint$6(args.params),
        writer: (_args) => writePrimitive
      },
      controller: (args) => {
        const doc = args.document;
        const value = args.value;
        const c = args.constraint;
        const lc = c && findConstraint(c, ListConstraint);
        if (lc) {
          return new ListController(doc, {
            props: new ValueMap({
              options: lc.values.value("options")
            }),
            value,
            viewProps: args.viewProps
          });
        }
        return new CheckboxController(doc, {
          value,
          viewProps: args.viewProps
        });
      }
    };
    const className$c = ClassName("col");
    class ColorView {
      constructor(doc, config) {
        this.element = doc.createElement("div");
        this.element.classList.add(className$c());
        config.foldable.bindExpandedClass(this.element, className$c(void 0, "expanded"));
        bindValueMap(config.foldable, "completed", valueToClassName(this.element, className$c(void 0, "cpl")));
        const headElem = doc.createElement("div");
        headElem.classList.add(className$c("h"));
        this.element.appendChild(headElem);
        const swatchElem = doc.createElement("div");
        swatchElem.classList.add(className$c("s"));
        headElem.appendChild(swatchElem);
        this.swatchElement = swatchElem;
        const textElem = doc.createElement("div");
        textElem.classList.add(className$c("t"));
        headElem.appendChild(textElem);
        this.textElement = textElem;
        if (config.pickerLayout === "inline") {
          const pickerElem = doc.createElement("div");
          pickerElem.classList.add(className$c("p"));
          this.element.appendChild(pickerElem);
          this.pickerElement = pickerElem;
        } else {
          this.pickerElement = null;
        }
      }
    }
    function rgbToHslInt(r2, g2, b2) {
      const rp = constrainRange(r2 / 255, 0, 1);
      const gp = constrainRange(g2 / 255, 0, 1);
      const bp = constrainRange(b2 / 255, 0, 1);
      const cmax = Math.max(rp, gp, bp);
      const cmin = Math.min(rp, gp, bp);
      const c = cmax - cmin;
      let h2 = 0;
      let s2 = 0;
      const l2 = (cmin + cmax) / 2;
      if (c !== 0) {
        s2 = c / (1 - Math.abs(cmax + cmin - 1));
        if (rp === cmax) {
          h2 = (gp - bp) / c;
        } else if (gp === cmax) {
          h2 = 2 + (bp - rp) / c;
        } else {
          h2 = 4 + (rp - gp) / c;
        }
        h2 = h2 / 6 + (h2 < 0 ? 1 : 0);
      }
      return [h2 * 360, s2 * 100, l2 * 100];
    }
    function hslToRgbInt(h2, s2, l2) {
      const hp = (h2 % 360 + 360) % 360;
      const sp = constrainRange(s2 / 100, 0, 1);
      const lp = constrainRange(l2 / 100, 0, 1);
      const c = (1 - Math.abs(2 * lp - 1)) * sp;
      const x2 = c * (1 - Math.abs(hp / 60 % 2 - 1));
      const m2 = lp - c / 2;
      let rp, gp, bp;
      if (hp >= 0 && hp < 60) {
        [rp, gp, bp] = [c, x2, 0];
      } else if (hp >= 60 && hp < 120) {
        [rp, gp, bp] = [x2, c, 0];
      } else if (hp >= 120 && hp < 180) {
        [rp, gp, bp] = [0, c, x2];
      } else if (hp >= 180 && hp < 240) {
        [rp, gp, bp] = [0, x2, c];
      } else if (hp >= 240 && hp < 300) {
        [rp, gp, bp] = [x2, 0, c];
      } else {
        [rp, gp, bp] = [c, 0, x2];
      }
      return [(rp + m2) * 255, (gp + m2) * 255, (bp + m2) * 255];
    }
    function rgbToHsvInt(r2, g2, b2) {
      const rp = constrainRange(r2 / 255, 0, 1);
      const gp = constrainRange(g2 / 255, 0, 1);
      const bp = constrainRange(b2 / 255, 0, 1);
      const cmax = Math.max(rp, gp, bp);
      const cmin = Math.min(rp, gp, bp);
      const d2 = cmax - cmin;
      let h2;
      if (d2 === 0) {
        h2 = 0;
      } else if (cmax === rp) {
        h2 = 60 * (((gp - bp) / d2 % 6 + 6) % 6);
      } else if (cmax === gp) {
        h2 = 60 * ((bp - rp) / d2 + 2);
      } else {
        h2 = 60 * ((rp - gp) / d2 + 4);
      }
      const s2 = cmax === 0 ? 0 : d2 / cmax;
      const v2 = cmax;
      return [h2, s2 * 100, v2 * 100];
    }
    function hsvToRgbInt(h2, s2, v2) {
      const hp = loopRange(h2, 360);
      const sp = constrainRange(s2 / 100, 0, 1);
      const vp = constrainRange(v2 / 100, 0, 1);
      const c = vp * sp;
      const x2 = c * (1 - Math.abs(hp / 60 % 2 - 1));
      const m2 = vp - c;
      let rp, gp, bp;
      if (hp >= 0 && hp < 60) {
        [rp, gp, bp] = [c, x2, 0];
      } else if (hp >= 60 && hp < 120) {
        [rp, gp, bp] = [x2, c, 0];
      } else if (hp >= 120 && hp < 180) {
        [rp, gp, bp] = [0, c, x2];
      } else if (hp >= 180 && hp < 240) {
        [rp, gp, bp] = [0, x2, c];
      } else if (hp >= 240 && hp < 300) {
        [rp, gp, bp] = [x2, 0, c];
      } else {
        [rp, gp, bp] = [c, 0, x2];
      }
      return [(rp + m2) * 255, (gp + m2) * 255, (bp + m2) * 255];
    }
    function hslToHsvInt(h2, s2, l2) {
      const sd = l2 + s2 * (100 - Math.abs(2 * l2 - 100)) / (2 * 100);
      return [
        h2,
        sd !== 0 ? s2 * (100 - Math.abs(2 * l2 - 100)) / sd : 0,
        l2 + s2 * (100 - Math.abs(2 * l2 - 100)) / (2 * 100)
      ];
    }
    function hsvToHslInt(h2, s2, v2) {
      const sd = 100 - Math.abs(v2 * (200 - s2) / 100 - 100);
      return [h2, sd !== 0 ? s2 * v2 / sd : 0, v2 * (200 - s2) / (2 * 100)];
    }
    function removeAlphaComponent(comps) {
      return [comps[0], comps[1], comps[2]];
    }
    function appendAlphaComponent(comps, alpha) {
      return [comps[0], comps[1], comps[2], alpha];
    }
    const MODE_CONVERTER_MAP = {
      hsl: {
        hsl: (h2, s2, l2) => [h2, s2, l2],
        hsv: hslToHsvInt,
        rgb: hslToRgbInt
      },
      hsv: {
        hsl: hsvToHslInt,
        hsv: (h2, s2, v2) => [h2, s2, v2],
        rgb: hsvToRgbInt
      },
      rgb: {
        hsl: rgbToHslInt,
        hsv: rgbToHsvInt,
        rgb: (r2, g2, b2) => [r2, g2, b2]
      }
    };
    function getColorMaxComponents(mode, type2) {
      return [
        type2 === "float" ? 1 : mode === "rgb" ? 255 : 360,
        type2 === "float" ? 1 : mode === "rgb" ? 255 : 100,
        type2 === "float" ? 1 : mode === "rgb" ? 255 : 100
      ];
    }
    function loopHueRange(hue, max2) {
      return hue === max2 ? max2 : loopRange(hue, max2);
    }
    function constrainColorComponents(components, mode, type2) {
      var _a2;
      const ms = getColorMaxComponents(mode, type2);
      return [
        mode === "rgb" ? constrainRange(components[0], 0, ms[0]) : loopHueRange(components[0], ms[0]),
        constrainRange(components[1], 0, ms[1]),
        constrainRange(components[2], 0, ms[2]),
        constrainRange((_a2 = components[3]) !== null && _a2 !== void 0 ? _a2 : 1, 0, 1)
      ];
    }
    function convertColorType(comps, mode, from, to) {
      const fms = getColorMaxComponents(mode, from);
      const tms = getColorMaxComponents(mode, to);
      return comps.map((c, index) => c / fms[index] * tms[index]);
    }
    function convertColor(components, from, to) {
      const intComps = convertColorType(components, from.mode, from.type, "int");
      const result = MODE_CONVERTER_MAP[from.mode][to.mode](...intComps);
      return convertColorType(result, to.mode, "int", to.type);
    }
    function isRgbColorComponent(obj, key) {
      if (typeof obj !== "object" || isEmpty(obj)) {
        return false;
      }
      return key in obj && typeof obj[key] === "number";
    }
    class Color {
      static black(type2 = "int") {
        return new Color([0, 0, 0], "rgb", type2);
      }
      static fromObject(obj, type2 = "int") {
        const comps = "a" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
        return new Color(comps, "rgb", type2);
      }
      static toRgbaObject(color, type2 = "int") {
        return color.toRgbaObject(type2);
      }
      static isRgbColorObject(obj) {
        return isRgbColorComponent(obj, "r") && isRgbColorComponent(obj, "g") && isRgbColorComponent(obj, "b");
      }
      static isRgbaColorObject(obj) {
        return this.isRgbColorObject(obj) && isRgbColorComponent(obj, "a");
      }
      static isColorObject(obj) {
        return this.isRgbColorObject(obj);
      }
      static equals(v1, v2) {
        if (v1.mode !== v2.mode) {
          return false;
        }
        const comps1 = v1.comps_;
        const comps2 = v2.comps_;
        for (let i = 0; i < comps1.length; i++) {
          if (comps1[i] !== comps2[i]) {
            return false;
          }
        }
        return true;
      }
      constructor(comps, mode, type2 = "int") {
        this.mode = mode;
        this.type = type2;
        this.comps_ = constrainColorComponents(comps, mode, type2);
      }
      getComponents(opt_mode, type2 = "int") {
        return appendAlphaComponent(convertColor(removeAlphaComponent(this.comps_), { mode: this.mode, type: this.type }, { mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode, type: type2 }), this.comps_[3]);
      }
      toRgbaObject(type2 = "int") {
        const rgbComps = this.getComponents("rgb", type2);
        return {
          r: rgbComps[0],
          g: rgbComps[1],
          b: rgbComps[2],
          a: rgbComps[3]
        };
      }
    }
    const className$b = ClassName("colp");
    class ColorPickerView {
      constructor(doc, config) {
        this.alphaViews_ = null;
        this.element = doc.createElement("div");
        this.element.classList.add(className$b());
        config.viewProps.bindClassModifiers(this.element);
        const hsvElem = doc.createElement("div");
        hsvElem.classList.add(className$b("hsv"));
        const svElem = doc.createElement("div");
        svElem.classList.add(className$b("sv"));
        this.svPaletteView_ = config.svPaletteView;
        svElem.appendChild(this.svPaletteView_.element);
        hsvElem.appendChild(svElem);
        const hElem = doc.createElement("div");
        hElem.classList.add(className$b("h"));
        this.hPaletteView_ = config.hPaletteView;
        hElem.appendChild(this.hPaletteView_.element);
        hsvElem.appendChild(hElem);
        this.element.appendChild(hsvElem);
        const rgbElem = doc.createElement("div");
        rgbElem.classList.add(className$b("rgb"));
        this.textView_ = config.textView;
        rgbElem.appendChild(this.textView_.element);
        this.element.appendChild(rgbElem);
        if (config.alphaViews) {
          this.alphaViews_ = {
            palette: config.alphaViews.palette,
            text: config.alphaViews.text
          };
          const aElem = doc.createElement("div");
          aElem.classList.add(className$b("a"));
          const apElem = doc.createElement("div");
          apElem.classList.add(className$b("ap"));
          apElem.appendChild(this.alphaViews_.palette.element);
          aElem.appendChild(apElem);
          const atElem = doc.createElement("div");
          atElem.classList.add(className$b("at"));
          atElem.appendChild(this.alphaViews_.text.element);
          aElem.appendChild(atElem);
          this.element.appendChild(aElem);
        }
      }
      get allFocusableElements() {
        const elems = [
          this.svPaletteView_.element,
          this.hPaletteView_.element,
          this.textView_.modeSelectElement,
          ...this.textView_.textViews.map((v2) => v2.inputElement)
        ];
        if (this.alphaViews_) {
          elems.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement);
        }
        return elems;
      }
    }
    function parseColorType(value) {
      return value === "int" ? "int" : value === "float" ? "float" : void 0;
    }
    function parseColorInputParams(params) {
      const p2 = ParamsParsers;
      return parseParams(params, {
        alpha: p2.optional.boolean,
        color: p2.optional.object({
          alpha: p2.optional.boolean,
          type: p2.optional.custom(parseColorType)
        }),
        expanded: p2.optional.boolean,
        picker: p2.optional.custom(parsePickerLayout)
      });
    }
    function getBaseStepForColor(forAlpha) {
      return forAlpha ? 0.1 : 1;
    }
    function extractColorType(params) {
      var _a2;
      return (_a2 = params.color) === null || _a2 === void 0 ? void 0 : _a2.type;
    }
    function equalsStringColorFormat(f1, f2) {
      return f1.alpha === f2.alpha && f1.mode === f2.mode && f1.notation === f2.notation && f1.type === f2.type;
    }
    function parseCssNumberOrPercentage(text, maxValue) {
      const m2 = text.match(/^(.+)%$/);
      if (!m2) {
        return Math.min(parseFloat(text), maxValue);
      }
      return Math.min(parseFloat(m2[1]) * 0.01 * maxValue, maxValue);
    }
    const ANGLE_TO_DEG_MAP = {
      deg: (angle) => angle,
      grad: (angle) => angle * 360 / 400,
      rad: (angle) => angle * 360 / (2 * Math.PI),
      turn: (angle) => angle * 360
    };
    function parseCssNumberOrAngle(text) {
      const m2 = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
      if (!m2) {
        return parseFloat(text);
      }
      const angle = parseFloat(m2[1]);
      const unit = m2[2];
      return ANGLE_TO_DEG_MAP[unit](angle);
    }
    function parseFunctionalRgbColorComponents(text) {
      const m2 = text.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!m2) {
        return null;
      }
      const comps = [
        parseCssNumberOrPercentage(m2[1], 255),
        parseCssNumberOrPercentage(m2[2], 255),
        parseCssNumberOrPercentage(m2[3], 255)
      ];
      if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
        return null;
      }
      return comps;
    }
    function createFunctionalRgbColorParser(type2) {
      return (text) => {
        const comps = parseFunctionalRgbColorComponents(text);
        return comps ? new Color(comps, "rgb", type2) : null;
      };
    }
    function parseFunctionalRgbaColorComponents(text) {
      const m2 = text.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!m2) {
        return null;
      }
      const comps = [
        parseCssNumberOrPercentage(m2[1], 255),
        parseCssNumberOrPercentage(m2[2], 255),
        parseCssNumberOrPercentage(m2[3], 255),
        parseCssNumberOrPercentage(m2[4], 1)
      ];
      if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
        return null;
      }
      return comps;
    }
    function createFunctionalRgbaColorParser(type2) {
      return (text) => {
        const comps = parseFunctionalRgbaColorComponents(text);
        return comps ? new Color(comps, "rgb", type2) : null;
      };
    }
    function parseHslColorComponents(text) {
      const m2 = text.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!m2) {
        return null;
      }
      const comps = [
        parseCssNumberOrAngle(m2[1]),
        parseCssNumberOrPercentage(m2[2], 100),
        parseCssNumberOrPercentage(m2[3], 100)
      ];
      if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
        return null;
      }
      return comps;
    }
    function createHslColorParser(type2) {
      return (text) => {
        const comps = parseHslColorComponents(text);
        return comps ? new Color(comps, "hsl", type2) : null;
      };
    }
    function parseHslaColorComponents(text) {
      const m2 = text.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!m2) {
        return null;
      }
      const comps = [
        parseCssNumberOrAngle(m2[1]),
        parseCssNumberOrPercentage(m2[2], 100),
        parseCssNumberOrPercentage(m2[3], 100),
        parseCssNumberOrPercentage(m2[4], 1)
      ];
      if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
        return null;
      }
      return comps;
    }
    function createHslaColorParser(type2) {
      return (text) => {
        const comps = parseHslaColorComponents(text);
        return comps ? new Color(comps, "hsl", type2) : null;
      };
    }
    function parseHexRgbColorComponents(text) {
      const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
      if (mRgb) {
        return [
          parseInt(mRgb[1] + mRgb[1], 16),
          parseInt(mRgb[2] + mRgb[2], 16),
          parseInt(mRgb[3] + mRgb[3], 16)
        ];
      }
      const mRrggbb = text.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
      if (mRrggbb) {
        return [
          parseInt(mRrggbb[1], 16),
          parseInt(mRrggbb[2], 16),
          parseInt(mRrggbb[3], 16)
        ];
      }
      return null;
    }
    function parseHexRgbColor(text) {
      const comps = parseHexRgbColorComponents(text);
      return comps ? new Color(comps, "rgb", "int") : null;
    }
    function parseHexRgbaColorComponents(text) {
      const mRgb = text.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
      if (mRgb) {
        return [
          parseInt(mRgb[1] + mRgb[1], 16),
          parseInt(mRgb[2] + mRgb[2], 16),
          parseInt(mRgb[3] + mRgb[3], 16),
          mapRange(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1)
        ];
      }
      const mRrggbb = text.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
      if (mRrggbb) {
        return [
          parseInt(mRrggbb[1], 16),
          parseInt(mRrggbb[2], 16),
          parseInt(mRrggbb[3], 16),
          mapRange(parseInt(mRrggbb[4], 16), 0, 255, 0, 1)
        ];
      }
      return null;
    }
    function parseHexRgbaColor(text) {
      const comps = parseHexRgbaColorComponents(text);
      return comps ? new Color(comps, "rgb", "int") : null;
    }
    function parseObjectRgbColorComponents(text) {
      const m2 = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
      if (!m2) {
        return null;
      }
      const comps = [
        parseFloat(m2[1]),
        parseFloat(m2[2]),
        parseFloat(m2[3])
      ];
      if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
        return null;
      }
      return comps;
    }
    function createObjectRgbColorParser(type2) {
      return (text) => {
        const comps = parseObjectRgbColorComponents(text);
        return comps ? new Color(comps, "rgb", type2) : null;
      };
    }
    function parseObjectRgbaColorComponents(text) {
      const m2 = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
      if (!m2) {
        return null;
      }
      const comps = [
        parseFloat(m2[1]),
        parseFloat(m2[2]),
        parseFloat(m2[3]),
        parseFloat(m2[4])
      ];
      if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
        return null;
      }
      return comps;
    }
    function createObjectRgbaColorParser(type2) {
      return (text) => {
        const comps = parseObjectRgbaColorComponents(text);
        return comps ? new Color(comps, "rgb", type2) : null;
      };
    }
    const PARSER_AND_RESULT = [
      {
        parser: parseHexRgbColorComponents,
        result: {
          alpha: false,
          mode: "rgb",
          notation: "hex"
        }
      },
      {
        parser: parseHexRgbaColorComponents,
        result: {
          alpha: true,
          mode: "rgb",
          notation: "hex"
        }
      },
      {
        parser: parseFunctionalRgbColorComponents,
        result: {
          alpha: false,
          mode: "rgb",
          notation: "func"
        }
      },
      {
        parser: parseFunctionalRgbaColorComponents,
        result: {
          alpha: true,
          mode: "rgb",
          notation: "func"
        }
      },
      {
        parser: parseHslColorComponents,
        result: {
          alpha: false,
          mode: "hsl",
          notation: "func"
        }
      },
      {
        parser: parseHslaColorComponents,
        result: {
          alpha: true,
          mode: "hsl",
          notation: "func"
        }
      },
      {
        parser: parseObjectRgbColorComponents,
        result: {
          alpha: false,
          mode: "rgb",
          notation: "object"
        }
      },
      {
        parser: parseObjectRgbaColorComponents,
        result: {
          alpha: true,
          mode: "rgb",
          notation: "object"
        }
      }
    ];
    function detectStringColor(text) {
      return PARSER_AND_RESULT.reduce((prev, { parser, result: detection }) => {
        if (prev) {
          return prev;
        }
        return parser(text) ? detection : null;
      }, null);
    }
    function detectStringColorFormat(text, type2 = "int") {
      const r2 = detectStringColor(text);
      if (!r2) {
        return null;
      }
      if (r2.notation === "hex" && type2 !== "float") {
        return Object.assign(Object.assign({}, r2), { type: "int" });
      }
      if (r2.notation === "func") {
        return Object.assign(Object.assign({}, r2), { type: type2 });
      }
      return null;
    }
    const TYPE_TO_PARSERS = {
      int: [
        parseHexRgbColor,
        parseHexRgbaColor,
        createFunctionalRgbColorParser("int"),
        createFunctionalRgbaColorParser("int"),
        createHslColorParser("int"),
        createHslaColorParser("int"),
        createObjectRgbColorParser("int"),
        createObjectRgbaColorParser("int")
      ],
      float: [
        createFunctionalRgbColorParser("float"),
        createFunctionalRgbaColorParser("float"),
        createHslColorParser("float"),
        createHslaColorParser("float"),
        createObjectRgbColorParser("float"),
        createObjectRgbaColorParser("float")
      ]
    };
    function createColorStringBindingReader(type2) {
      const parsers = TYPE_TO_PARSERS[type2];
      return (value) => {
        if (typeof value !== "string") {
          return Color.black(type2);
        }
        const result = parsers.reduce((prev, parser) => {
          if (prev) {
            return prev;
          }
          return parser(value);
        }, null);
        return result !== null && result !== void 0 ? result : Color.black(type2);
      };
    }
    function createColorStringParser(type2) {
      const parsers = TYPE_TO_PARSERS[type2];
      return (value) => {
        return parsers.reduce((prev, parser) => {
          if (prev) {
            return prev;
          }
          return parser(value);
        }, null);
      };
    }
    function zerofill(comp) {
      const hex = constrainRange(Math.floor(comp), 0, 255).toString(16);
      return hex.length === 1 ? `0${hex}` : hex;
    }
    function colorToHexRgbString(value, prefix = "#") {
      const hexes = removeAlphaComponent(value.getComponents("rgb")).map(zerofill).join("");
      return `${prefix}${hexes}`;
    }
    function colorToHexRgbaString(value, prefix = "#") {
      const rgbaComps = value.getComponents("rgb");
      const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255].map(zerofill).join("");
      return `${prefix}${hexes}`;
    }
    function colorToFunctionalRgbString(value, opt_type) {
      const formatter = createNumberFormatter(opt_type === "float" ? 2 : 0);
      const comps = removeAlphaComponent(value.getComponents("rgb", opt_type)).map((comp) => formatter(comp));
      return `rgb(${comps.join(", ")})`;
    }
    function createFunctionalRgbColorFormatter(type2) {
      return (value) => {
        return colorToFunctionalRgbString(value, type2);
      };
    }
    function colorToFunctionalRgbaString(value, opt_type) {
      const aFormatter = createNumberFormatter(2);
      const rgbFormatter = createNumberFormatter(opt_type === "float" ? 2 : 0);
      const comps = value.getComponents("rgb", opt_type).map((comp, index) => {
        const formatter = index === 3 ? aFormatter : rgbFormatter;
        return formatter(comp);
      });
      return `rgba(${comps.join(", ")})`;
    }
    function createFunctionalRgbaColorFormatter(type2) {
      return (value) => {
        return colorToFunctionalRgbaString(value, type2);
      };
    }
    function colorToFunctionalHslString(value) {
      const formatters = [
        createNumberFormatter(0),
        formatPercentage,
        formatPercentage
      ];
      const comps = removeAlphaComponent(value.getComponents("hsl")).map((comp, index) => formatters[index](comp));
      return `hsl(${comps.join(", ")})`;
    }
    function colorToFunctionalHslaString(value) {
      const formatters = [
        createNumberFormatter(0),
        formatPercentage,
        formatPercentage,
        createNumberFormatter(2)
      ];
      const comps = value.getComponents("hsl").map((comp, index) => formatters[index](comp));
      return `hsla(${comps.join(", ")})`;
    }
    function colorToObjectRgbString(value, type2) {
      const formatter = createNumberFormatter(type2 === "float" ? 2 : 0);
      const names = ["r", "g", "b"];
      const comps = removeAlphaComponent(value.getComponents("rgb", type2)).map((comp, index) => `${names[index]}: ${formatter(comp)}`);
      return `{${comps.join(", ")}}`;
    }
    function createObjectRgbColorFormatter(type2) {
      return (value) => colorToObjectRgbString(value, type2);
    }
    function colorToObjectRgbaString(value, type2) {
      const aFormatter = createNumberFormatter(2);
      const rgbFormatter = createNumberFormatter(type2 === "float" ? 2 : 0);
      const names = ["r", "g", "b", "a"];
      const comps = value.getComponents("rgb", type2).map((comp, index) => {
        const formatter = index === 3 ? aFormatter : rgbFormatter;
        return `${names[index]}: ${formatter(comp)}`;
      });
      return `{${comps.join(", ")}}`;
    }
    function createObjectRgbaColorFormatter(type2) {
      return (value) => colorToObjectRgbaString(value, type2);
    }
    const FORMAT_AND_STRINGIFIERS = [
      {
        format: {
          alpha: false,
          mode: "rgb",
          notation: "hex",
          type: "int"
        },
        stringifier: colorToHexRgbString
      },
      {
        format: {
          alpha: true,
          mode: "rgb",
          notation: "hex",
          type: "int"
        },
        stringifier: colorToHexRgbaString
      },
      {
        format: {
          alpha: false,
          mode: "hsl",
          notation: "func",
          type: "int"
        },
        stringifier: colorToFunctionalHslString
      },
      {
        format: {
          alpha: true,
          mode: "hsl",
          notation: "func",
          type: "int"
        },
        stringifier: colorToFunctionalHslaString
      },
      ...["int", "float"].reduce((prev, type2) => {
        return [
          ...prev,
          {
            format: {
              alpha: false,
              mode: "rgb",
              notation: "func",
              type: type2
            },
            stringifier: createFunctionalRgbColorFormatter(type2)
          },
          {
            format: {
              alpha: true,
              mode: "rgb",
              notation: "func",
              type: type2
            },
            stringifier: createFunctionalRgbaColorFormatter(type2)
          },
          {
            format: {
              alpha: false,
              mode: "rgb",
              notation: "object",
              type: type2
            },
            stringifier: createObjectRgbColorFormatter(type2)
          },
          {
            format: {
              alpha: true,
              mode: "rgb",
              notation: "object",
              type: type2
            },
            stringifier: createObjectRgbaColorFormatter(type2)
          }
        ];
      }, [])
    ];
    function findColorStringifier(format2) {
      return FORMAT_AND_STRINGIFIERS.reduce((prev, fas) => {
        if (prev) {
          return prev;
        }
        return equalsStringColorFormat(fas.format, format2) ? fas.stringifier : null;
      }, null);
    }
    const className$a = ClassName("apl");
    class APaletteView {
      constructor(doc, config) {
        this.onValueChange_ = this.onValueChange_.bind(this);
        this.value = config.value;
        this.value.emitter.on("change", this.onValueChange_);
        this.element = doc.createElement("div");
        this.element.classList.add(className$a());
        config.viewProps.bindClassModifiers(this.element);
        config.viewProps.bindTabIndex(this.element);
        const barElem = doc.createElement("div");
        barElem.classList.add(className$a("b"));
        this.element.appendChild(barElem);
        const colorElem = doc.createElement("div");
        colorElem.classList.add(className$a("c"));
        barElem.appendChild(colorElem);
        this.colorElem_ = colorElem;
        const markerElem = doc.createElement("div");
        markerElem.classList.add(className$a("m"));
        this.element.appendChild(markerElem);
        this.markerElem_ = markerElem;
        const previewElem = doc.createElement("div");
        previewElem.classList.add(className$a("p"));
        this.markerElem_.appendChild(previewElem);
        this.previewElem_ = previewElem;
        this.update_();
      }
      update_() {
        const c = this.value.rawValue;
        const rgbaComps = c.getComponents("rgb");
        const leftColor = new Color([rgbaComps[0], rgbaComps[1], rgbaComps[2], 0], "rgb");
        const rightColor = new Color([rgbaComps[0], rgbaComps[1], rgbaComps[2], 255], "rgb");
        const gradientComps = [
          "to right",
          colorToFunctionalRgbaString(leftColor),
          colorToFunctionalRgbaString(rightColor)
        ];
        this.colorElem_.style.background = `linear-gradient(${gradientComps.join(",")})`;
        this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString(c);
        const left = mapRange(rgbaComps[3], 0, 1, 0, 100);
        this.markerElem_.style.left = `${left}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class APaletteController {
      constructor(doc, config) {
        this.onKeyDown_ = this.onKeyDown_.bind(this);
        this.onKeyUp_ = this.onKeyUp_.bind(this);
        this.onPointerDown_ = this.onPointerDown_.bind(this);
        this.onPointerMove_ = this.onPointerMove_.bind(this);
        this.onPointerUp_ = this.onPointerUp_.bind(this);
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.view = new APaletteView(doc, {
          value: this.value,
          viewProps: this.viewProps
        });
        this.ptHandler_ = new PointerHandler(this.view.element);
        this.ptHandler_.emitter.on("down", this.onPointerDown_);
        this.ptHandler_.emitter.on("move", this.onPointerMove_);
        this.ptHandler_.emitter.on("up", this.onPointerUp_);
        this.view.element.addEventListener("keydown", this.onKeyDown_);
        this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(d2, opts) {
        if (!d2.point) {
          return;
        }
        const alpha = d2.point.x / d2.bounds.width;
        const c = this.value.rawValue;
        const [h2, s2, v2] = c.getComponents("hsv");
        this.value.setRawValue(new Color([h2, s2, v2, alpha], "hsv"), opts);
      }
      onPointerDown_(ev) {
        this.handlePointerEvent_(ev.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerMove_(ev) {
        this.handlePointerEvent_(ev.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerUp_(ev) {
        this.handlePointerEvent_(ev.data, {
          forceEmit: true,
          last: true
        });
      }
      onKeyDown_(ev) {
        const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
        if (step === 0) {
          return;
        }
        const c = this.value.rawValue;
        const [h2, s2, v2, a2] = c.getComponents("hsv");
        this.value.setRawValue(new Color([h2, s2, v2, a2 + step], "hsv"), {
          forceEmit: false,
          last: false
        });
      }
      onKeyUp_(ev) {
        const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
        if (step === 0) {
          return;
        }
        this.value.setRawValue(this.value.rawValue, {
          forceEmit: true,
          last: true
        });
      }
    }
    const className$9 = ClassName("coltxt");
    function createModeSelectElement(doc) {
      const selectElem = doc.createElement("select");
      const items = [
        { text: "RGB", value: "rgb" },
        { text: "HSL", value: "hsl" },
        { text: "HSV", value: "hsv" }
      ];
      selectElem.appendChild(items.reduce((frag2, item) => {
        const optElem = doc.createElement("option");
        optElem.textContent = item.text;
        optElem.value = item.value;
        frag2.appendChild(optElem);
        return frag2;
      }, doc.createDocumentFragment()));
      return selectElem;
    }
    class ColorTextView {
      constructor(doc, config) {
        this.element = doc.createElement("div");
        this.element.classList.add(className$9());
        config.viewProps.bindClassModifiers(this.element);
        const modeElem = doc.createElement("div");
        modeElem.classList.add(className$9("m"));
        this.modeElem_ = createModeSelectElement(doc);
        this.modeElem_.classList.add(className$9("ms"));
        modeElem.appendChild(this.modeSelectElement);
        config.viewProps.bindDisabled(this.modeElem_);
        const modeMarkerElem = doc.createElement("div");
        modeMarkerElem.classList.add(className$9("mm"));
        modeMarkerElem.appendChild(createSvgIconElement(doc, "dropdown"));
        modeElem.appendChild(modeMarkerElem);
        this.element.appendChild(modeElem);
        const textsElem = doc.createElement("div");
        textsElem.classList.add(className$9("w"));
        this.element.appendChild(textsElem);
        this.textsElem_ = textsElem;
        this.textViews_ = config.textViews;
        this.applyTextViews_();
        bindValue(config.colorMode, (mode) => {
          this.modeElem_.value = mode;
        });
      }
      get modeSelectElement() {
        return this.modeElem_;
      }
      get textViews() {
        return this.textViews_;
      }
      set textViews(textViews) {
        this.textViews_ = textViews;
        this.applyTextViews_();
      }
      applyTextViews_() {
        removeChildElements(this.textsElem_);
        const doc = this.element.ownerDocument;
        this.textViews_.forEach((v2) => {
          const compElem = doc.createElement("div");
          compElem.classList.add(className$9("c"));
          compElem.appendChild(v2.element);
          this.textsElem_.appendChild(compElem);
        });
      }
    }
    function createFormatter$2(type2) {
      return createNumberFormatter(type2 === "float" ? 2 : 0);
    }
    function createConstraint$5(mode, type2, index) {
      const max2 = getColorMaxComponents(mode, type2)[index];
      return new DefiniteRangeConstraint({
        min: 0,
        max: max2
      });
    }
    function createComponentController(doc, config, index) {
      return new NumberTextController(doc, {
        arrayPosition: index === 0 ? "fst" : index === 3 - 1 ? "lst" : "mid",
        baseStep: getBaseStepForColor(false),
        parser: config.parser,
        props: ValueMap.fromObject({
          draggingScale: config.colorType === "float" ? 0.01 : 1,
          formatter: createFormatter$2(config.colorType)
        }),
        value: createValue(0, {
          constraint: createConstraint$5(config.colorMode, config.colorType, index)
        }),
        viewProps: config.viewProps
      });
    }
    class ColorTextController {
      constructor(doc, config) {
        this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
        this.colorType_ = config.colorType;
        this.parser_ = config.parser;
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.colorMode = createValue(this.value.rawValue.mode);
        this.ccs_ = this.createComponentControllers_(doc);
        this.view = new ColorTextView(doc, {
          colorMode: this.colorMode,
          textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
          viewProps: this.viewProps
        });
        this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
      }
      createComponentControllers_(doc) {
        const cc = {
          colorMode: this.colorMode.rawValue,
          colorType: this.colorType_,
          parser: this.parser_,
          viewProps: this.viewProps
        };
        const ccs = [
          createComponentController(doc, cc, 0),
          createComponentController(doc, cc, 1),
          createComponentController(doc, cc, 2)
        ];
        ccs.forEach((cs, index) => {
          connectValues({
            primary: this.value,
            secondary: cs.value,
            forward: (p2) => {
              return p2.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[index];
            },
            backward: (p2, s2) => {
              const pickedMode = this.colorMode.rawValue;
              const comps = p2.rawValue.getComponents(pickedMode, this.colorType_);
              comps[index] = s2.rawValue;
              return new Color(appendAlphaComponent(removeAlphaComponent(comps), comps[3]), pickedMode, this.colorType_);
            }
          });
        });
        return ccs;
      }
      onModeSelectChange_(ev) {
        const selectElem = ev.currentTarget;
        this.colorMode.rawValue = selectElem.value;
        this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument);
        this.view.textViews = [
          this.ccs_[0].view,
          this.ccs_[1].view,
          this.ccs_[2].view
        ];
      }
    }
    const className$8 = ClassName("hpl");
    class HPaletteView {
      constructor(doc, config) {
        this.onValueChange_ = this.onValueChange_.bind(this);
        this.value = config.value;
        this.value.emitter.on("change", this.onValueChange_);
        this.element = doc.createElement("div");
        this.element.classList.add(className$8());
        config.viewProps.bindClassModifiers(this.element);
        config.viewProps.bindTabIndex(this.element);
        const colorElem = doc.createElement("div");
        colorElem.classList.add(className$8("c"));
        this.element.appendChild(colorElem);
        const markerElem = doc.createElement("div");
        markerElem.classList.add(className$8("m"));
        this.element.appendChild(markerElem);
        this.markerElem_ = markerElem;
        this.update_();
      }
      update_() {
        const c = this.value.rawValue;
        const [h2] = c.getComponents("hsv");
        this.markerElem_.style.backgroundColor = colorToFunctionalRgbString(new Color([h2, 100, 100], "hsv"));
        const left = mapRange(h2, 0, 360, 0, 100);
        this.markerElem_.style.left = `${left}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class HPaletteController {
      constructor(doc, config) {
        this.onKeyDown_ = this.onKeyDown_.bind(this);
        this.onKeyUp_ = this.onKeyUp_.bind(this);
        this.onPointerDown_ = this.onPointerDown_.bind(this);
        this.onPointerMove_ = this.onPointerMove_.bind(this);
        this.onPointerUp_ = this.onPointerUp_.bind(this);
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.view = new HPaletteView(doc, {
          value: this.value,
          viewProps: this.viewProps
        });
        this.ptHandler_ = new PointerHandler(this.view.element);
        this.ptHandler_.emitter.on("down", this.onPointerDown_);
        this.ptHandler_.emitter.on("move", this.onPointerMove_);
        this.ptHandler_.emitter.on("up", this.onPointerUp_);
        this.view.element.addEventListener("keydown", this.onKeyDown_);
        this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(d2, opts) {
        if (!d2.point) {
          return;
        }
        const hue = mapRange(constrainRange(d2.point.x, 0, d2.bounds.width), 0, d2.bounds.width, 0, 360);
        const c = this.value.rawValue;
        const [, s2, v2, a2] = c.getComponents("hsv");
        this.value.setRawValue(new Color([hue, s2, v2, a2], "hsv"), opts);
      }
      onPointerDown_(ev) {
        this.handlePointerEvent_(ev.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerMove_(ev) {
        this.handlePointerEvent_(ev.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerUp_(ev) {
        this.handlePointerEvent_(ev.data, {
          forceEmit: true,
          last: true
        });
      }
      onKeyDown_(ev) {
        const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
        if (step === 0) {
          return;
        }
        const c = this.value.rawValue;
        const [h2, s2, v2, a2] = c.getComponents("hsv");
        this.value.setRawValue(new Color([h2 + step, s2, v2, a2], "hsv"), {
          forceEmit: false,
          last: false
        });
      }
      onKeyUp_(ev) {
        const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
        if (step === 0) {
          return;
        }
        this.value.setRawValue(this.value.rawValue, {
          forceEmit: true,
          last: true
        });
      }
    }
    const className$7 = ClassName("svp");
    const CANVAS_RESOL = 64;
    class SvPaletteView {
      constructor(doc, config) {
        this.onValueChange_ = this.onValueChange_.bind(this);
        this.value = config.value;
        this.value.emitter.on("change", this.onValueChange_);
        this.element = doc.createElement("div");
        this.element.classList.add(className$7());
        config.viewProps.bindClassModifiers(this.element);
        config.viewProps.bindTabIndex(this.element);
        const canvasElem = doc.createElement("canvas");
        canvasElem.height = CANVAS_RESOL;
        canvasElem.width = CANVAS_RESOL;
        canvasElem.classList.add(className$7("c"));
        this.element.appendChild(canvasElem);
        this.canvasElement = canvasElem;
        const markerElem = doc.createElement("div");
        markerElem.classList.add(className$7("m"));
        this.element.appendChild(markerElem);
        this.markerElem_ = markerElem;
        this.update_();
      }
      update_() {
        const ctx = getCanvasContext(this.canvasElement);
        if (!ctx) {
          return;
        }
        const c = this.value.rawValue;
        const hsvComps = c.getComponents("hsv");
        const width = this.canvasElement.width;
        const height = this.canvasElement.height;
        const imgData = ctx.getImageData(0, 0, width, height);
        const data = imgData.data;
        for (let iy = 0; iy < height; iy++) {
          for (let ix = 0; ix < width; ix++) {
            const s2 = mapRange(ix, 0, width, 0, 100);
            const v2 = mapRange(iy, 0, height, 100, 0);
            const rgbComps = hsvToRgbInt(hsvComps[0], s2, v2);
            const i = (iy * width + ix) * 4;
            data[i] = rgbComps[0];
            data[i + 1] = rgbComps[1];
            data[i + 2] = rgbComps[2];
            data[i + 3] = 255;
          }
        }
        ctx.putImageData(imgData, 0, 0);
        const left = mapRange(hsvComps[1], 0, 100, 0, 100);
        this.markerElem_.style.left = `${left}%`;
        const top = mapRange(hsvComps[2], 0, 100, 100, 0);
        this.markerElem_.style.top = `${top}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class SvPaletteController {
      constructor(doc, config) {
        this.onKeyDown_ = this.onKeyDown_.bind(this);
        this.onKeyUp_ = this.onKeyUp_.bind(this);
        this.onPointerDown_ = this.onPointerDown_.bind(this);
        this.onPointerMove_ = this.onPointerMove_.bind(this);
        this.onPointerUp_ = this.onPointerUp_.bind(this);
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.view = new SvPaletteView(doc, {
          value: this.value,
          viewProps: this.viewProps
        });
        this.ptHandler_ = new PointerHandler(this.view.element);
        this.ptHandler_.emitter.on("down", this.onPointerDown_);
        this.ptHandler_.emitter.on("move", this.onPointerMove_);
        this.ptHandler_.emitter.on("up", this.onPointerUp_);
        this.view.element.addEventListener("keydown", this.onKeyDown_);
        this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(d2, opts) {
        if (!d2.point) {
          return;
        }
        const saturation = mapRange(d2.point.x, 0, d2.bounds.width, 0, 100);
        const value = mapRange(d2.point.y, 0, d2.bounds.height, 100, 0);
        const [h2, , , a2] = this.value.rawValue.getComponents("hsv");
        this.value.setRawValue(new Color([h2, saturation, value, a2], "hsv"), opts);
      }
      onPointerDown_(ev) {
        this.handlePointerEvent_(ev.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerMove_(ev) {
        this.handlePointerEvent_(ev.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerUp_(ev) {
        this.handlePointerEvent_(ev.data, {
          forceEmit: true,
          last: true
        });
      }
      onKeyDown_(ev) {
        if (isArrowKey(ev.key)) {
          ev.preventDefault();
        }
        const [h2, s2, v2, a2] = this.value.rawValue.getComponents("hsv");
        const baseStep = getBaseStepForColor(false);
        const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
        const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
        if (ds === 0 && dv === 0) {
          return;
        }
        this.value.setRawValue(new Color([h2, s2 + ds, v2 + dv, a2], "hsv"), {
          forceEmit: false,
          last: false
        });
      }
      onKeyUp_(ev) {
        const baseStep = getBaseStepForColor(false);
        const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
        const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
        if (ds === 0 && dv === 0) {
          return;
        }
        this.value.setRawValue(this.value.rawValue, {
          forceEmit: true,
          last: true
        });
      }
    }
    class ColorPickerController {
      constructor(doc, config) {
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.hPaletteC_ = new HPaletteController(doc, {
          value: this.value,
          viewProps: this.viewProps
        });
        this.svPaletteC_ = new SvPaletteController(doc, {
          value: this.value,
          viewProps: this.viewProps
        });
        this.alphaIcs_ = config.supportsAlpha ? {
          palette: new APaletteController(doc, {
            value: this.value,
            viewProps: this.viewProps
          }),
          text: new NumberTextController(doc, {
            parser: parseNumber,
            baseStep: 0.1,
            props: ValueMap.fromObject({
              draggingScale: 0.01,
              formatter: createNumberFormatter(2)
            }),
            value: createValue(0, {
              constraint: new DefiniteRangeConstraint({ min: 0, max: 1 })
            }),
            viewProps: this.viewProps
          })
        } : null;
        if (this.alphaIcs_) {
          connectValues({
            primary: this.value,
            secondary: this.alphaIcs_.text.value,
            forward: (p2) => {
              return p2.rawValue.getComponents()[3];
            },
            backward: (p2, s2) => {
              const comps = p2.rawValue.getComponents();
              comps[3] = s2.rawValue;
              return new Color(comps, p2.rawValue.mode);
            }
          });
        }
        this.textC_ = new ColorTextController(doc, {
          colorType: config.colorType,
          parser: parseNumber,
          value: this.value,
          viewProps: this.viewProps
        });
        this.view = new ColorPickerView(doc, {
          alphaViews: this.alphaIcs_ ? {
            palette: this.alphaIcs_.palette.view,
            text: this.alphaIcs_.text.view
          } : null,
          hPaletteView: this.hPaletteC_.view,
          supportsAlpha: config.supportsAlpha,
          svPaletteView: this.svPaletteC_.view,
          textView: this.textC_.view,
          viewProps: this.viewProps
        });
      }
      get textController() {
        return this.textC_;
      }
    }
    const className$6 = ClassName("colsw");
    class ColorSwatchView {
      constructor(doc, config) {
        this.onValueChange_ = this.onValueChange_.bind(this);
        config.value.emitter.on("change", this.onValueChange_);
        this.value = config.value;
        this.element = doc.createElement("div");
        this.element.classList.add(className$6());
        config.viewProps.bindClassModifiers(this.element);
        const swatchElem = doc.createElement("div");
        swatchElem.classList.add(className$6("sw"));
        this.element.appendChild(swatchElem);
        this.swatchElem_ = swatchElem;
        const buttonElem = doc.createElement("button");
        buttonElem.classList.add(className$6("b"));
        config.viewProps.bindDisabled(buttonElem);
        this.element.appendChild(buttonElem);
        this.buttonElement = buttonElem;
        this.update_();
      }
      update_() {
        const value = this.value.rawValue;
        this.swatchElem_.style.backgroundColor = colorToHexRgbaString(value);
      }
      onValueChange_() {
        this.update_();
      }
    }
    class ColorSwatchController {
      constructor(doc, config) {
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.view = new ColorSwatchView(doc, {
          value: this.value,
          viewProps: this.viewProps
        });
      }
    }
    class ColorController {
      constructor(doc, config) {
        this.onButtonBlur_ = this.onButtonBlur_.bind(this);
        this.onButtonClick_ = this.onButtonClick_.bind(this);
        this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
        this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.foldable_ = Foldable.create(config.expanded);
        this.swatchC_ = new ColorSwatchController(doc, {
          value: this.value,
          viewProps: this.viewProps
        });
        const buttonElem = this.swatchC_.view.buttonElement;
        buttonElem.addEventListener("blur", this.onButtonBlur_);
        buttonElem.addEventListener("click", this.onButtonClick_);
        this.textC_ = new TextController(doc, {
          parser: config.parser,
          props: ValueMap.fromObject({
            formatter: config.formatter
          }),
          value: this.value,
          viewProps: this.viewProps
        });
        this.view = new ColorView(doc, {
          foldable: this.foldable_,
          pickerLayout: config.pickerLayout
        });
        this.view.swatchElement.appendChild(this.swatchC_.view.element);
        this.view.textElement.appendChild(this.textC_.view.element);
        this.popC_ = config.pickerLayout === "popup" ? new PopupController(doc, {
          viewProps: this.viewProps
        }) : null;
        const pickerC = new ColorPickerController(doc, {
          colorType: config.colorType,
          supportsAlpha: config.supportsAlpha,
          value: this.value,
          viewProps: this.viewProps
        });
        pickerC.view.allFocusableElements.forEach((elem) => {
          elem.addEventListener("blur", this.onPopupChildBlur_);
          elem.addEventListener("keydown", this.onPopupChildKeydown_);
        });
        this.pickerC_ = pickerC;
        if (this.popC_) {
          this.view.element.appendChild(this.popC_.view.element);
          this.popC_.view.element.appendChild(pickerC.view.element);
          connectValues({
            primary: this.foldable_.value("expanded"),
            secondary: this.popC_.shows,
            forward: (p2) => p2.rawValue,
            backward: (_, s2) => s2.rawValue
          });
        } else if (this.view.pickerElement) {
          this.view.pickerElement.appendChild(this.pickerC_.view.element);
          bindFoldable(this.foldable_, this.view.pickerElement);
        }
      }
      get textController() {
        return this.textC_;
      }
      onButtonBlur_(e2) {
        if (!this.popC_) {
          return;
        }
        const elem = this.view.element;
        const nextTarget = forceCast(e2.relatedTarget);
        if (!nextTarget || !elem.contains(nextTarget)) {
          this.popC_.shows.rawValue = false;
        }
      }
      onButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded"));
        if (this.foldable_.get("expanded")) {
          this.pickerC_.view.allFocusableElements[0].focus();
        }
      }
      onPopupChildBlur_(ev) {
        if (!this.popC_) {
          return;
        }
        const elem = this.popC_.view.element;
        const nextTarget = findNextTarget(ev);
        if (nextTarget && elem.contains(nextTarget)) {
          return;
        }
        if (nextTarget && nextTarget === this.swatchC_.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
          return;
        }
        this.popC_.shows.rawValue = false;
      }
      onPopupChildKeydown_(ev) {
        if (this.popC_) {
          if (ev.key === "Escape") {
            this.popC_.shows.rawValue = false;
          }
        } else if (this.view.pickerElement) {
          if (ev.key === "Escape") {
            this.swatchC_.view.buttonElement.focus();
          }
        }
      }
    }
    function colorFromObject(value, opt_type) {
      if (Color.isColorObject(value)) {
        return Color.fromObject(value, opt_type);
      }
      return Color.black(opt_type);
    }
    function colorToRgbNumber(value) {
      return removeAlphaComponent(value.getComponents("rgb")).reduce((result, comp) => {
        return result << 8 | Math.floor(comp) & 255;
      }, 0);
    }
    function colorToRgbaNumber(value) {
      return value.getComponents("rgb").reduce((result, comp, index) => {
        const hex = Math.floor(index === 3 ? comp * 255 : comp) & 255;
        return result << 8 | hex;
      }, 0) >>> 0;
    }
    function numberToRgbColor(num) {
      return new Color([num >> 16 & 255, num >> 8 & 255, num & 255], "rgb");
    }
    function numberToRgbaColor(num) {
      return new Color([
        num >> 24 & 255,
        num >> 16 & 255,
        num >> 8 & 255,
        mapRange(num & 255, 0, 255, 0, 1)
      ], "rgb");
    }
    function colorFromRgbNumber(value) {
      if (typeof value !== "number") {
        return Color.black();
      }
      return numberToRgbColor(value);
    }
    function colorFromRgbaNumber(value) {
      if (typeof value !== "number") {
        return Color.black();
      }
      return numberToRgbaColor(value);
    }
    function createColorStringWriter(format2) {
      const stringify3 = findColorStringifier(format2);
      return stringify3 ? (target, value) => {
        writePrimitive(target, stringify3(value));
      } : null;
    }
    function createColorNumberWriter(supportsAlpha) {
      const colorToNumber = supportsAlpha ? colorToRgbaNumber : colorToRgbNumber;
      return (target, value) => {
        writePrimitive(target, colorToNumber(value));
      };
    }
    function writeRgbaColorObject(target, value, opt_type) {
      const obj = value.toRgbaObject(opt_type);
      target.writeProperty("r", obj.r);
      target.writeProperty("g", obj.g);
      target.writeProperty("b", obj.b);
      target.writeProperty("a", obj.a);
    }
    function writeRgbColorObject(target, value, opt_type) {
      const obj = value.toRgbaObject(opt_type);
      target.writeProperty("r", obj.r);
      target.writeProperty("g", obj.g);
      target.writeProperty("b", obj.b);
    }
    function createColorObjectWriter(supportsAlpha, opt_type) {
      return (target, inValue) => {
        if (supportsAlpha) {
          writeRgbaColorObject(target, inValue, opt_type);
        } else {
          writeRgbColorObject(target, inValue, opt_type);
        }
      };
    }
    function shouldSupportAlpha$1(inputParams) {
      var _a2;
      if ((inputParams === null || inputParams === void 0 ? void 0 : inputParams.alpha) || ((_a2 = inputParams === null || inputParams === void 0 ? void 0 : inputParams.color) === null || _a2 === void 0 ? void 0 : _a2.alpha)) {
        return true;
      }
      return false;
    }
    function createFormatter$1(supportsAlpha) {
      return supportsAlpha ? (v2) => colorToHexRgbaString(v2, "0x") : (v2) => colorToHexRgbString(v2, "0x");
    }
    function isForColor(params) {
      if ("color" in params) {
        return true;
      }
      if ("view" in params && params.view === "color") {
        return true;
      }
      return false;
    }
    const NumberColorInputPlugin = {
      id: "input-color-number",
      type: "input",
      accept: (value, params) => {
        if (typeof value !== "number") {
          return null;
        }
        if (!isForColor(params)) {
          return null;
        }
        const result = parseColorInputParams(params);
        return result ? {
          initialValue: value,
          params: result
        } : null;
      },
      binding: {
        reader: (args) => {
          return shouldSupportAlpha$1(args.params) ? colorFromRgbaNumber : colorFromRgbNumber;
        },
        equals: Color.equals,
        writer: (args) => {
          return createColorNumberWriter(shouldSupportAlpha$1(args.params));
        }
      },
      controller: (args) => {
        const supportsAlpha = shouldSupportAlpha$1(args.params);
        const expanded = "expanded" in args.params ? args.params.expanded : void 0;
        const picker = "picker" in args.params ? args.params.picker : void 0;
        return new ColorController(args.document, {
          colorType: "int",
          expanded: expanded !== null && expanded !== void 0 ? expanded : false,
          formatter: createFormatter$1(supportsAlpha),
          parser: createColorStringParser("int"),
          pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
          supportsAlpha,
          value: args.value,
          viewProps: args.viewProps
        });
      }
    };
    function shouldSupportAlpha(initialValue) {
      return Color.isRgbaColorObject(initialValue);
    }
    function createColorObjectReader(opt_type) {
      return (value) => {
        return colorFromObject(value, opt_type);
      };
    }
    function createColorObjectFormatter(supportsAlpha, type2) {
      return (value) => {
        if (supportsAlpha) {
          return colorToObjectRgbaString(value, type2);
        }
        return colorToObjectRgbString(value, type2);
      };
    }
    const ObjectColorInputPlugin = {
      id: "input-color-object",
      type: "input",
      accept: (value, params) => {
        if (!Color.isColorObject(value)) {
          return null;
        }
        const result = parseColorInputParams(params);
        return result ? {
          initialValue: value,
          params: result
        } : null;
      },
      binding: {
        reader: (args) => createColorObjectReader(extractColorType(args.params)),
        equals: Color.equals,
        writer: (args) => createColorObjectWriter(shouldSupportAlpha(args.initialValue), extractColorType(args.params))
      },
      controller: (args) => {
        var _a2;
        const supportsAlpha = Color.isRgbaColorObject(args.initialValue);
        const expanded = "expanded" in args.params ? args.params.expanded : void 0;
        const picker = "picker" in args.params ? args.params.picker : void 0;
        const type2 = (_a2 = extractColorType(args.params)) !== null && _a2 !== void 0 ? _a2 : "int";
        return new ColorController(args.document, {
          colorType: type2,
          expanded: expanded !== null && expanded !== void 0 ? expanded : false,
          formatter: createColorObjectFormatter(supportsAlpha, type2),
          parser: createColorStringParser(type2),
          pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
          supportsAlpha,
          value: args.value,
          viewProps: args.viewProps
        });
      }
    };
    const StringColorInputPlugin = {
      id: "input-color-string",
      type: "input",
      accept: (value, params) => {
        if (typeof value !== "string") {
          return null;
        }
        if ("view" in params && params.view === "text") {
          return null;
        }
        const format2 = detectStringColorFormat(value, extractColorType(params));
        if (!format2) {
          return null;
        }
        const stringifier = findColorStringifier(format2);
        if (!stringifier) {
          return null;
        }
        const result = parseColorInputParams(params);
        return result ? {
          initialValue: value,
          params: result
        } : null;
      },
      binding: {
        reader: (args) => {
          var _a2;
          return createColorStringBindingReader((_a2 = extractColorType(args.params)) !== null && _a2 !== void 0 ? _a2 : "int");
        },
        equals: Color.equals,
        writer: (args) => {
          const format2 = detectStringColorFormat(args.initialValue, extractColorType(args.params));
          if (!format2) {
            throw TpError.shouldNeverHappen();
          }
          const writer = createColorStringWriter(format2);
          if (!writer) {
            throw TpError.notBindable();
          }
          return writer;
        }
      },
      controller: (args) => {
        const format2 = detectStringColorFormat(args.initialValue, extractColorType(args.params));
        if (!format2) {
          throw TpError.shouldNeverHappen();
        }
        const stringifier = findColorStringifier(format2);
        if (!stringifier) {
          throw TpError.shouldNeverHappen();
        }
        const expanded = "expanded" in args.params ? args.params.expanded : void 0;
        const picker = "picker" in args.params ? args.params.picker : void 0;
        return new ColorController(args.document, {
          colorType: format2.type,
          expanded: expanded !== null && expanded !== void 0 ? expanded : false,
          formatter: stringifier,
          parser: createColorStringParser(format2.type),
          pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
          supportsAlpha: format2.alpha,
          value: args.value,
          viewProps: args.viewProps
        });
      }
    };
    class PointNdConstraint {
      constructor(config) {
        this.components = config.components;
        this.asm_ = config.assembly;
      }
      constrain(value) {
        const comps = this.asm_.toComponents(value).map((comp, index) => {
          var _a2, _b2;
          return (_b2 = (_a2 = this.components[index]) === null || _a2 === void 0 ? void 0 : _a2.constrain(comp)) !== null && _b2 !== void 0 ? _b2 : comp;
        });
        return this.asm_.fromComponents(comps);
      }
    }
    const className$5 = ClassName("pndtxt");
    class PointNdTextView {
      constructor(doc, config) {
        this.textViews = config.textViews;
        this.element = doc.createElement("div");
        this.element.classList.add(className$5());
        this.textViews.forEach((v2) => {
          const axisElem = doc.createElement("div");
          axisElem.classList.add(className$5("a"));
          axisElem.appendChild(v2.element);
          this.element.appendChild(axisElem);
        });
      }
    }
    function createAxisController(doc, config, index) {
      return new NumberTextController(doc, {
        arrayPosition: index === 0 ? "fst" : index === config.axes.length - 1 ? "lst" : "mid",
        baseStep: config.axes[index].baseStep,
        parser: config.parser,
        props: config.axes[index].textProps,
        value: createValue(0, {
          constraint: config.axes[index].constraint
        }),
        viewProps: config.viewProps
      });
    }
    class PointNdTextController {
      constructor(doc, config) {
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.acs_ = config.axes.map((_, index) => createAxisController(doc, config, index));
        this.acs_.forEach((c, index) => {
          connectValues({
            primary: this.value,
            secondary: c.value,
            forward: (p2) => {
              return config.assembly.toComponents(p2.rawValue)[index];
            },
            backward: (p2, s2) => {
              const comps = config.assembly.toComponents(p2.rawValue);
              comps[index] = s2.rawValue;
              return config.assembly.fromComponents(comps);
            }
          });
        });
        this.view = new PointNdTextView(doc, {
          textViews: this.acs_.map((ac) => ac.view)
        });
      }
    }
    function createStepConstraint(params, initialValue) {
      if ("step" in params && !isEmpty(params.step)) {
        return new StepConstraint(params.step, initialValue);
      }
      return null;
    }
    function createRangeConstraint(params) {
      if (!isEmpty(params.max) && !isEmpty(params.min)) {
        return new DefiniteRangeConstraint({
          max: params.max,
          min: params.min
        });
      }
      if (!isEmpty(params.max) || !isEmpty(params.min)) {
        return new RangeConstraint({
          max: params.max,
          min: params.min
        });
      }
      return null;
    }
    function findNumberRange(c) {
      const drc = findConstraint(c, DefiniteRangeConstraint);
      if (drc) {
        return [drc.values.get("min"), drc.values.get("max")];
      }
      const rc = findConstraint(c, RangeConstraint);
      if (rc) {
        return [rc.minValue, rc.maxValue];
      }
      return [void 0, void 0];
    }
    function createConstraint$4(params, initialValue) {
      const constraints = [];
      const sc = createStepConstraint(params, initialValue);
      if (sc) {
        constraints.push(sc);
      }
      const rc = createRangeConstraint(params);
      if (rc) {
        constraints.push(rc);
      }
      const lc = createListConstraint(params.options);
      if (lc) {
        constraints.push(lc);
      }
      return new CompositeConstraint(constraints);
    }
    const NumberInputPlugin = {
      id: "input-number",
      type: "input",
      accept: (value, params) => {
        if (typeof value !== "number") {
          return null;
        }
        const p2 = ParamsParsers;
        const result = parseParams(params, {
          format: p2.optional.function,
          max: p2.optional.number,
          min: p2.optional.number,
          options: p2.optional.custom(parseListOptions),
          step: p2.optional.number
        });
        return result ? {
          initialValue: value,
          params: result
        } : null;
      },
      binding: {
        reader: (_args) => numberFromUnknown,
        constraint: (args) => createConstraint$4(args.params, args.initialValue),
        writer: (_args) => writePrimitive
      },
      controller: (args) => {
        var _a2;
        const value = args.value;
        const c = args.constraint;
        const lc = c && findConstraint(c, ListConstraint);
        if (lc) {
          return new ListController(args.document, {
            props: new ValueMap({
              options: lc.values.value("options")
            }),
            value,
            viewProps: args.viewProps
          });
        }
        const formatter = (_a2 = "format" in args.params ? args.params.format : void 0) !== null && _a2 !== void 0 ? _a2 : createNumberFormatter(getSuitableDecimalDigits(c, value.rawValue));
        const drc = c && findConstraint(c, DefiniteRangeConstraint);
        if (drc) {
          return new SliderTextController(args.document, {
            baseStep: getBaseStep(c),
            parser: parseNumber,
            sliderProps: new ValueMap({
              maxValue: drc.values.value("max"),
              minValue: drc.values.value("min")
            }),
            textProps: ValueMap.fromObject({
              draggingScale: getSuitableDraggingScale(c, value.rawValue),
              formatter
            }),
            value,
            viewProps: args.viewProps
          });
        }
        return new NumberTextController(args.document, {
          baseStep: getBaseStep(c),
          parser: parseNumber,
          props: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(c, value.rawValue),
            formatter
          }),
          value,
          viewProps: args.viewProps
        });
      }
    };
    class Point2d {
      constructor(x2 = 0, y2 = 0) {
        this.x = x2;
        this.y = y2;
      }
      getComponents() {
        return [this.x, this.y];
      }
      static isObject(obj) {
        if (isEmpty(obj)) {
          return false;
        }
        const x2 = obj.x;
        const y2 = obj.y;
        if (typeof x2 !== "number" || typeof y2 !== "number") {
          return false;
        }
        return true;
      }
      static equals(v1, v2) {
        return v1.x === v2.x && v1.y === v2.y;
      }
      toObject() {
        return {
          x: this.x,
          y: this.y
        };
      }
    }
    const Point2dAssembly = {
      toComponents: (p2) => p2.getComponents(),
      fromComponents: (comps) => new Point2d(...comps)
    };
    const className$4 = ClassName("p2d");
    class Point2dView {
      constructor(doc, config) {
        this.element = doc.createElement("div");
        this.element.classList.add(className$4());
        config.viewProps.bindClassModifiers(this.element);
        bindValue(config.expanded, valueToClassName(this.element, className$4(void 0, "expanded")));
        const headElem = doc.createElement("div");
        headElem.classList.add(className$4("h"));
        this.element.appendChild(headElem);
        const buttonElem = doc.createElement("button");
        buttonElem.classList.add(className$4("b"));
        buttonElem.appendChild(createSvgIconElement(doc, "p2dpad"));
        config.viewProps.bindDisabled(buttonElem);
        headElem.appendChild(buttonElem);
        this.buttonElement = buttonElem;
        const textElem = doc.createElement("div");
        textElem.classList.add(className$4("t"));
        headElem.appendChild(textElem);
        this.textElement = textElem;
        if (config.pickerLayout === "inline") {
          const pickerElem = doc.createElement("div");
          pickerElem.classList.add(className$4("p"));
          this.element.appendChild(pickerElem);
          this.pickerElement = pickerElem;
        } else {
          this.pickerElement = null;
        }
      }
    }
    const className$3 = ClassName("p2dp");
    class Point2dPickerView {
      constructor(doc, config) {
        this.onFoldableChange_ = this.onFoldableChange_.bind(this);
        this.onValueChange_ = this.onValueChange_.bind(this);
        this.invertsY_ = config.invertsY;
        this.maxValue_ = config.maxValue;
        this.element = doc.createElement("div");
        this.element.classList.add(className$3());
        if (config.layout === "popup") {
          this.element.classList.add(className$3(void 0, "p"));
        }
        config.viewProps.bindClassModifiers(this.element);
        const padElem = doc.createElement("div");
        padElem.classList.add(className$3("p"));
        config.viewProps.bindTabIndex(padElem);
        this.element.appendChild(padElem);
        this.padElement = padElem;
        const svgElem = doc.createElementNS(SVG_NS, "svg");
        svgElem.classList.add(className$3("g"));
        this.padElement.appendChild(svgElem);
        this.svgElem_ = svgElem;
        const xAxisElem = doc.createElementNS(SVG_NS, "line");
        xAxisElem.classList.add(className$3("ax"));
        xAxisElem.setAttributeNS(null, "x1", "0");
        xAxisElem.setAttributeNS(null, "y1", "50%");
        xAxisElem.setAttributeNS(null, "x2", "100%");
        xAxisElem.setAttributeNS(null, "y2", "50%");
        this.svgElem_.appendChild(xAxisElem);
        const yAxisElem = doc.createElementNS(SVG_NS, "line");
        yAxisElem.classList.add(className$3("ax"));
        yAxisElem.setAttributeNS(null, "x1", "50%");
        yAxisElem.setAttributeNS(null, "y1", "0");
        yAxisElem.setAttributeNS(null, "x2", "50%");
        yAxisElem.setAttributeNS(null, "y2", "100%");
        this.svgElem_.appendChild(yAxisElem);
        const lineElem = doc.createElementNS(SVG_NS, "line");
        lineElem.classList.add(className$3("l"));
        lineElem.setAttributeNS(null, "x1", "50%");
        lineElem.setAttributeNS(null, "y1", "50%");
        this.svgElem_.appendChild(lineElem);
        this.lineElem_ = lineElem;
        const markerElem = doc.createElement("div");
        markerElem.classList.add(className$3("m"));
        this.padElement.appendChild(markerElem);
        this.markerElem_ = markerElem;
        config.value.emitter.on("change", this.onValueChange_);
        this.value = config.value;
        this.update_();
      }
      get allFocusableElements() {
        return [this.padElement];
      }
      update_() {
        const [x2, y2] = this.value.rawValue.getComponents();
        const max2 = this.maxValue_;
        const px = mapRange(x2, -max2, +max2, 0, 100);
        const py = mapRange(y2, -max2, +max2, 0, 100);
        const ipy = this.invertsY_ ? 100 - py : py;
        this.lineElem_.setAttributeNS(null, "x2", `${px}%`);
        this.lineElem_.setAttributeNS(null, "y2", `${ipy}%`);
        this.markerElem_.style.left = `${px}%`;
        this.markerElem_.style.top = `${ipy}%`;
      }
      onValueChange_() {
        this.update_();
      }
      onFoldableChange_() {
        this.update_();
      }
    }
    function computeOffset(ev, baseSteps, invertsY) {
      return [
        getStepForKey(baseSteps[0], getHorizontalStepKeys(ev)),
        getStepForKey(baseSteps[1], getVerticalStepKeys(ev)) * (invertsY ? 1 : -1)
      ];
    }
    class Point2dPickerController {
      constructor(doc, config) {
        this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
        this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
        this.onPointerDown_ = this.onPointerDown_.bind(this);
        this.onPointerMove_ = this.onPointerMove_.bind(this);
        this.onPointerUp_ = this.onPointerUp_.bind(this);
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.baseSteps_ = config.baseSteps;
        this.maxValue_ = config.maxValue;
        this.invertsY_ = config.invertsY;
        this.view = new Point2dPickerView(doc, {
          invertsY: this.invertsY_,
          layout: config.layout,
          maxValue: this.maxValue_,
          value: this.value,
          viewProps: this.viewProps
        });
        this.ptHandler_ = new PointerHandler(this.view.padElement);
        this.ptHandler_.emitter.on("down", this.onPointerDown_);
        this.ptHandler_.emitter.on("move", this.onPointerMove_);
        this.ptHandler_.emitter.on("up", this.onPointerUp_);
        this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
        this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
      }
      handlePointerEvent_(d2, opts) {
        if (!d2.point) {
          return;
        }
        const max2 = this.maxValue_;
        const px = mapRange(d2.point.x, 0, d2.bounds.width, -max2, +max2);
        const py = mapRange(this.invertsY_ ? d2.bounds.height - d2.point.y : d2.point.y, 0, d2.bounds.height, -max2, +max2);
        this.value.setRawValue(new Point2d(px, py), opts);
      }
      onPointerDown_(ev) {
        this.handlePointerEvent_(ev.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerMove_(ev) {
        this.handlePointerEvent_(ev.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerUp_(ev) {
        this.handlePointerEvent_(ev.data, {
          forceEmit: true,
          last: true
        });
      }
      onPadKeyDown_(ev) {
        if (isArrowKey(ev.key)) {
          ev.preventDefault();
        }
        const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
        if (dx === 0 && dy === 0) {
          return;
        }
        this.value.setRawValue(new Point2d(this.value.rawValue.x + dx, this.value.rawValue.y + dy), {
          forceEmit: false,
          last: false
        });
      }
      onPadKeyUp_(ev) {
        const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
        if (dx === 0 && dy === 0) {
          return;
        }
        this.value.setRawValue(this.value.rawValue, {
          forceEmit: true,
          last: true
        });
      }
    }
    class Point2dController {
      constructor(doc, config) {
        var _a2, _b2;
        this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
        this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
        this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
        this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.foldable_ = Foldable.create(config.expanded);
        this.popC_ = config.pickerLayout === "popup" ? new PopupController(doc, {
          viewProps: this.viewProps
        }) : null;
        const padC = new Point2dPickerController(doc, {
          baseSteps: [config.axes[0].baseStep, config.axes[1].baseStep],
          invertsY: config.invertsY,
          layout: config.pickerLayout,
          maxValue: config.maxValue,
          value: this.value,
          viewProps: this.viewProps
        });
        padC.view.allFocusableElements.forEach((elem) => {
          elem.addEventListener("blur", this.onPopupChildBlur_);
          elem.addEventListener("keydown", this.onPopupChildKeydown_);
        });
        this.pickerC_ = padC;
        this.textC_ = new PointNdTextController(doc, {
          assembly: Point2dAssembly,
          axes: config.axes,
          parser: config.parser,
          value: this.value,
          viewProps: this.viewProps
        });
        this.view = new Point2dView(doc, {
          expanded: this.foldable_.value("expanded"),
          pickerLayout: config.pickerLayout,
          viewProps: this.viewProps
        });
        this.view.textElement.appendChild(this.textC_.view.element);
        (_a2 = this.view.buttonElement) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("blur", this.onPadButtonBlur_);
        (_b2 = this.view.buttonElement) === null || _b2 === void 0 ? void 0 : _b2.addEventListener("click", this.onPadButtonClick_);
        if (this.popC_) {
          this.view.element.appendChild(this.popC_.view.element);
          this.popC_.view.element.appendChild(this.pickerC_.view.element);
          connectValues({
            primary: this.foldable_.value("expanded"),
            secondary: this.popC_.shows,
            forward: (p2) => p2.rawValue,
            backward: (_, s2) => s2.rawValue
          });
        } else if (this.view.pickerElement) {
          this.view.pickerElement.appendChild(this.pickerC_.view.element);
          bindFoldable(this.foldable_, this.view.pickerElement);
        }
      }
      onPadButtonBlur_(e2) {
        if (!this.popC_) {
          return;
        }
        const elem = this.view.element;
        const nextTarget = forceCast(e2.relatedTarget);
        if (!nextTarget || !elem.contains(nextTarget)) {
          this.popC_.shows.rawValue = false;
        }
      }
      onPadButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded"));
        if (this.foldable_.get("expanded")) {
          this.pickerC_.view.allFocusableElements[0].focus();
        }
      }
      onPopupChildBlur_(ev) {
        if (!this.popC_) {
          return;
        }
        const elem = this.popC_.view.element;
        const nextTarget = findNextTarget(ev);
        if (nextTarget && elem.contains(nextTarget)) {
          return;
        }
        if (nextTarget && nextTarget === this.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
          return;
        }
        this.popC_.shows.rawValue = false;
      }
      onPopupChildKeydown_(ev) {
        if (this.popC_) {
          if (ev.key === "Escape") {
            this.popC_.shows.rawValue = false;
          }
        } else if (this.view.pickerElement) {
          if (ev.key === "Escape") {
            this.view.buttonElement.focus();
          }
        }
      }
    }
    class Point3d {
      constructor(x2 = 0, y2 = 0, z2 = 0) {
        this.x = x2;
        this.y = y2;
        this.z = z2;
      }
      getComponents() {
        return [this.x, this.y, this.z];
      }
      static isObject(obj) {
        if (isEmpty(obj)) {
          return false;
        }
        const x2 = obj.x;
        const y2 = obj.y;
        const z2 = obj.z;
        if (typeof x2 !== "number" || typeof y2 !== "number" || typeof z2 !== "number") {
          return false;
        }
        return true;
      }
      static equals(v1, v2) {
        return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
      }
      toObject() {
        return {
          x: this.x,
          y: this.y,
          z: this.z
        };
      }
    }
    const Point3dAssembly = {
      toComponents: (p2) => p2.getComponents(),
      fromComponents: (comps) => new Point3d(...comps)
    };
    function point3dFromUnknown(value) {
      return Point3d.isObject(value) ? new Point3d(value.x, value.y, value.z) : new Point3d();
    }
    function writePoint3d(target, value) {
      target.writeProperty("x", value.x);
      target.writeProperty("y", value.y);
      target.writeProperty("z", value.z);
    }
    function createConstraint$3(params, initialValue) {
      return new PointNdConstraint({
        assembly: Point3dAssembly,
        components: [
          createDimensionConstraint("x" in params ? params.x : void 0, initialValue.x),
          createDimensionConstraint("y" in params ? params.y : void 0, initialValue.y),
          createDimensionConstraint("z" in params ? params.z : void 0, initialValue.z)
        ]
      });
    }
    function createAxis$2(initialValue, constraint) {
      return {
        baseStep: getBaseStep(constraint),
        constraint,
        textProps: ValueMap.fromObject({
          draggingScale: getSuitableDraggingScale(constraint, initialValue),
          formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
        })
      };
    }
    const Point3dInputPlugin = {
      id: "input-point3d",
      type: "input",
      accept: (value, params) => {
        if (!Point3d.isObject(value)) {
          return null;
        }
        const p2 = ParamsParsers;
        const result = parseParams(params, {
          x: p2.optional.custom(parsePointDimensionParams),
          y: p2.optional.custom(parsePointDimensionParams),
          z: p2.optional.custom(parsePointDimensionParams)
        });
        return result ? {
          initialValue: value,
          params: result
        } : null;
      },
      binding: {
        reader: (_args) => point3dFromUnknown,
        constraint: (args) => createConstraint$3(args.params, args.initialValue),
        equals: Point3d.equals,
        writer: (_args) => writePoint3d
      },
      controller: (args) => {
        const value = args.value;
        const c = args.constraint;
        if (!(c instanceof PointNdConstraint)) {
          throw TpError.shouldNeverHappen();
        }
        return new PointNdTextController(args.document, {
          assembly: Point3dAssembly,
          axes: [
            createAxis$2(value.rawValue.x, c.components[0]),
            createAxis$2(value.rawValue.y, c.components[1]),
            createAxis$2(value.rawValue.z, c.components[2])
          ],
          parser: parseNumber,
          value,
          viewProps: args.viewProps
        });
      }
    };
    class Point4d {
      constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 0) {
        this.x = x2;
        this.y = y2;
        this.z = z2;
        this.w = w2;
      }
      getComponents() {
        return [this.x, this.y, this.z, this.w];
      }
      static isObject(obj) {
        if (isEmpty(obj)) {
          return false;
        }
        const x2 = obj.x;
        const y2 = obj.y;
        const z2 = obj.z;
        const w2 = obj.w;
        if (typeof x2 !== "number" || typeof y2 !== "number" || typeof z2 !== "number" || typeof w2 !== "number") {
          return false;
        }
        return true;
      }
      static equals(v1, v2) {
        return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;
      }
      toObject() {
        return {
          x: this.x,
          y: this.y,
          z: this.z,
          w: this.w
        };
      }
    }
    const Point4dAssembly = {
      toComponents: (p2) => p2.getComponents(),
      fromComponents: (comps) => new Point4d(...comps)
    };
    function point4dFromUnknown(value) {
      return Point4d.isObject(value) ? new Point4d(value.x, value.y, value.z, value.w) : new Point4d();
    }
    function writePoint4d(target, value) {
      target.writeProperty("x", value.x);
      target.writeProperty("y", value.y);
      target.writeProperty("z", value.z);
      target.writeProperty("w", value.w);
    }
    function createConstraint$2(params, initialValue) {
      return new PointNdConstraint({
        assembly: Point4dAssembly,
        components: [
          createDimensionConstraint("x" in params ? params.x : void 0, initialValue.x),
          createDimensionConstraint("y" in params ? params.y : void 0, initialValue.y),
          createDimensionConstraint("z" in params ? params.z : void 0, initialValue.z),
          createDimensionConstraint("w" in params ? params.w : void 0, initialValue.w)
        ]
      });
    }
    function createAxis$1(initialValue, constraint) {
      return {
        baseStep: getBaseStep(constraint),
        constraint,
        textProps: ValueMap.fromObject({
          draggingScale: getSuitableDraggingScale(constraint, initialValue),
          formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
        })
      };
    }
    const Point4dInputPlugin = {
      id: "input-point4d",
      type: "input",
      accept: (value, params) => {
        if (!Point4d.isObject(value)) {
          return null;
        }
        const p2 = ParamsParsers;
        const result = parseParams(params, {
          x: p2.optional.custom(parsePointDimensionParams),
          y: p2.optional.custom(parsePointDimensionParams),
          z: p2.optional.custom(parsePointDimensionParams),
          w: p2.optional.custom(parsePointDimensionParams)
        });
        return result ? {
          initialValue: value,
          params: result
        } : null;
      },
      binding: {
        reader: (_args) => point4dFromUnknown,
        constraint: (args) => createConstraint$2(args.params, args.initialValue),
        equals: Point4d.equals,
        writer: (_args) => writePoint4d
      },
      controller: (args) => {
        const value = args.value;
        const c = args.constraint;
        if (!(c instanceof PointNdConstraint)) {
          throw TpError.shouldNeverHappen();
        }
        return new PointNdTextController(args.document, {
          assembly: Point4dAssembly,
          axes: value.rawValue.getComponents().map((comp, index) => createAxis$1(comp, c.components[index])),
          parser: parseNumber,
          value,
          viewProps: args.viewProps
        });
      }
    };
    function createConstraint$1(params) {
      const constraints = [];
      const lc = createListConstraint(params.options);
      if (lc) {
        constraints.push(lc);
      }
      return new CompositeConstraint(constraints);
    }
    const StringInputPlugin = {
      id: "input-string",
      type: "input",
      accept: (value, params) => {
        if (typeof value !== "string") {
          return null;
        }
        const p2 = ParamsParsers;
        const result = parseParams(params, {
          options: p2.optional.custom(parseListOptions)
        });
        return result ? {
          initialValue: value,
          params: result
        } : null;
      },
      binding: {
        reader: (_args) => stringFromUnknown,
        constraint: (args) => createConstraint$1(args.params),
        writer: (_args) => writePrimitive
      },
      controller: (args) => {
        const doc = args.document;
        const value = args.value;
        const c = args.constraint;
        const lc = c && findConstraint(c, ListConstraint);
        if (lc) {
          return new ListController(doc, {
            props: new ValueMap({
              options: lc.values.value("options")
            }),
            value,
            viewProps: args.viewProps
          });
        }
        return new TextController(doc, {
          parser: (v2) => v2,
          props: ValueMap.fromObject({
            formatter: formatString
          }),
          value,
          viewProps: args.viewProps
        });
      }
    };
    const Constants = {
      monitor: {
        defaultInterval: 200,
        defaultLineCount: 3
      }
    };
    const className$2 = ClassName("mll");
    class MultiLogView {
      constructor(doc, config) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this);
        this.formatter_ = config.formatter;
        this.element = doc.createElement("div");
        this.element.classList.add(className$2());
        config.viewProps.bindClassModifiers(this.element);
        const textareaElem = doc.createElement("textarea");
        textareaElem.classList.add(className$2("i"));
        textareaElem.style.height = `calc(var(--bld-us) * ${config.lineCount})`;
        textareaElem.readOnly = true;
        config.viewProps.bindDisabled(textareaElem);
        this.element.appendChild(textareaElem);
        this.textareaElem_ = textareaElem;
        config.value.emitter.on("change", this.onValueUpdate_);
        this.value = config.value;
        this.update_();
      }
      update_() {
        const elem = this.textareaElem_;
        const shouldScroll = elem.scrollTop === elem.scrollHeight - elem.clientHeight;
        const lines = [];
        this.value.rawValue.forEach((value) => {
          if (value !== void 0) {
            lines.push(this.formatter_(value));
          }
        });
        elem.textContent = lines.join("\n");
        if (shouldScroll) {
          elem.scrollTop = elem.scrollHeight;
        }
      }
      onValueUpdate_() {
        this.update_();
      }
    }
    class MultiLogController {
      constructor(doc, config) {
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.view = new MultiLogView(doc, {
          formatter: config.formatter,
          lineCount: config.lineCount,
          value: this.value,
          viewProps: this.viewProps
        });
      }
    }
    const className$1 = ClassName("sgl");
    class SingleLogView {
      constructor(doc, config) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this);
        this.formatter_ = config.formatter;
        this.element = doc.createElement("div");
        this.element.classList.add(className$1());
        config.viewProps.bindClassModifiers(this.element);
        const inputElem = doc.createElement("input");
        inputElem.classList.add(className$1("i"));
        inputElem.readOnly = true;
        inputElem.type = "text";
        config.viewProps.bindDisabled(inputElem);
        this.element.appendChild(inputElem);
        this.inputElement = inputElem;
        config.value.emitter.on("change", this.onValueUpdate_);
        this.value = config.value;
        this.update_();
      }
      update_() {
        const values = this.value.rawValue;
        const lastValue = values[values.length - 1];
        this.inputElement.value = lastValue !== void 0 ? this.formatter_(lastValue) : "";
      }
      onValueUpdate_() {
        this.update_();
      }
    }
    class SingleLogController {
      constructor(doc, config) {
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.view = new SingleLogView(doc, {
          formatter: config.formatter,
          value: this.value,
          viewProps: this.viewProps
        });
      }
    }
    const BooleanMonitorPlugin = {
      id: "monitor-bool",
      type: "monitor",
      accept: (value, params) => {
        if (typeof value !== "boolean") {
          return null;
        }
        const p2 = ParamsParsers;
        const result = parseParams(params, {
          lineCount: p2.optional.number
        });
        return result ? {
          initialValue: value,
          params: result
        } : null;
      },
      binding: {
        reader: (_args) => boolFromUnknown
      },
      controller: (args) => {
        var _a2;
        if (args.value.rawValue.length === 1) {
          return new SingleLogController(args.document, {
            formatter: BooleanFormatter,
            value: args.value,
            viewProps: args.viewProps
          });
        }
        return new MultiLogController(args.document, {
          formatter: BooleanFormatter,
          lineCount: (_a2 = args.params.lineCount) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultLineCount,
          value: args.value,
          viewProps: args.viewProps
        });
      }
    };
    const className = ClassName("grl");
    class GraphLogView {
      constructor(doc, config) {
        this.onCursorChange_ = this.onCursorChange_.bind(this);
        this.onValueUpdate_ = this.onValueUpdate_.bind(this);
        this.element = doc.createElement("div");
        this.element.classList.add(className());
        config.viewProps.bindClassModifiers(this.element);
        this.formatter_ = config.formatter;
        this.props_ = config.props;
        this.cursor_ = config.cursor;
        this.cursor_.emitter.on("change", this.onCursorChange_);
        const svgElem = doc.createElementNS(SVG_NS, "svg");
        svgElem.classList.add(className("g"));
        svgElem.style.height = `calc(var(--bld-us) * ${config.lineCount})`;
        this.element.appendChild(svgElem);
        this.svgElem_ = svgElem;
        const lineElem = doc.createElementNS(SVG_NS, "polyline");
        this.svgElem_.appendChild(lineElem);
        this.lineElem_ = lineElem;
        const tooltipElem = doc.createElement("div");
        tooltipElem.classList.add(className("t"), ClassName("tt")());
        this.element.appendChild(tooltipElem);
        this.tooltipElem_ = tooltipElem;
        config.value.emitter.on("change", this.onValueUpdate_);
        this.value = config.value;
        this.update_();
      }
      get graphElement() {
        return this.svgElem_;
      }
      update_() {
        const bounds = this.svgElem_.getBoundingClientRect();
        const maxIndex = this.value.rawValue.length - 1;
        const min = this.props_.get("minValue");
        const max2 = this.props_.get("maxValue");
        const points = [];
        this.value.rawValue.forEach((v2, index) => {
          if (v2 === void 0) {
            return;
          }
          const x2 = mapRange(index, 0, maxIndex, 0, bounds.width);
          const y2 = mapRange(v2, min, max2, bounds.height, 0);
          points.push([x2, y2].join(","));
        });
        this.lineElem_.setAttributeNS(null, "points", points.join(" "));
        const tooltipElem = this.tooltipElem_;
        const value = this.value.rawValue[this.cursor_.rawValue];
        if (value === void 0) {
          tooltipElem.classList.remove(className("t", "a"));
          return;
        }
        const tx = mapRange(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
        const ty = mapRange(value, min, max2, bounds.height, 0);
        tooltipElem.style.left = `${tx}px`;
        tooltipElem.style.top = `${ty}px`;
        tooltipElem.textContent = `${this.formatter_(value)}`;
        if (!tooltipElem.classList.contains(className("t", "a"))) {
          tooltipElem.classList.add(className("t", "a"), className("t", "in"));
          forceReflow(tooltipElem);
          tooltipElem.classList.remove(className("t", "in"));
        }
      }
      onValueUpdate_() {
        this.update_();
      }
      onCursorChange_() {
        this.update_();
      }
    }
    class GraphLogController {
      constructor(doc, config) {
        this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
        this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
        this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
        this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
        this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
        this.props_ = config.props;
        this.value = config.value;
        this.viewProps = config.viewProps;
        this.cursor_ = createValue(-1);
        this.view = new GraphLogView(doc, {
          cursor: this.cursor_,
          formatter: config.formatter,
          lineCount: config.lineCount,
          props: this.props_,
          value: this.value,
          viewProps: this.viewProps
        });
        if (!supportsTouch(doc)) {
          this.view.element.addEventListener("mousemove", this.onGraphMouseMove_);
          this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
        } else {
          const ph = new PointerHandler(this.view.element);
          ph.emitter.on("down", this.onGraphPointerDown_);
          ph.emitter.on("move", this.onGraphPointerMove_);
          ph.emitter.on("up", this.onGraphPointerUp_);
        }
      }
      onGraphMouseLeave_() {
        this.cursor_.rawValue = -1;
      }
      onGraphMouseMove_(ev) {
        const bounds = this.view.element.getBoundingClientRect();
        this.cursor_.rawValue = Math.floor(mapRange(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length));
      }
      onGraphPointerDown_(ev) {
        this.onGraphPointerMove_(ev);
      }
      onGraphPointerMove_(ev) {
        if (!ev.data.point) {
          this.cursor_.rawValue = -1;
          return;
        }
        this.cursor_.rawValue = Math.floor(mapRange(ev.data.point.x, 0, ev.data.bounds.width, 0, this.value.rawValue.length));
      }
      onGraphPointerUp_() {
        this.cursor_.rawValue = -1;
      }
    }
    function createFormatter(params) {
      return "format" in params && !isEmpty(params.format) ? params.format : createNumberFormatter(2);
    }
    function createTextMonitor(args) {
      var _a2;
      if (args.value.rawValue.length === 1) {
        return new SingleLogController(args.document, {
          formatter: createFormatter(args.params),
          value: args.value,
          viewProps: args.viewProps
        });
      }
      return new MultiLogController(args.document, {
        formatter: createFormatter(args.params),
        lineCount: (_a2 = args.params.lineCount) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultLineCount,
        value: args.value,
        viewProps: args.viewProps
      });
    }
    function createGraphMonitor(args) {
      var _a2, _b2, _c2;
      return new GraphLogController(args.document, {
        formatter: createFormatter(args.params),
        lineCount: (_a2 = args.params.lineCount) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultLineCount,
        props: ValueMap.fromObject({
          maxValue: (_b2 = "max" in args.params ? args.params.max : null) !== null && _b2 !== void 0 ? _b2 : 100,
          minValue: (_c2 = "min" in args.params ? args.params.min : null) !== null && _c2 !== void 0 ? _c2 : 0
        }),
        value: args.value,
        viewProps: args.viewProps
      });
    }
    function shouldShowGraph(params) {
      return "view" in params && params.view === "graph";
    }
    const NumberMonitorPlugin = {
      id: "monitor-number",
      type: "monitor",
      accept: (value, params) => {
        if (typeof value !== "number") {
          return null;
        }
        const p2 = ParamsParsers;
        const result = parseParams(params, {
          format: p2.optional.function,
          lineCount: p2.optional.number,
          max: p2.optional.number,
          min: p2.optional.number,
          view: p2.optional.string
        });
        return result ? {
          initialValue: value,
          params: result
        } : null;
      },
      binding: {
        defaultBufferSize: (params) => shouldShowGraph(params) ? 64 : 1,
        reader: (_args) => numberFromUnknown
      },
      controller: (args) => {
        if (shouldShowGraph(args.params)) {
          return createGraphMonitor(args);
        }
        return createTextMonitor(args);
      }
    };
    const StringMonitorPlugin = {
      id: "monitor-string",
      type: "monitor",
      accept: (value, params) => {
        if (typeof value !== "string") {
          return null;
        }
        const p2 = ParamsParsers;
        const result = parseParams(params, {
          lineCount: p2.optional.number,
          multiline: p2.optional.boolean
        });
        return result ? {
          initialValue: value,
          params: result
        } : null;
      },
      binding: {
        reader: (_args) => stringFromUnknown
      },
      controller: (args) => {
        var _a2;
        const value = args.value;
        const multiline = value.rawValue.length > 1 || "multiline" in args.params && args.params.multiline;
        if (multiline) {
          return new MultiLogController(args.document, {
            formatter: formatString,
            lineCount: (_a2 = args.params.lineCount) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultLineCount,
            value,
            viewProps: args.viewProps
          });
        }
        return new SingleLogController(args.document, {
          formatter: formatString,
          value,
          viewProps: args.viewProps
        });
      }
    };
    function createInputBindingController(plugin, args) {
      var _a2;
      const result = plugin.accept(args.target.read(), args.params);
      if (isEmpty(result)) {
        return null;
      }
      const p2 = ParamsParsers;
      const valueArgs = {
        target: args.target,
        initialValue: result.initialValue,
        params: result.params
      };
      const reader = plugin.binding.reader(valueArgs);
      const constraint = plugin.binding.constraint ? plugin.binding.constraint(valueArgs) : void 0;
      const value = createValue(reader(result.initialValue), {
        constraint,
        equals: plugin.binding.equals
      });
      const binding = new InputBinding({
        reader,
        target: args.target,
        value,
        writer: plugin.binding.writer(valueArgs)
      });
      const disabled = p2.optional.boolean(args.params.disabled).value;
      const hidden = p2.optional.boolean(args.params.hidden).value;
      const controller = plugin.controller({
        constraint,
        document: args.document,
        initialValue: result.initialValue,
        params: result.params,
        value: binding.value,
        viewProps: ViewProps.create({
          disabled,
          hidden
        })
      });
      return new InputBindingController(args.document, {
        binding,
        blade: createBlade(),
        props: ValueMap.fromObject({
          label: "label" in args.params ? (_a2 = p2.optional.string(args.params.label).value) !== null && _a2 !== void 0 ? _a2 : null : args.target.key
        }),
        valueController: controller
      });
    }
    function createTicker(document2, interval) {
      return interval === 0 ? new ManualTicker() : new IntervalTicker(document2, interval !== null && interval !== void 0 ? interval : Constants.monitor.defaultInterval);
    }
    function createMonitorBindingController(plugin, args) {
      var _a2, _b2, _c2;
      const p2 = ParamsParsers;
      const result = plugin.accept(args.target.read(), args.params);
      if (isEmpty(result)) {
        return null;
      }
      const bindingArgs = {
        target: args.target,
        initialValue: result.initialValue,
        params: result.params
      };
      const reader = plugin.binding.reader(bindingArgs);
      const bufferSize = (_b2 = (_a2 = p2.optional.number(args.params.bufferSize).value) !== null && _a2 !== void 0 ? _a2 : plugin.binding.defaultBufferSize && plugin.binding.defaultBufferSize(result.params)) !== null && _b2 !== void 0 ? _b2 : 1;
      const interval = p2.optional.number(args.params.interval).value;
      const binding = new MonitorBinding({
        reader,
        target: args.target,
        ticker: createTicker(args.document, interval),
        value: initializeBuffer(bufferSize)
      });
      const disabled = p2.optional.boolean(args.params.disabled).value;
      const hidden = p2.optional.boolean(args.params.hidden).value;
      const controller = plugin.controller({
        document: args.document,
        params: result.params,
        value: binding.value,
        viewProps: ViewProps.create({
          disabled,
          hidden
        })
      });
      return new MonitorBindingController(args.document, {
        binding,
        blade: createBlade(),
        props: ValueMap.fromObject({
          label: "label" in args.params ? (_c2 = p2.optional.string(args.params.label).value) !== null && _c2 !== void 0 ? _c2 : null : args.target.key
        }),
        valueController: controller
      });
    }
    class PluginPool {
      constructor() {
        this.pluginsMap_ = {
          blades: [],
          inputs: [],
          monitors: []
        };
      }
      getAll() {
        return [
          ...this.pluginsMap_.blades,
          ...this.pluginsMap_.inputs,
          ...this.pluginsMap_.monitors
        ];
      }
      register(r2) {
        if (r2.type === "blade") {
          this.pluginsMap_.blades.unshift(r2);
        } else if (r2.type === "input") {
          this.pluginsMap_.inputs.unshift(r2);
        } else if (r2.type === "monitor") {
          this.pluginsMap_.monitors.unshift(r2);
        }
      }
      createInput(document2, target, params) {
        const initialValue = target.read();
        if (isEmpty(initialValue)) {
          throw new TpError({
            context: {
              key: target.key
            },
            type: "nomatchingcontroller"
          });
        }
        const bc = this.pluginsMap_.inputs.reduce((result, plugin) => result !== null && result !== void 0 ? result : createInputBindingController(plugin, {
          document: document2,
          target,
          params
        }), null);
        if (bc) {
          return bc;
        }
        throw new TpError({
          context: {
            key: target.key
          },
          type: "nomatchingcontroller"
        });
      }
      createMonitor(document2, target, params) {
        const bc = this.pluginsMap_.monitors.reduce((result, plugin) => result !== null && result !== void 0 ? result : createMonitorBindingController(plugin, {
          document: document2,
          params,
          target
        }), null);
        if (bc) {
          return bc;
        }
        throw new TpError({
          context: {
            key: target.key
          },
          type: "nomatchingcontroller"
        });
      }
      createBlade(document2, params) {
        const bc = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : createBladeController(plugin, {
          document: document2,
          params
        }), null);
        if (!bc) {
          throw new TpError({
            type: "nomatchingview",
            context: {
              params
            }
          });
        }
        return bc;
      }
      createBladeApi(bc) {
        if (bc instanceof InputBindingController) {
          return new InputBindingApi(bc);
        }
        if (bc instanceof MonitorBindingController) {
          return new MonitorBindingApi(bc);
        }
        if (bc instanceof RackController) {
          return new RackApi(bc, this);
        }
        const api = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : plugin.api({
          controller: bc,
          pool: this
        }), null);
        if (!api) {
          throw TpError.shouldNeverHappen();
        }
        return api;
      }
    }
    function createDefaultPluginPool() {
      const pool = new PluginPool();
      [
        Point2dInputPlugin,
        Point3dInputPlugin,
        Point4dInputPlugin,
        StringInputPlugin,
        NumberInputPlugin,
        StringColorInputPlugin,
        ObjectColorInputPlugin,
        NumberColorInputPlugin,
        BooleanInputPlugin,
        BooleanMonitorPlugin,
        StringMonitorPlugin,
        NumberMonitorPlugin,
        ButtonBladePlugin,
        FolderBladePlugin,
        SeparatorBladePlugin,
        TabBladePlugin
      ].forEach((p2) => {
        pool.register(p2);
      });
      return pool;
    }
    function point2dFromUnknown(value) {
      return Point2d.isObject(value) ? new Point2d(value.x, value.y) : new Point2d();
    }
    function writePoint2d(target, value) {
      target.writeProperty("x", value.x);
      target.writeProperty("y", value.y);
    }
    function createDimensionConstraint(params, initialValue) {
      if (!params) {
        return void 0;
      }
      const constraints = [];
      const cs = createStepConstraint(params, initialValue);
      if (cs) {
        constraints.push(cs);
      }
      const rs = createRangeConstraint(params);
      if (rs) {
        constraints.push(rs);
      }
      return new CompositeConstraint(constraints);
    }
    function createConstraint(params, initialValue) {
      return new PointNdConstraint({
        assembly: Point2dAssembly,
        components: [
          createDimensionConstraint("x" in params ? params.x : void 0, initialValue.x),
          createDimensionConstraint("y" in params ? params.y : void 0, initialValue.y)
        ]
      });
    }
    function getSuitableMaxDimensionValue(constraint, rawValue) {
      const [min, max2] = constraint ? findNumberRange(constraint) : [];
      if (!isEmpty(min) || !isEmpty(max2)) {
        return Math.max(Math.abs(min !== null && min !== void 0 ? min : 0), Math.abs(max2 !== null && max2 !== void 0 ? max2 : 0));
      }
      const step = getBaseStep(constraint);
      return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
    }
    function getSuitableMaxValue(initialValue, constraint) {
      const xc = constraint instanceof PointNdConstraint ? constraint.components[0] : void 0;
      const yc = constraint instanceof PointNdConstraint ? constraint.components[1] : void 0;
      const xr = getSuitableMaxDimensionValue(xc, initialValue.x);
      const yr = getSuitableMaxDimensionValue(yc, initialValue.y);
      return Math.max(xr, yr);
    }
    function createAxis(initialValue, constraint) {
      return {
        baseStep: getBaseStep(constraint),
        constraint,
        textProps: ValueMap.fromObject({
          draggingScale: getSuitableDraggingScale(constraint, initialValue),
          formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
        })
      };
    }
    function shouldInvertY(params) {
      if (!("y" in params)) {
        return false;
      }
      const yParams = params.y;
      if (!yParams) {
        return false;
      }
      return "inverted" in yParams ? !!yParams.inverted : false;
    }
    const Point2dInputPlugin = {
      id: "input-point2d",
      type: "input",
      accept: (value, params) => {
        if (!Point2d.isObject(value)) {
          return null;
        }
        const p2 = ParamsParsers;
        const result = parseParams(params, {
          expanded: p2.optional.boolean,
          picker: p2.optional.custom(parsePickerLayout),
          x: p2.optional.custom(parsePointDimensionParams),
          y: p2.optional.object({
            inverted: p2.optional.boolean,
            max: p2.optional.number,
            min: p2.optional.number,
            step: p2.optional.number
          })
        });
        return result ? {
          initialValue: value,
          params: result
        } : null;
      },
      binding: {
        reader: (_args) => point2dFromUnknown,
        constraint: (args) => createConstraint(args.params, args.initialValue),
        equals: Point2d.equals,
        writer: (_args) => writePoint2d
      },
      controller: (args) => {
        const doc = args.document;
        const value = args.value;
        const c = args.constraint;
        if (!(c instanceof PointNdConstraint)) {
          throw TpError.shouldNeverHappen();
        }
        const expanded = "expanded" in args.params ? args.params.expanded : void 0;
        const picker = "picker" in args.params ? args.params.picker : void 0;
        return new Point2dController(doc, {
          axes: [
            createAxis(value.rawValue.x, c.components[0]),
            createAxis(value.rawValue.y, c.components[1])
          ],
          expanded: expanded !== null && expanded !== void 0 ? expanded : false,
          invertsY: shouldInvertY(args.params),
          maxValue: getSuitableMaxValue(value.rawValue, c),
          parser: parseNumber,
          pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
          value,
          viewProps: args.viewProps
        });
      }
    };
    class ListApi extends BladeApi {
      constructor(controller) {
        super(controller);
        this.emitter_ = new Emitter2();
        this.controller_.valueController.value.emitter.on("change", (ev) => {
          this.emitter_.emit("change", {
            event: new TpChangeEvent(this, ev.rawValue)
          });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(label) {
        this.controller_.props.set("label", label);
      }
      get options() {
        return this.controller_.valueController.props.get("options");
      }
      set options(options) {
        this.controller_.valueController.props.set("options", options);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(value) {
        this.controller_.valueController.value.rawValue = value;
      }
      on(eventName, handler) {
        const bh = handler.bind(this);
        this.emitter_.on(eventName, (ev) => {
          bh(ev.event);
        });
        return this;
      }
    }
    class SliderApi extends BladeApi {
      constructor(controller) {
        super(controller);
        this.emitter_ = new Emitter2();
        this.controller_.valueController.value.emitter.on("change", (ev) => {
          this.emitter_.emit("change", {
            event: new TpChangeEvent(this, ev.rawValue)
          });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(label) {
        this.controller_.props.set("label", label);
      }
      get maxValue() {
        return this.controller_.valueController.sliderController.props.get("maxValue");
      }
      set maxValue(maxValue) {
        this.controller_.valueController.sliderController.props.set("maxValue", maxValue);
      }
      get minValue() {
        return this.controller_.valueController.sliderController.props.get("minValue");
      }
      set minValue(minValue) {
        this.controller_.valueController.sliderController.props.set("minValue", minValue);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(value) {
        this.controller_.valueController.value.rawValue = value;
      }
      on(eventName, handler) {
        const bh = handler.bind(this);
        this.emitter_.on(eventName, (ev) => {
          bh(ev.event);
        });
        return this;
      }
    }
    class TextApi extends BladeApi {
      constructor(controller) {
        super(controller);
        this.emitter_ = new Emitter2();
        this.controller_.valueController.value.emitter.on("change", (ev) => {
          this.emitter_.emit("change", {
            event: new TpChangeEvent(this, ev.rawValue)
          });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(label) {
        this.controller_.props.set("label", label);
      }
      get formatter() {
        return this.controller_.valueController.props.get("formatter");
      }
      set formatter(formatter) {
        this.controller_.valueController.props.set("formatter", formatter);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(value) {
        this.controller_.valueController.value.rawValue = value;
      }
      on(eventName, handler) {
        const bh = handler.bind(this);
        this.emitter_.on(eventName, (ev) => {
          bh(ev.event);
        });
        return this;
      }
    }
    const ListBladePlugin = function() {
      return {
        id: "list",
        type: "blade",
        accept(params) {
          const p2 = ParamsParsers;
          const result = parseParams(params, {
            options: p2.required.custom(parseListOptions),
            value: p2.required.raw,
            view: p2.required.constant("list"),
            label: p2.optional.string
          });
          return result ? { params: result } : null;
        },
        controller(args) {
          const lc = new ListConstraint(normalizeListOptions(args.params.options));
          const value = createValue(args.params.value, {
            constraint: lc
          });
          const ic = new ListController(args.document, {
            props: new ValueMap({
              options: lc.values.value("options")
            }),
            value,
            viewProps: args.viewProps
          });
          return new LabeledValueController(args.document, {
            blade: args.blade,
            props: ValueMap.fromObject({
              label: args.params.label
            }),
            valueController: ic
          });
        },
        api(args) {
          if (!(args.controller instanceof LabeledValueController)) {
            return null;
          }
          if (!(args.controller.valueController instanceof ListController)) {
            return null;
          }
          return new ListApi(args.controller);
        }
      };
    }();
    function exportPresetJson(targets) {
      return targets.reduce((result, target) => {
        return Object.assign(result, {
          [target.presetKey]: target.read()
        });
      }, {});
    }
    function importPresetJson(bindings, preset) {
      bindings.forEach((binding) => {
        const value = preset[binding.target.presetKey];
        if (value !== void 0) {
          binding.writer(binding.target, binding.reader(value));
        }
      });
    }
    class RootApi extends FolderApi {
      constructor(controller, pool) {
        super(controller, pool);
      }
      get element() {
        return this.controller_.view.element;
      }
      importPreset(preset) {
        const bindings = this.controller_.rackController.rack.find(InputBindingController).map((ibc) => {
          return ibc.binding;
        });
        importPresetJson(bindings, preset);
        this.refresh();
      }
      exportPreset() {
        const targets = this.controller_.rackController.rack.find(InputBindingController).map((ibc) => {
          return ibc.binding.target;
        });
        return exportPresetJson(targets);
      }
      refresh() {
        this.controller_.rackController.rack.find(InputBindingController).forEach((ibc) => {
          ibc.binding.read();
        });
        this.controller_.rackController.rack.find(MonitorBindingController).forEach((mbc) => {
          mbc.binding.read();
        });
      }
    }
    class RootController extends FolderController {
      constructor(doc, config) {
        super(doc, {
          expanded: config.expanded,
          blade: config.blade,
          props: config.props,
          root: true,
          viewProps: config.viewProps
        });
      }
    }
    const SliderBladePlugin = {
      id: "slider",
      type: "blade",
      accept(params) {
        const p2 = ParamsParsers;
        const result = parseParams(params, {
          max: p2.required.number,
          min: p2.required.number,
          view: p2.required.constant("slider"),
          format: p2.optional.function,
          label: p2.optional.string,
          value: p2.optional.number
        });
        return result ? { params: result } : null;
      },
      controller(args) {
        var _a2, _b2;
        const initialValue = (_a2 = args.params.value) !== null && _a2 !== void 0 ? _a2 : 0;
        const drc = new DefiniteRangeConstraint({
          max: args.params.max,
          min: args.params.min
        });
        const vc = new SliderTextController(args.document, {
          baseStep: 1,
          parser: parseNumber,
          sliderProps: new ValueMap({
            maxValue: drc.values.value("max"),
            minValue: drc.values.value("min")
          }),
          textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(void 0, initialValue),
            formatter: (_b2 = args.params.format) !== null && _b2 !== void 0 ? _b2 : numberToString
          }),
          value: createValue(initialValue, {
            constraint: drc
          }),
          viewProps: args.viewProps
        });
        return new LabeledValueController(args.document, {
          blade: args.blade,
          props: ValueMap.fromObject({
            label: args.params.label
          }),
          valueController: vc
        });
      },
      api(args) {
        if (!(args.controller instanceof LabeledValueController)) {
          return null;
        }
        if (!(args.controller.valueController instanceof SliderTextController)) {
          return null;
        }
        return new SliderApi(args.controller);
      }
    };
    const TextBladePlugin = function() {
      return {
        id: "text",
        type: "blade",
        accept(params) {
          const p2 = ParamsParsers;
          const result = parseParams(params, {
            parse: p2.required.function,
            value: p2.required.raw,
            view: p2.required.constant("text"),
            format: p2.optional.function,
            label: p2.optional.string
          });
          return result ? { params: result } : null;
        },
        controller(args) {
          var _a2;
          const ic = new TextController(args.document, {
            parser: args.params.parse,
            props: ValueMap.fromObject({
              formatter: (_a2 = args.params.format) !== null && _a2 !== void 0 ? _a2 : (v2) => String(v2)
            }),
            value: createValue(args.params.value),
            viewProps: args.viewProps
          });
          return new LabeledValueController(args.document, {
            blade: args.blade,
            props: ValueMap.fromObject({
              label: args.params.label
            }),
            valueController: ic
          });
        },
        api(args) {
          if (!(args.controller instanceof LabeledValueController)) {
            return null;
          }
          if (!(args.controller.valueController instanceof TextController)) {
            return null;
          }
          return new TextApi(args.controller);
        }
      };
    }();
    function createDefaultWrapperElement(doc) {
      const elem = doc.createElement("div");
      elem.classList.add(ClassName("dfw")());
      if (doc.body) {
        doc.body.appendChild(elem);
      }
      return elem;
    }
    function embedStyle(doc, id, css) {
      if (doc.querySelector(`style[data-tp-style=${id}]`)) {
        return;
      }
      const styleElem = doc.createElement("style");
      styleElem.dataset.tpStyle = id;
      styleElem.textContent = css;
      doc.head.appendChild(styleElem);
    }
    class Pane extends RootApi {
      constructor(opt_config) {
        var _a2, _b2;
        const config = opt_config !== null && opt_config !== void 0 ? opt_config : {};
        const doc = (_a2 = config.document) !== null && _a2 !== void 0 ? _a2 : getWindowDocument();
        const pool = createDefaultPluginPool();
        const rootController = new RootController(doc, {
          expanded: config.expanded,
          blade: createBlade(),
          props: ValueMap.fromObject({
            title: config.title
          }),
          viewProps: ViewProps.create()
        });
        super(rootController, pool);
        this.pool_ = pool;
        this.containerElem_ = (_b2 = config.container) !== null && _b2 !== void 0 ? _b2 : createDefaultWrapperElement(doc);
        this.containerElem_.appendChild(this.element);
        this.doc_ = doc;
        this.usesDefaultWrapper_ = !config.container;
        this.setUpDefaultPlugins_();
      }
      get document() {
        if (!this.doc_) {
          throw TpError.alreadyDisposed();
        }
        return this.doc_;
      }
      dispose() {
        const containerElem = this.containerElem_;
        if (!containerElem) {
          throw TpError.alreadyDisposed();
        }
        if (this.usesDefaultWrapper_) {
          const parentElem = containerElem.parentElement;
          if (parentElem) {
            parentElem.removeChild(containerElem);
          }
        }
        this.containerElem_ = null;
        this.doc_ = null;
        super.dispose();
      }
      registerPlugin(bundle) {
        const plugins = "plugin" in bundle ? [bundle.plugin] : "plugins" in bundle ? bundle.plugins : [];
        plugins.forEach((p2) => {
          this.pool_.register(p2);
          this.embedPluginStyle_(p2);
        });
      }
      embedPluginStyle_(plugin) {
        if (plugin.css) {
          embedStyle(this.document, `plugin-${plugin.id}`, plugin.css);
        }
      }
      setUpDefaultPlugins_() {
        embedStyle(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{padding-bottom:var(--cnt-v-p);padding-left:4px;padding-top:var(--cnt-v-p)}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}');
        this.pool_.getAll().forEach((plugin) => {
          this.embedPluginStyle_(plugin);
        });
        this.registerPlugin({
          plugins: [
            SliderBladePlugin,
            ListBladePlugin,
            TabBladePlugin,
            TextBladePlugin
          ]
        });
      }
    }
    const VERSION2 = new Semver("3.1.10");
    exports2.BladeApi = BladeApi;
    exports2.ButtonApi = ButtonApi;
    exports2.FolderApi = FolderApi;
    exports2.InputBindingApi = InputBindingApi;
    exports2.ListApi = ListApi;
    exports2.MonitorBindingApi = MonitorBindingApi;
    exports2.Pane = Pane;
    exports2.SeparatorApi = SeparatorApi;
    exports2.SliderApi = SliderApi;
    exports2.TabApi = TabApi;
    exports2.TabPageApi = TabPageApi;
    exports2.TextApi = TextApi;
    exports2.TpChangeEvent = TpChangeEvent;
    exports2.VERSION = VERSION2;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
})(tweakpane, tweakpane.exports);
urlparser.queryString = querystringparser;
let currentConfig;
const getQuery = (index) => {
  const url2 = window.location.href;
  const qs = url2.substring(url2.indexOf("?") + 1).split("&");
  const result = {};
  for (let i = 0; i < qs.length; i++) {
    qs[i] = qs[i].split("=");
    result[qs[i][0]] = decodeURIComponent(qs[i][1]);
  }
  return result.hasOwnProperty(index) ? result[index] : false;
};
const share = (obj) => {
  window.history.pushState(
    "Kindeo Title Slide",
    "Title",
    window.location.origin + window.location.pathname + "?config=" + encodeURIComponent(JSON.stringify(obj))
  );
};
const init = (exportFn) => {
  if (getQuery("config")) {
    currentConfig = JSON.parse(getQuery("config"));
  }
  const pane = new tweakpane.exports.Pane();
  const obj = {
    customConfig: ""
  };
  pane.addInput(obj, "customConfig").on("change", () => {
    let conf = obj.customConfig.replace(/\s/g, "");
    conf = conf.replaceAll(",}", "}");
    conf = conf.replaceAll(",]", "]");
    conf = conf.replaceAll(/\w+(?=:)/g, '"$&"');
    if (conf[conf.length - 1] === ",") {
      conf = conf.slice(0, -1);
    }
    currentConfig = JSON.parse(conf);
    share(currentConfig);
    window.location.reload();
  });
  const btnShare = pane.addButton({
    title: "Share"
  });
  btnShare.on("click", () => {
    const obj2 = exportFn();
    console.log(JSON.stringify(obj2));
    share(obj2);
  });
  return { pane, currentConfig };
};
const furryAssetsMap = {
  furry1: "/assets/images/furry-ball.png",
  furry2: "/assets/images/fuzz_piece_04.png"
};
const asset = getQuery("asset");
class RenderShader {
  constructor() {
    this.tick = 0;
    this.mouseX = -2e3;
    this.mouseY = -2e3;
    this.extraCharacters = [];
    this.material = Shader.from(vert$3, frag$3, {
      uMap: Texture.from(furryAssetsMap[asset] || furryAssetsMap.furry2),
      texturePositions: Texture.WHITE,
      uSize: 0,
      uPointSize: particleSize,
      uTime: 0,
      uAngle: 0.5
    });
    this.geometry = new Geometry();
    this.mesh = new Mesh(this.geometry, this.material);
    this.view = new Container();
    this.view.addChild(this.mesh);
    this.extraCharactersContainer = new Container();
    this.view.addChildAt(this.extraCharactersContainer, 0);
    const verts = [];
    const indices3 = [];
    const uvs = [];
    verts.push(
      0.5 + 0.5,
      -0.5 + 0.5,
      0.5 + 0.5,
      0.5 + 0.5,
      -0.5 + 0.5,
      0.5 + 0.5,
      -0.5 + 0.5,
      -0.5 + 0.5
    );
    uvs.push(1, 0, 1, 1, 0, 1, 0, 0);
    indices3.push(3, 2, 1, 3, 1, 0);
    this.geometry.instanced = true;
    this.geometry.addAttribute("aVertexPosition", verts, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", uvs, 2).addAttribute(
      "aPosOffset",
      [0, 0, 0, 0],
      4,
      false,
      TYPES.FLOAT,
      0,
      0,
      true
    ).addAttribute(
      "aTextureCoordPosition",
      [0, 0],
      2,
      false,
      TYPES.FLOAT,
      0,
      0,
      true
    ).addAttribute("aExtra", [0, 0, 0], 3, false, TYPES.FLOAT, 0, 0, true).addAttribute("aScale", [0], 1, false, TYPES.FLOAT, 0, 0, true).addIndex(new Uint16Array(indices3));
  }
  draw(pointsLength, cols, rows, scalesData) {
    this.extraCharacters.length = 0;
    this.extraCharactersContainer.removeChildren();
    this.material.uniforms.uSize = cols;
    const scales = [];
    const extra = [];
    const coords = [];
    let count = 0;
    for (let j2 = 0; j2 < rows; j2++) {
      for (let i = 0; i < cols; i++) {
        if (count >= pointsLength)
          break;
        scales.push(scalesData[count]);
        coords.push(count * 2, count * 2 + 1);
        extra.push(count, 0, 0);
        count++;
      }
    }
    this.geometry.instanceCount = pointsLength - 1;
    this.geometry.getBuffer("aTextureCoordPosition").update(new Float32Array(coords));
    this.geometry.getBuffer("aExtra").update(new Float32Array(extra));
    this.geometry.getBuffer("aScale").update(new Float32Array(scales));
  }
  addExtraChar(char) {
    this.extraCharacters.push(char);
    char.originX = char.x;
    char.originY = char.y;
    char.lastX = char.x;
    char.lastY = char.y;
    this.extraCharactersContainer.addChild(char);
  }
  setScale(value) {
    this.view.scale.set(value);
    this.material.uniforms.uPointSize = particleSize * Math.max(0.75, value);
  }
  setPosition(x2, y2) {
    this.view.position.x = x2;
    this.view.position.y = y2;
  }
  set mouse({ x: x2, y: y2 }) {
    this.mouseX = x2;
    this.mouseY = y2;
  }
  update() {
    this.tick++;
    this.material.uniforms.uTime = this.tick;
    const repulsionRadius = 70;
    const repulsionForce = 1;
    for (let i = 0; i < this.extraCharacters.length; i++) {
      const char = this.extraCharacters[i];
      const distance = Math.sqrt(
        (this.mouseX - char.position.x) ** 2 + (this.mouseY - char.position.y) ** 2
      );
      if (distance < repulsionRadius + char.width / 4) {
        const dx = char.position.x - this.mouseX;
        const dy = char.position.y - this.mouseY;
        const magnitude = Math.sqrt(dx ** 2 + dy ** 2);
        if (magnitude !== 0) {
          char.position.x += repulsionForce * (dx / magnitude);
          char.position.y += repulsionForce * (dy / magnitude);
        }
      } else {
        char.position.x += (char.originX - char.position.x) * 0.01;
        char.position.y += (char.originY - char.position.y) * 0.01;
      }
      let velX = char.position.x - char.lastX;
      let velY = char.position.y - char.lastY;
      const damping = 0.9;
      velX *= damping;
      velY *= damping;
      char.lastX = char.position.x;
      char.lastY = char.position.y;
      char.position.x += velX;
      char.position.y += velY;
    }
  }
}
var frag$2 = `

// precision mediump float;
varying vec2 vTextureCoord;
varying float vCount;
varying float vScale;

uniform sampler2D textureOriginalPositions;
uniform sampler2D texturePositions;
uniform float uDistance;
uniform float scale;
uniform float fixedPosition;
uniform vec2 uMouse;
uniform float uSize;

${encode_decode}

// convert index to a vec2
// to compensate for floating point inaccuracy
vec2 getBaseTextureCoordinates (float index) {
    return (
        vec2(floor(mod(index + 0.5, uSize)), 
        floor((index + 0.5) / uSize)
    ) + 0.5) / uSize;
}

void main () {
    vec2 uvX = getBaseTextureCoordinates(vTextureCoord.x);
    vec2 uvY = getBaseTextureCoordinates(vTextureCoord.y);
    
    vec4 originalPositionEncodedX = texture2D(textureOriginalPositions, uvX);
    vec4 originalPositionEncodedY = texture2D(textureOriginalPositions, uvY);
    
    vec4 positionEncodedX = texture2D(texturePositions, uvX);
    vec4 positionEncodedY = texture2D(texturePositions, uvY);

    float positionX = decode_float(positionEncodedX);
    float positionY = decode_float(positionEncodedY);
    vec2 position = vec2(positionX, positionY);

    float originalPositionX = decode_float(originalPositionEncodedX);
    float originalPositionY = decode_float(originalPositionEncodedY);
    vec2 originalPosition = vec2(originalPositionX, originalPositionY);


    float dist = distance(uMouse.xy, position.xy);

    float sc = scale * vScale;
    float repulsionStrength = .1 * sc;
    float repulsionRadius = 70. * sc;

    float dist2 = distance(originalPosition.xy, position.xy);
    // simple repulsion IF it's in the cursors radius
    if( dist < repulsionRadius) {
        float displacement = repulsionStrength * (repulsionRadius - dist);
        position.xy += normalize(position.xy - uMouse) * displacement;
    } else if (dist2 > .01) {
        position.xy += (originalPosition.xy - position.xy) * 0.01;
    };

    float floatToEncode = position.y;
    if (mod(vCount, 2.) == 0.) {
        floatToEncode = position.x;
    }
 
    vec4 encoded = encode_float(floatToEncode, true);


    gl_FragColor = encoded; // Store the encoded values
}
`;
var vert$2 = `
// precision mediump float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute float aScale;
attribute float aCount;


uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
varying vec2 vTextureCoord;
varying float vCount;
varying float vScale;

void main(void)
{
  vCount = aCount;
  vScale = aScale;
  vTextureCoord = aTextureCoord;
  gl_Position=vec4(aVertexPosition, 0., 1.);

  gl_PointSize = 1.;
}
`;
class RepulsionShader {
  constructor() {
    this.material = Shader.from(vert$2, frag$2, {
      textureOriginalPositions: Texture.WHITE,
      texturePositions: Texture.WHITE,
      uMouse: [-1e3, -1e3],
      scale: 1
    });
    this.geometry = new Geometry();
    this.mesh = new Mesh(
      this.geometry,
      this.material,
      void 0,
      DRAW_MODES.POINTS
    );
    this.geometry.addAttribute("aVertexPosition", [0, 0], 2).addAttribute("aTextureCoord", [0, 0], 2).addAttribute("aCount", [0], 1).addAttribute("aScale", [0], 1).addIndex([0]);
  }
  draw(cols, rows, totalParticles, scalesData) {
    this.material.uniforms.uSize = cols;
    const coordsIndex = [];
    const positions = [];
    const indices3 = [];
    const counts = [];
    const scales = [];
    let count = 0;
    let countUV = 0;
    let ux2, uy2;
    for (let j2 = 0; j2 < rows; j2++) {
      for (let i = 0; i < cols; i++) {
        coordsIndex.push(countUV * 2, countUV * 2 + 1);
        scales.push(scalesData[countUV] || 1);
        ux2 = i / cols * 2 - 1 + 0.5 / cols;
        uy2 = j2 / rows * 2 - 1 + 0.5 / rows;
        positions.push(ux2, uy2);
        indices3.push(count);
        counts.push(count);
        count++;
        if (count % 2 === 0) {
          countUV++;
        }
      }
    }
    this.geometry.getBuffer("aVertexPosition").update(new Float32Array(positions));
    this.geometry.getBuffer("aTextureCoord").update(new Float32Array(coordsIndex));
    this.geometry.getBuffer("aCount").update(new Float32Array(counts));
    this.geometry.getBuffer("aScale").update(new Float32Array(scales));
    this.geometry.getIndex().update(new Uint16Array(indices3));
  }
  set mouse({ x: x2, y: y2 }) {
    this.material.uniforms.uMouse = [x2, y2];
  }
}
var frag$1 = `

// precision mediump float;
varying vec2 vTextureCoord;
varying float vCount;

uniform sampler2D textureCurrentPosition;
uniform sampler2D texturePrevPosition;
uniform float uSize;

${encode_decode}


vec2 getBaseTextureCoordinates (float index) {
    return (
        vec2(floor(mod(index + 0.5, uSize)), 
        floor((index + 0.5) / uSize)
    ) + 0.5) / uSize;
}

void main () {
    vec2 uvX = getBaseTextureCoordinates(vTextureCoord.x);
    vec2 uvY = getBaseTextureCoordinates(vTextureCoord.y);
    
    vec4 prevPositionEncodedX = texture2D(texturePrevPosition, uvX);
    vec4 prevPositionEncodedY = texture2D(texturePrevPosition, uvY);
    
    vec4 positionEncodedX = texture2D(textureCurrentPosition, uvX);
    vec4 positionEncodedY = texture2D(textureCurrentPosition, uvY);

    float positionX = decode_float(positionEncodedX);
    float positionY = decode_float(positionEncodedY);
    
    
    float prevPositionX = decode_float(prevPositionEncodedX);
    float prevPositionY = decode_float(prevPositionEncodedY);
    
    
    vec2 position = vec2(positionX, positionY);
    vec2 prevPosition = vec2(prevPositionX, prevPositionY);


    vec2 vel = position - prevPosition;
    
    float damping = 0.9;
    vel *= damping;    
    position += vel;

    float floatToEncode = position.y;
    if (mod(vCount, 2.) == 0.) {
        floatToEncode = position.x;
    }

    floatToEncode = floor(floatToEncode * 100.) / 100. + 0.001;

    vec4 encoded = encode_float(floatToEncode, true);

    gl_FragColor = encoded; // Store the encoded values
}
`;
var vert$1 = `
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute float aCount;


uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
varying vec2 vTextureCoord;
varying float vCount;

void main(void)
{
  vCount = aCount;
  vTextureCoord = aTextureCoord;
  gl_Position=vec4(aVertexPosition, 0., 1.);

  gl_PointSize = 1.;
}
`;
class SimulationShader {
  constructor() {
    this.material = Shader.from(vert$1, frag$1, {
      textureCurrentPosition: Texture.WHITE,
      texturePrevPosition: Texture.WHITE,
      uSize: 0
    });
    this.geometry = new Geometry();
    this.mesh = new Mesh(
      this.geometry,
      this.material,
      void 0,
      DRAW_MODES.POINTS
    );
    this.geometry.addAttribute("aVertexPosition", [0, 0], 2).addAttribute("aTextureCoord", [0, 0], 2).addAttribute("aCount", [0], 1).addIndex([0]);
  }
  draw(cols, rows, totalParticles) {
    this.material.uniforms.uSize = cols;
    const coordsIndex = [];
    const positions = [];
    const indices3 = [];
    const counts = [];
    let count = 0;
    let countUV = 0;
    let ux2, uy2;
    for (let j2 = 0; j2 < rows; j2++) {
      for (let i = 0; i < cols; i++) {
        coordsIndex.push(countUV * 2, countUV * 2 + 1);
        ux2 = i / cols * 2 - 1 + 0.5 / cols;
        uy2 = j2 / rows * 2 - 1 + 0.5 / rows;
        positions.push(ux2, uy2);
        indices3.push(count);
        counts.push(count);
        count++;
        if (count % 2 === 0) {
          countUV++;
        }
      }
    }
    this.geometry.getBuffer("aVertexPosition").update(new Float32Array(positions));
    this.geometry.getBuffer("aTextureCoord").update(new Float32Array(coordsIndex));
    this.geometry.getBuffer("aCount").update(new Float32Array(counts));
    this.geometry.getIndex().update(new Uint16Array(indices3));
  }
  set mouse({ x: x2, y: y2 }) {
    this.material.uniforms.uMouse = [x2, y2];
  }
}
var frag = `

// precision mediump float;
varying vec2 vDistance;
varying vec2 vTextureCoord;
varying float vCount;
varying float vScale;
varying vec4 vNeighbours;

uniform sampler2D texturePosition;
uniform float uSize;

${encode_decode}

vec2 getDelta (vec2 center, vec2 other, float restLength, float stiffness) {
    restLength *= 1.0;

    float dist = distance(center, other);

    vec2 delta = stiffness * (dist - restLength) * (other - center) / dist;

    return delta;
}


vec2 getBaseTextureCoordinates (float index) {
    return (
        vec2(floor(mod(index + 0.5, uSize)), 
        floor((index + 0.5) / uSize)
    ) + 0.5) / uSize;
}

void main () {
    vec2 uvX = getBaseTextureCoordinates(vTextureCoord.x);
    vec2 uvY = getBaseTextureCoordinates(vTextureCoord.y);
    
    vec4 positionEncodedX = texture2D(texturePosition, uvX);
    vec4 positionEncodedY = texture2D(texturePosition, uvY);

    float positionX = decode_float(positionEncodedX);
    float positionY = decode_float(positionEncodedY);
    
    vec2 position = vec2(positionX, positionY);


    vec4 neighbourAXEncoded = texture2D(texturePosition, getBaseTextureCoordinates(vNeighbours.x));
    vec4 neighbourAYEncoded = texture2D(texturePosition, getBaseTextureCoordinates(vNeighbours.y));

    float neighbourAX = decode_float(neighbourAXEncoded);
    float neighbourAY = decode_float(neighbourAYEncoded);

    vec4 neighbourBXEncoded = texture2D(texturePosition, getBaseTextureCoordinates(vNeighbours.z));
    vec4 neighbourBYEncoded = texture2D(texturePosition, getBaseTextureCoordinates(vNeighbours.w));

    float neighbourBX = decode_float(neighbourBXEncoded);
    float neighbourBY = decode_float(neighbourBYEncoded);

    vec2 neighbourA = vec2(neighbourAX, neighbourAY);
    vec2 neighbourB = vec2(neighbourBX, neighbourBY);
    

    float stiffness = 30. * pow(max(1., vScale), 2.);
    float restLengthA = vDistance.x;
    float restLengthB = vDistance.y;
    vec2 offset = vec2(0.0);

    float c = 0.;
    if (vNeighbours.x > -0.5 && vNeighbours.y > -.5 && restLengthA > 0.) {
        offset += getDelta(position.xy, neighbourA, restLengthA, stiffness);
        c += 1.;
    }
    if (vNeighbours.z > -.5 && vNeighbours.w > -.5 && restLengthB > 0.) {
        offset += getDelta(position.xy, neighbourB, restLengthB, stiffness);
        c += 1.;
    }

    if (c > 0.) {
        position.xy = position.xy + offset / c * .01;
    }

    float floatToEncode = position.y;
    if (mod(vCount, 2.) == 0.) {
        floatToEncode = position.x;
    }

    vec4 encoded = encode_float(floatToEncode, true);

    gl_FragColor = encoded;
}
`;
var vert = `
attribute vec2 aDistance;
attribute vec2 aVertexPosition;
attribute vec4 aNeighbours;
attribute vec2 aTextureCoord;
attribute float aCount;
attribute float aScale;


uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
varying vec2 vTextureCoord;
varying vec4 vNeighbours;
varying float vCount;
varying float vScale;
varying vec2 vDistance;

void main(void)
{
  vCount = aCount;
  vScale = aScale;
  vDistance = aDistance;
  vTextureCoord = aTextureCoord;
  vNeighbours = aNeighbours;
  gl_Position=vec4(aVertexPosition, 0., 1.);

  gl_PointSize = 1.;
}
`;
class ConstraintsShader {
  constructor() {
    this.material = Shader.from(vert, frag, {
      texturePosition: Texture.WHITE,
      uSize: 0
    });
    this.geometry = new Geometry();
    this.mesh = new Mesh(
      this.geometry,
      this.material,
      void 0,
      DRAW_MODES.POINTS
    );
    this.geometry.addAttribute("aVertexPosition", [0, 0], 2).addAttribute("aNeighbours", [0, 0, 0, 0], 4).addAttribute("aTextureCoord", [0, 0], 2).addAttribute("aCount", [0], 1).addAttribute("aScale", [0], 1).addAttribute("aDistance", [0, 0], 2).addIndex(new Uint16Array([0]));
  }
  draw(neighboursData, distancesData, scalesData, cols, rows) {
    this.material.uniforms.uSize = cols;
    const coordsIndex = [];
    const positions = [];
    const neighbours = [];
    const distances = [];
    const indices3 = [];
    const counts = [];
    const scales = [];
    let count = 0;
    let countUV = 0;
    let ux2, uy2;
    for (let j2 = 0; j2 < rows; j2++) {
      for (let i = 0; i < cols; i++) {
        const [neighbourA, neighbourAY, neighbourBX, neighbourBY] = neighboursData[countUV] || [-1, -1, -1, -1];
        neighbours.push(neighbourA, neighbourAY, neighbourBX, neighbourBY);
        if (distancesData[countUV]) {
          const [distanceA, distanceB] = distancesData[countUV];
          distances.push(distanceA / 1, distanceB / 1);
        } else {
          distances.push(0, 0);
        }
        scales.push(scalesData[countUV] || 1);
        coordsIndex.push(countUV * 2, countUV * 2 + 1);
        ux2 = i / cols * 2 - 1 + 0.5 / cols;
        uy2 = j2 / rows * 2 - 1 + 0.5 / rows;
        positions.push(ux2, uy2);
        indices3.push(count);
        counts.push(count);
        count++;
        if (count % 2 === 0) {
          countUV++;
        }
      }
    }
    this.geometry.getBuffer("aVertexPosition").update(new Float32Array(positions));
    this.geometry.getBuffer("aNeighbours").update(new Float32Array(neighbours));
    this.geometry.getBuffer("aTextureCoord").update(new Float32Array(coordsIndex));
    this.geometry.getBuffer("aCount").update(new Float32Array(counts));
    this.geometry.getBuffer("aScale").update(new Float32Array(scales));
    this.geometry.getBuffer("aDistance").update(new Float32Array(distances));
    this.geometry.getIndex().update(new Uint16Array(indices3));
  }
}
function calculateTextureDimensions(arrayLength) {
  let squareRoot = Math.sqrt(arrayLength);
  let sideLength = Math.ceil(squareRoot);
  let rows, columns;
  if (sideLength * sideLength >= arrayLength) {
    rows = columns = sideLength;
  } else {
    rows = sideLength;
    columns = Math.ceil(arrayLength / sideLength);
  }
  return [rows, columns];
}
const debugMode = !!getQuery("debug");
(function machineIsLittleEndian() {
  const uint8Array = new Uint8Array([170, 187]);
  const uint16array = new Uint16Array(uint8Array.buffer);
  return uint16array[0] === 48042;
})();
class Scene extends AbstractScene {
  constructor() {
    super();
    const { pane: originalPane } = init(this.export.bind(this));
    this.positionsShader = new PositionShader();
    this.repulsionShader = new RepulsionShader();
    this.simulationShader = new SimulationShader();
    this.constraintsShader = new ConstraintsShader();
    this.renderShader = new RenderShader();
    this.view.addChild(this.renderShader.view);
    this.renderTextures = {};
    this.fboContainer = new Container();
    this.view.addChild(this.fboContainer);
    this.textContent = "Have a good day\u2600\uFE0F";
    originalPane.addInput(this, "textContent").on("change", this.resetText.bind(this));
    this.furryText = new FurryText();
    this.mouse = { x: -2e3, y: -2e3 };
    this.view.interactive = true;
    this.view.hitArea = app.screen;
    this.view.on("pointermove", (e2) => {
      const { x: x2, y: y2 } = e2.data.getLocalPosition(this.view);
      this.mouse.x = x2 - this.renderShader.view.position.x;
      this.mouse.y = y2 - this.renderShader.view.position.y;
      this.mouse.x /= this.renderShader.view.scale.x;
      this.mouse.y /= this.renderShader.view.scale.y;
      this.repulsionShader.mouse = this.mouse;
      this.renderShader.mouse = this.mouse;
    });
    this.view.on("pointerup", () => {
      this.mouse.x = -2e3;
      this.mouse.y = -2e3;
      this.repulsionShader.mouse = this.mouse;
    });
  }
  getTexture(key) {
    if (!this.renderTextures[key]) {
      const brt = new BaseRenderTexture({
        width: this.heightTexture,
        height: this.widthTexture,
        scaleMode: SCALE_MODES.NEAREST,
        format: FORMATS.RGBA
      });
      const rt = new RenderTexture(brt);
      this.renderTextures[key] = rt;
    }
    return this.renderTextures[key];
  }
  get furryTextWidth() {
    return this.furryText.width * this.renderShader.view.scale.x;
  }
  get furryTextHeight() {
    return this.furryText.height * this.renderShader.view.scale.y;
  }
  onShow() {
    this.resetText();
  }
  resetText() {
    this.furryText.text = this.textContent;
    const points = this.furryText.points;
    const neighbours = this.furryText.neighbours;
    const scales = this.furryText.scales;
    const distances = this.furryText.distances;
    const charactersNotFound = this.furryText.charactersNotFound;
    const [widthTexture, heightTexture] = calculateTextureDimensions(
      points.length
    );
    this.widthTexture = widthTexture;
    this.heightTexture = heightTexture;
    this.resizeTextures();
    this.positionsShader.draw(points, widthTexture, heightTexture);
    this.constraintsShader.draw(
      neighbours,
      distances,
      scales,
      widthTexture,
      heightTexture
    );
    this.repulsionShader.draw(
      widthTexture,
      heightTexture,
      points.length,
      scales
    );
    this.simulationShader.draw(widthTexture, heightTexture, points.length);
    this.renderShader.draw(
      points.length / 2,
      widthTexture,
      heightTexture,
      scales
    );
    for (let i = 0; i < charactersNotFound.length; i++) {
      const { char, position, frame } = charactersNotFound[i];
      const text = new Text(char, { fontSize: 400 });
      text.anchor.set(0.5);
      text.position.x = position[0];
      text.position.y = position[1];
      text.scale.set(Math.max(frame[0] / text.width, frame[1] / text.height));
      this.renderShader.addExtraChar(text);
    }
    app.renderer.render(this.positionsShader.mesh, {
      renderTexture: this.getTexture("originalPositions"),
      clear: true
    });
    app.renderer.render(this.positionsShader.mesh, {
      renderTexture: this.getTexture("position1"),
      clear: true
    });
    app.renderer.render(this.positionsShader.mesh, {
      renderTexture: this.getTexture("position2"),
      clear: true
    });
    app.renderer.render(this.positionsShader.mesh, {
      renderTexture: this.getTexture("prevPosition1"),
      clear: true
    });
    app.renderer.render(this.positionsShader.mesh, {
      renderTexture: this.getTexture("prevPosition2"),
      clear: true
    });
    this.onResize(this.w, this.h);
    this.repulsionShader.material.uniforms.textureOriginalPositions = this.getTexture("originalPositions");
  }
  resizeTextures() {
    Object.values(this.renderTextures).forEach((rt) => {
      rt.resize(this.widthTexture, this.heightTexture, true);
    });
  }
  swap(key1, key2) {
    let temp2 = this.renderTextures[key1];
    this.renderTextures[key1] = this.renderTextures[key2];
    this.renderTextures[key2] = temp2;
  }
  update() {
    this.repulsionShader.material.uniforms.texturePositions = this.getTexture(`position1`);
    app.renderer.render(this.repulsionShader.mesh, {
      renderTexture: this.getTexture(`position2`),
      clear: true
    });
    app.renderer.render(this.repulsionShader.mesh, {
      renderTexture: this.getTexture("prevPosition1"),
      clear: true
    });
    this.swap("position1", "position2");
    this.simulationShader.material.uniforms.textureCurrentPosition = this.getTexture("position1");
    this.simulationShader.material.uniforms.texturePrevPosition = this.getTexture("prevPosition2");
    app.renderer.render(this.simulationShader.mesh, {
      renderTexture: this.getTexture("position2"),
      clear: true
    });
    this.swap("position1", "position2");
    this.swap("prevPosition1", "prevPosition2");
    for (let i = 0; i < 10; i++) {
      this.constraintsShader.material.uniforms.texturePosition = this.getTexture("position1");
      app.renderer.render(this.constraintsShader.mesh, {
        renderTexture: this.getTexture("position2"),
        clear: true
      });
      this.swap("position1", "position2");
    }
    this.swap("position1", "position2");
    this.renderShader.material.uniforms.texturePositions = this.getTexture("position1");
    this.renderShader.update();
  }
  resizeMesh() {
    const scaleMesh = Math.min(
      1,
      this.w * 0.8 / this.furryText.width,
      this.h * 0.8 / this.furryText.height
    );
    this.renderShader.setScale(scaleMesh);
    this.renderShader.setPosition(
      this.w / 2 - this.furryText.width / 2 * scaleMesh,
      this.h / 2 - this.furryText.height / 2 * scaleMesh
    );
  }
  onResize(w2, h2) {
    this.resizeMesh();
    if (debugMode) {
      const widthFbo = 128;
      this.fboContainer.removeChildren();
      Object.entries(this.renderTextures).forEach(([key, rt], i) => {
        const fboHelper = new Sprite(rt);
        fboHelper.width = widthFbo;
        fboHelper.height = widthFbo;
        fboHelper.position.x = widthFbo * i;
        const text = new Text(key, { fontSize: 10 });
        fboHelper.addChild(text);
        text.position.x = fboHelper.position.x + 5;
        text.anchor.y = 1;
        text.position.y = -10;
        this.fboContainer.addChild(fboHelper, text);
      });
      this.fboContainer.position.y = h2 - widthFbo;
    }
  }
  export() {
    return {};
  }
}
var assets = {
  images: [
    { src: "/assets/images/furry-ball.png" },
    { src: "/assets/images/fuzz_piece_04.png" }
  ],
  fonts: ["Montserrat:800", "Montserrat:400", "Montserrat:700"]
};
var events = { exports: {} };
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
  if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
  }
  this._maxListeners = n2;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type2) {
  var args = [];
  for (var i = 1; i < arguments.length; i++)
    args.push(arguments[i]);
  var doError = type2 === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type2];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners2[i], this, args);
  }
  return true;
};
function _addListener(target, type2, listener, prepend) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit(
        "newListener",
        type2,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type2];
  }
  if (existing === void 0) {
    existing = events2[type2] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type2;
      w2.count = existing.length;
      ProcessEmitWarning(w2);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type2, listener) {
  return _addListener(this, type2, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
  return _addListener(this, type2, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type2, listener) {
  var state = { fired: false, wrapFn: void 0, target, type: type2, listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type2, listener) {
  checkListener(listener);
  this.on(type2, _onceWrap(this, type2, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
  checkListener(listener);
  this.prependListener(type2, _onceWrap(this, type2, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type2, listener) {
  var list, events2, position, i, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type2];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type2];
      if (events2.removeListener)
        this.emit("removeListener", type2, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type2] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type2, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {
  var listeners2, events2, i;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type2] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type2];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys3 = Object.keys(events2);
    var key;
    for (i = 0; i < keys3.length; ++i) {
      key = keys3[i];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type2];
  if (typeof listeners2 === "function") {
    this.removeListener(type2, listeners2);
  } else if (listeners2 !== void 0) {
    for (i = listeners2.length - 1; i >= 0; i--) {
      this.removeListener(type2, listeners2[i]);
    }
  }
  return this;
};
function _listeners(target, type2, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type2];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type2) {
  return _listeners(this, type2, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type2) {
  return _listeners(this, type2, false);
};
EventEmitter.listenerCount = function(emitter, type2) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type2);
  } else {
    return listenerCount.call(emitter, type2);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type2) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type2];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n2) {
  var copy = new Array(n2);
  for (var i = 0; i < n2; ++i)
    copy[i] = arr[i];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once2(emitter, name) {
  return new Promise(function(resolve2, reject2) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject2(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve2([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var Emitter = events.exports;
let app = null;
let renderer = null;
class MainApp extends Emitter {
  constructor(mConfig = {}) {
    super();
    this.isSupported = true;
    this._isPlaying = true;
    objectAssign(Config, mConfig);
    if (this.isSupported) {
      this.app = new Application({
        width: window.innerWidth,
        height: window.innerHeight,
        backgroundColor: 15658734,
        autoDensity: true,
        antialias: true,
        resolution: Math.max(window.devicePixelRatio || 1, 1.5)
      });
      app = this.app;
      renderer = this.app.renderer;
      mConfig.container.appendChild(this.app.view);
      this.app.resizeTo = window;
      const canvas = this.app.view;
      canvas.style.position = "fixed";
      canvas.style.top = 0;
      canvas.style.left = 0;
      this.stage = this.app.stage;
      this.preloader = new LoaderPixi({ optimize: false });
      this._loadAssets(mConfig.ASSETS_PATH || "assets/");
    } else {
      setTimeout(() => {
        this.emit("onError", {
          error: "Mobile not supported for this experiment"
        });
      }, 10);
    }
  }
  _loadAssets(assetsPath) {
    if (!this.isSupported)
      return;
    const images = assets.images.map((oAsset) => {
      oAsset.src = oAsset.src.replace("assets/", assetsPath);
      return oAsset;
    });
    this.preloader.addManifest(images || []);
    assets.fonts && this.preloader.addFonts(assets.fonts || []);
    assets.customFonts && this.preloader.addCustomFonts(assets.customFonts);
    assets.others && this.preloader.addOthers(current.assets.others);
    this.preloader.load();
    this.preloader.loader.onProgress.add((l2, p2) => {
      this.emit("onProgress", { percent: p2 });
    });
    this.preloader.onLoaderComplete.then(() => {
      this._onAssetsLoaded();
    });
  }
  _onAssetsLoaded(o2) {
    if (!this.isSupported)
      return;
    this.emit("onLoaded");
    this._initScenes();
  }
  onToggleSound() {
  }
  start() {
    if (!this.isSupported)
      return;
    this.app.ticker.add(this._update.bind(this));
  }
  play() {
    if (!this.isSupported)
      return;
    this._isPlaying = true;
  }
  pause() {
    if (!this.isSupported)
      return;
    this._isPlaying = false;
  }
  _initScenes() {
    if (!this.isSupported)
      return;
    setTimeout(() => {
      this.view = new Scene();
      this.stage.addChild(this.view.view);
      this.view.resize(this.w, this.h);
      this.view.show();
    }, 100);
  }
  _update() {
    if (!this.isSupported)
      return;
    this.view && this.view.update();
  }
  resize(w2, h2) {
    if (!this.isSupported)
      return;
    this.app.resize();
    this.view && this.view.resize(w2, h2);
  }
}
export { app, MainApp as default, renderer };
